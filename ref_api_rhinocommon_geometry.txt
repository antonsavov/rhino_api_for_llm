Rhino.Geometry.AngularDimension.AdjustFromPoints(self, plane: Rhino.Geometry.Plane, centerpoint: Rhino.Geometry.Point3d, defpoint1: Rhino.Geometry.Point3d, defpoint2: Rhino.Geometry.Point3d, dimlinepoint: Rhino.Geometry.Point3d) -> bool
Rhino.Geometry.AngularDimension.AdjustFromPoints(self, plane: Rhino.Geometry.Plane, extpoint1: Rhino.Geometry.Point3d, extpoint2: Rhino.Geometry.Point3d, dirpoint1: Rhino.Geometry.Point3d, dirpoint2: Rhino.Geometry.Point3d, dimlinepoint: Rhino.Geometry.Point3d) -> bool
Rhino.Geometry.AngularDimension.Create(dimStyle: Rhino.DocObjects.DimensionStyle, line1: Rhino.Geometry.Line, pointOnLine1: Rhino.Geometry.Point3d, line2: Rhino.Geometry.Line, pointOnLine2: Rhino.Geometry.Point3d, pointOnAngularDimensionArc: Rhino.Geometry.Point3d, bSetExtensionPoints: bool) -> Rhino.Geometry.AngularDimension
Rhino.Geometry.AngularDimension.Create(dimStyle: Rhino.DocObjects.DimensionStyle, plane: Rhino.Geometry.Plane, horizontal: Rhino.Geometry.Vector3d, centerpoint: Rhino.Geometry.Point3d, defpoint1: Rhino.Geometry.Point3d, defpoint2: Rhino.Geometry.Point3d, dimlinepoint: Rhino.Geometry.Point3d) -> Rhino.Geometry.AngularDimension
Rhino.Geometry.AngularDimension.Create(dimStyle: Rhino.DocObjects.DimensionStyle, plane: Rhino.Geometry.Plane, horizontal: Rhino.Geometry.Vector3d, extpoint1: Rhino.Geometry.Point3d, extpoint2: Rhino.Geometry.Point3d, dirpoint1: Rhino.Geometry.Point3d, dirpoint2: Rhino.Geometry.Point3d, dimlinepoint: Rhino.Geometry.Point3d) -> Rhino.Geometry.AngularDimension
Rhino.Geometry.AngularDimension.Get3dPoints(self, centerpoint: Rhino.Geometry.Point3d@, defpoint1: Rhino.Geometry.Point3d@, defpoint2: Rhino.Geometry.Point3d@, arrowpoint1: Rhino.Geometry.Point3d@, arrowpoint2: Rhino.Geometry.Point3d@, dimlinepoint: Rhino.Geometry.Point3d@, textpoint: Rhino.Geometry.Point3d@) -> bool
Rhino.Geometry.AngularDimension.GetAngleDisplayText(self, style: Rhino.DocObjects.DimensionStyle) -> str
Rhino.Geometry.AngularDimension.GetDisplayLines(self, style: Rhino.DocObjects.DimensionStyle, scale: float, lines: Rhino.Geometry.Line[]@, arcs: Rhino.Geometry.Arc[]@) -> bool
Rhino.Geometry.AngularDimension.GetTextRectangle(self, corners: Rhino.Geometry.Point3d[]@) -> bool
Rhino.Geometry.AngularDimension.[ObsoleteAttribute(self, arg1: System.Guid, arg2: Rhino.Geometry.Plane, arg3: Rhino.Geometry.Point3d, arg4: Rhino.Geometry.Point3d, arg5: Rhino.Geometry.Point3d, arg6: Rhino.Geometry.Point3d, arg7: Rhino.Geometry.Point3d) -> None
Rhino.Geometry.AngularDimension.__init__(self) -> None
Rhino.Geometry.AngularDimension.__init__(self, arc: Rhino.Geometry.Arc, offset: float) -> None
Rhino.Geometry.AngularDimension.__init__(self, info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext) -> None
Rhino.Geometry.AngularDimension.__init__(self, line1: Rhino.Geometry.Line, pointOnLine1: Rhino.Geometry.Point3d, line2: Rhino.Geometry.Line, pointOnLine2: Rhino.Geometry.Point3d, pointOnAngularDimensionArc: Rhino.Geometry.Point3d, bSetExtensionPoints: bool) -> None
Rhino.Geometry.AngularDimension.__init__(self, plane: Rhino.Geometry.Plane, horizontal: Rhino.Geometry.Vector3d, centerpoint: Rhino.Geometry.Point3d, defpoint1: Rhino.Geometry.Point3d, defpoint2: Rhino.Geometry.Point3d, dimlinepoint: Rhino.Geometry.Point3d) -> None
Rhino.Geometry.AngularDimension.__init__(self, plane: Rhino.Geometry.Plane, horizontal: Rhino.Geometry.Vector3d, extpoint1: Rhino.Geometry.Point3d, extpoint2: Rhino.Geometry.Point3d, dirpoint1: Rhino.Geometry.Point3d, dirpoint2: Rhino.Geometry.Point3d, dimlinepoint: Rhino.Geometry.Point3d) -> None
Rhino.Geometry.AnnotationBase.ClearPropertyOverrides(self) -> bool
Rhino.Geometry.AnnotationBase.FirstCharProperties(rtf_str: str, bold: System.Boolean@, italic: System.Boolean@, underline: System.Boolean@, facename: System.String@) -> bool
Rhino.Geometry.AnnotationBase.FormatRtfString(rtf_in: str, clear_bold: bool, set_bold: bool, clear_italic: bool, set_italic: bool, clear_underline: bool, set_underline: bool, clear_facename: bool, set_facename: bool, facename: str) -> str
Rhino.Geometry.AnnotationBase.GetBoundingBox(self, xform: Rhino.Geometry.Transform) -> BoundingBox
Rhino.Geometry.AnnotationBase.GetDimensionScale(doc: Rhino.RhinoDoc, dimstyle: Rhino.DocObjects.DimensionStyle, vport: Rhino.Display.RhinoViewport) -> float
Rhino.Geometry.AnnotationBase.GetDimensionStyle(self, parentDimStyle: Rhino.DocObjects.DimensionStyle) -> DimensionStyle
Rhino.Geometry.AnnotationBase.GetPlainTextWithRunMap(self, map: System.Int32[]@) -> str
Rhino.Geometry.AnnotationBase.IsAllBold(self) -> bool
Rhino.Geometry.AnnotationBase.IsAllItalic(self) -> bool
Rhino.Geometry.AnnotationBase.IsAllUnderlined(self) -> bool
Rhino.Geometry.AnnotationBase.IsPropertyOverridden(self, arg1: Rhino.DocObjects.DimensionStyle.Field) -> bool
Rhino.Geometry.AnnotationBase.PlainTextToRtf(str: str) -> str
Rhino.Geometry.AnnotationBase.RunReplace(self, replaceString: str, startRunIndex: int, startRunPosition: int, endRunIndex: int, endRunPosition: int) -> bool
Rhino.Geometry.AnnotationBase.SetBold(self, set_on: bool) -> bool
Rhino.Geometry.AnnotationBase.SetFacename(self, set_on: bool, facename: str) -> bool
Rhino.Geometry.AnnotationBase.SetItalic(self, set_on: bool) -> bool
Rhino.Geometry.AnnotationBase.SetOverrideDimStyle(self, OverrideStyle: Rhino.DocObjects.DimensionStyle) -> bool
Rhino.Geometry.AnnotationBase.SetRichText(self, rtfText: str, dimstyle: Rhino.DocObjects.DimensionStyle) -> None
Rhino.Geometry.AnnotationBase.SetUnderline(self, set_on: bool) -> bool
Rhino.Geometry.AnnotationBase.WrapText(self) -> None
Rhino.Geometry.AnnotationBase.__init__(self) -> None
Rhino.Geometry.AnnotationBase.__init__(self, info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext) -> None
Rhino.Geometry.Arc.!=(a: Rhino.Geometry.Arc, b: Rhino.Geometry.Arc) -> operator
Rhino.Geometry.Arc.==(a: Rhino.Geometry.Arc, b: Rhino.Geometry.Arc) -> operator
Rhino.Geometry.Arc.BoundingBox(self) -> BoundingBox
Rhino.Geometry.Arc.ClosestParameter(self, testPoint: Rhino.Geometry.Point3d) -> float
Rhino.Geometry.Arc.ClosestPoint(self, testPoint: Rhino.Geometry.Point3d) -> Point3d
Rhino.Geometry.Arc.EpsilonEquals(self, other: Rhino.Geometry.Arc, epsilon: float) -> bool
Rhino.Geometry.Arc.Equals(self, obj: Any) -> bool
Rhino.Geometry.Arc.Equals(self, other: Rhino.Geometry.Arc) -> bool
Rhino.Geometry.Arc.GetHashCode(self) -> int
Rhino.Geometry.Arc.PointAt(self, t: float) -> Point3d
Rhino.Geometry.Arc.Reverse(self) -> None
Rhino.Geometry.Arc.TangentAt(self, t: float) -> Vector3d
Rhino.Geometry.Arc.ToNurbsCurve(self) -> NurbsCurve
Rhino.Geometry.Arc.ToNurbsCurve(self, degree: int, cvCount: int) -> NurbsCurve
Rhino.Geometry.Arc.Transform(self, xform: Rhino.Geometry.Transform) -> bool
Rhino.Geometry.Arc.Trim(self, domain: Rhino.Geometry.Interval) -> bool
Rhino.Geometry.Arc.__init__(self, center: Rhino.Geometry.Point3d, radius: float, angleRadians: float) -> None
Rhino.Geometry.Arc.__init__(self, circle: Rhino.Geometry.Circle, angleIntervalRadians: Rhino.Geometry.Interval) -> None
Rhino.Geometry.Arc.__init__(self, circle: Rhino.Geometry.Circle, angleRadians: float) -> None
Rhino.Geometry.Arc.__init__(self, plane: Rhino.Geometry.Plane, center: Rhino.Geometry.Point3d, radius: float, angleRadians: float) -> None
Rhino.Geometry.Arc.__init__(self, plane: Rhino.Geometry.Plane, radius: float, angleRadians: float) -> None
Rhino.Geometry.Arc.__init__(self, pointA: Rhino.Geometry.Point3d, tangentA: Rhino.Geometry.Vector3d, pointB: Rhino.Geometry.Point3d) -> None
Rhino.Geometry.Arc.__init__(self, startPoint: Rhino.Geometry.Point3d, pointOnInterior: Rhino.Geometry.Point3d, endPoint: Rhino.Geometry.Point3d) -> None
Rhino.Geometry.ArcCurve.__init__(self) -> None
Rhino.Geometry.ArcCurve.__init__(self, arc: Rhino.Geometry.Arc) -> None
Rhino.Geometry.ArcCurve.__init__(self, arc: Rhino.Geometry.Arc, t0: float, t1: float) -> None
Rhino.Geometry.ArcCurve.__init__(self, circle: Rhino.Geometry.Circle) -> None
Rhino.Geometry.ArcCurve.__init__(self, circle: Rhino.Geometry.Circle, t0: float, t1: float) -> None
Rhino.Geometry.ArcCurve.__init__(self, info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext) -> None
Rhino.Geometry.ArcCurve.__init__(self, other: Rhino.Geometry.ArcCurve) -> None
Rhino.Geometry.AreaMassProperties.CentroidCoordinatesPrincipalMoments(self, x: System.Double@, xaxis: Rhino.Geometry.Vector3d@, y: System.Double@, yaxis: Rhino.Geometry.Vector3d@, z: System.Double@, zaxis: Rhino.Geometry.Vector3d@) -> bool
Rhino.Geometry.AreaMassProperties.CentroidCoordinatesPrincipalMomentsOfInertia(self, x: System.Double@, xaxis: Rhino.Geometry.Vector3d@, y: System.Double@, yaxis: Rhino.Geometry.Vector3d@, z: System.Double@, zaxis: Rhino.Geometry.Vector3d@) -> bool
Rhino.Geometry.AreaMassProperties.Compute(brep: Rhino.Geometry.Brep) -> Rhino.Geometry.AreaMassProperties
Rhino.Geometry.AreaMassProperties.Compute(brep: Rhino.Geometry.Brep, area: bool, firstMoments: bool, secondMoments: bool, productMoments: bool) -> Rhino.Geometry.AreaMassProperties
Rhino.Geometry.AreaMassProperties.Compute(brep: Rhino.Geometry.Brep, area: bool, firstMoments: bool, secondMoments: bool, productMoments: bool, relativeTolerance: float, absoluteTolerance: float) -> Rhino.Geometry.AreaMassProperties
Rhino.Geometry.AreaMassProperties.Compute(closedPlanarCurve: Rhino.Geometry.Curve) -> Rhino.Geometry.AreaMassProperties
Rhino.Geometry.AreaMassProperties.Compute(closedPlanarCurve: Rhino.Geometry.Curve, planarTolerance: float) -> Rhino.Geometry.AreaMassProperties
Rhino.Geometry.AreaMassProperties.Compute(geometry: Iterable[Rhino.Geometry.GeometryBase]) -> Rhino.Geometry.AreaMassProperties
Rhino.Geometry.AreaMassProperties.Compute(geometry: Iterable[Rhino.Geometry.GeometryBase], area: bool, firstMoments: bool, secondMoments: bool, productMoments: bool) -> Rhino.Geometry.AreaMassProperties
Rhino.Geometry.AreaMassProperties.Compute(hatch: Rhino.Geometry.Hatch) -> Rhino.Geometry.AreaMassProperties
Rhino.Geometry.AreaMassProperties.Compute(mesh: Rhino.Geometry.Mesh) -> Rhino.Geometry.AreaMassProperties
Rhino.Geometry.AreaMassProperties.Compute(mesh: Rhino.Geometry.Mesh, area: bool, firstMoments: bool, secondMoments: bool, productMoments: bool) -> Rhino.Geometry.AreaMassProperties
Rhino.Geometry.AreaMassProperties.Compute(surface: Rhino.Geometry.Surface) -> Rhino.Geometry.AreaMassProperties
Rhino.Geometry.AreaMassProperties.Compute(surface: Rhino.Geometry.Surface, area: bool, firstMoments: bool, secondMoments: bool, productMoments: bool) -> Rhino.Geometry.AreaMassProperties
Rhino.Geometry.AreaMassProperties.Dispose(self) -> None
Rhino.Geometry.AreaMassProperties.Dispose(self, disposing: bool) -> None
Rhino.Geometry.AreaMassProperties.Finalize(self) -> None
Rhino.Geometry.AreaMassProperties.WorldCoordinatesPrincipalMoments(self, x: System.Double@, xaxis: Rhino.Geometry.Vector3d@, y: System.Double@, yaxis: Rhino.Geometry.Vector3d@, z: System.Double@, zaxis: Rhino.Geometry.Vector3d@) -> bool
Rhino.Geometry.AreaMassProperties.WorldCoordinatesPrincipalMomentsOfInertia(self, x: System.Double@, xaxis: Rhino.Geometry.Vector3d@, y: System.Double@, yaxis: Rhino.Geometry.Vector3d@, z: System.Double@, zaxis: Rhino.Geometry.Vector3d@) -> bool
Rhino.Geometry.Arrowhead.__init__(self) -> None
Rhino.Geometry.Arrowhead.__init__(self, arg1: Rhino.DocObjects.DimensionStyle.ArrowType, arg2: System.Guid) -> None
Rhino.Geometry.BezierCurve.ChangeDimension(self, desiredDimension: int) -> bool
Rhino.Geometry.BezierCurve.CreateBeziers(sourceCurve: Rhino.Geometry.Curve) -> List[Rhino.Geometry.BezierCurve]
Rhino.Geometry.BezierCurve.CreateCubicBeziers(sourceCurve: Rhino.Geometry.Curve, distanceTolerance: float, kinkTolerance: float) -> List[Rhino.Geometry.BezierCurve]
Rhino.Geometry.BezierCurve.CreateLoftedBezier(points: Iterable[Rhino.Geometry.Point2d]) -> Rhino.Geometry.BezierCurve
Rhino.Geometry.BezierCurve.CreateLoftedBezier(points: Iterable[Rhino.Geometry.Point3d]) -> Rhino.Geometry.BezierCurve
Rhino.Geometry.BezierCurve.CurvatureAt(self, t: float) -> Vector3d
Rhino.Geometry.BezierCurve.Dispose(self) -> None
Rhino.Geometry.BezierCurve.Dispose(self, disposing: bool) -> None
Rhino.Geometry.BezierCurve.Finalize(self) -> None
Rhino.Geometry.BezierCurve.GetBoundingBox(self, accurate: bool) -> BoundingBox
Rhino.Geometry.BezierCurve.GetControlVertex2d(self, index: int) -> Point2d
Rhino.Geometry.BezierCurve.GetControlVertex3d(self, index: int) -> Point3d
Rhino.Geometry.BezierCurve.GetControlVertex4d(self, index: int) -> Point4d
Rhino.Geometry.BezierCurve.GetObjectData(self, info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext) -> None
Rhino.Geometry.BezierCurve.IncreaseDegree(self, desiredDegree: int) -> bool
Rhino.Geometry.BezierCurve.MakeNonRational(self) -> bool
Rhino.Geometry.BezierCurve.MakeRational(self) -> bool
Rhino.Geometry.BezierCurve.PointAt(self, t: float) -> Point3d
Rhino.Geometry.BezierCurve.Split(self, t: float, left: Rhino.Geometry.BezierCurve@, right: Rhino.Geometry.BezierCurve@) -> bool
Rhino.Geometry.BezierCurve.TangentAt(self, t: float) -> Vector3d
Rhino.Geometry.BezierCurve.ToNurbsCurve(self) -> NurbsCurve
Rhino.Geometry.BezierCurve.__init__(self, controlPoints: Iterable[Rhino.Geometry.Point2d]) -> None
Rhino.Geometry.BezierCurve.__init__(self, controlPoints: Iterable[Rhino.Geometry.Point3d]) -> None
Rhino.Geometry.BezierCurve.__init__(self, controlPoints: Iterable[Rhino.Geometry.Point4d]) -> None
Rhino.Geometry.BezierCurve.__init__(self, info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext) -> None
Rhino.Geometry.BezierSurface.ControlVertexCount(self, direction: int) -> int
Rhino.Geometry.BezierSurface.CreateLoftedBezier(curves: Iterable[Rhino.Geometry.BezierCurve]) -> Rhino.Geometry.BezierSurface
Rhino.Geometry.BezierSurface.Dispose(self) -> None
Rhino.Geometry.BezierSurface.Dispose(self, disposing: bool) -> None
Rhino.Geometry.BezierSurface.Domain(self, direction: int) -> Interval
Rhino.Geometry.BezierSurface.Finalize(self) -> None
Rhino.Geometry.BezierSurface.GetBoundingBox(self, accurate: bool) -> BoundingBox
Rhino.Geometry.BezierSurface.GetControlVertex2d(self, i: int, j: int) -> Point2d
Rhino.Geometry.BezierSurface.GetControlVertex3d(self, i: int, j: int) -> Point3d
Rhino.Geometry.BezierSurface.GetControlVertex4d(self, i: int, j: int) -> Point4d
Rhino.Geometry.BezierSurface.MakeNonRational(self) -> bool
Rhino.Geometry.BezierSurface.MakeRational(self) -> bool
Rhino.Geometry.BezierSurface.PointAt(self, u: float, v: float) -> Point3d
Rhino.Geometry.BezierSurface.Reverse(self, direction: int) -> Rhino.Geometry.BezierSurface
Rhino.Geometry.BezierSurface.Split(self, direction: int, t: float, left: Rhino.Geometry.BezierSurface@, right: Rhino.Geometry.BezierSurface@) -> bool
Rhino.Geometry.BezierSurface.ToNurbsSurface(self) -> NurbsSurface
Rhino.Geometry.BezierSurface.Transform(self, xform: Rhino.Geometry.Transform) -> bool
Rhino.Geometry.BezierSurface.Transpose(self) -> Rhino.Geometry.BezierSurface
Rhino.Geometry.BoundingBox.ClosestPoint(self, point: Rhino.Geometry.Point3d) -> Point3d
Rhino.Geometry.BoundingBox.ClosestPoint(self, point: Rhino.Geometry.Point3d, includeInterior: bool) -> Point3d
Rhino.Geometry.BoundingBox.Contains(self, box: Rhino.Geometry.BoundingBox) -> bool
Rhino.Geometry.BoundingBox.Contains(self, box: Rhino.Geometry.BoundingBox, strict: bool) -> bool
Rhino.Geometry.BoundingBox.Contains(self, point: Rhino.Geometry.Point3d) -> bool
Rhino.Geometry.BoundingBox.Contains(self, point: Rhino.Geometry.Point3d, strict: bool) -> bool
Rhino.Geometry.BoundingBox.Corner(self, minX: bool, minY: bool, minZ: bool) -> Point3d
Rhino.Geometry.BoundingBox.FurthestPoint(self, point: Rhino.Geometry.Point3d) -> Point3d
Rhino.Geometry.BoundingBox.GetCorners(self) -> List[Point3d]
Rhino.Geometry.BoundingBox.GetEdges(self) -> List[Line]
Rhino.Geometry.BoundingBox.Inflate(self, amount: float) -> None
Rhino.Geometry.BoundingBox.Inflate(self, xAmount: float, yAmount: float, zAmount: float) -> None
Rhino.Geometry.BoundingBox.Intersection(a: Rhino.Geometry.BoundingBox, b: Rhino.Geometry.BoundingBox) -> Rhino.Geometry.BoundingBox
Rhino.Geometry.BoundingBox.IsDegenerate(self, tolerance: float) -> int
Rhino.Geometry.BoundingBox.MakeValid(self) -> bool
Rhino.Geometry.BoundingBox.PointAt(self, tx: float, ty: float, tz: float) -> Point3d
Rhino.Geometry.BoundingBox.ToBrep(self) -> Brep
Rhino.Geometry.BoundingBox.ToString(self) -> str
Rhino.Geometry.BoundingBox.Transform(self, xform: Rhino.Geometry.Transform) -> bool
Rhino.Geometry.BoundingBox.Union(a: Rhino.Geometry.BoundingBox, b: Rhino.Geometry.BoundingBox) -> Rhino.Geometry.BoundingBox
Rhino.Geometry.BoundingBox.Union(box: Rhino.Geometry.BoundingBox, point: Rhino.Geometry.Point3d) -> Rhino.Geometry.BoundingBox
Rhino.Geometry.BoundingBox.Union(self, other: Rhino.Geometry.BoundingBox) -> None
Rhino.Geometry.BoundingBox.Union(self, point: Rhino.Geometry.Point3d) -> None
Rhino.Geometry.BoundingBox.__init__(self, min: Rhino.Geometry.Point3d, max: Rhino.Geometry.Point3d) -> None
Rhino.Geometry.BoundingBox.__init__(self, minX: float, minY: float, minZ: float, maxX: float, maxY: float, maxZ: float) -> None
Rhino.Geometry.BoundingBox.__init__(self, points: Iterable[Rhino.Geometry.Point3d]) -> None
Rhino.Geometry.BoundingBox.__init__(self, points: Iterable[Rhino.Geometry.Point3d], xform: Rhino.Geometry.Transform) -> None
Rhino.Geometry.Box.ClosestPoint(self, point: Rhino.Geometry.Point3d) -> Point3d
Rhino.Geometry.Box.Contains(self, box: Rhino.Geometry.BoundingBox) -> bool
Rhino.Geometry.Box.Contains(self, box: Rhino.Geometry.BoundingBox, strict: bool) -> bool
Rhino.Geometry.Box.Contains(self, box: Rhino.Geometry.Box) -> bool
Rhino.Geometry.Box.Contains(self, box: Rhino.Geometry.Box, strict: bool) -> bool
Rhino.Geometry.Box.Contains(self, point: Rhino.Geometry.Point3d) -> bool
Rhino.Geometry.Box.Contains(self, point: Rhino.Geometry.Point3d, strict: bool) -> bool
Rhino.Geometry.Box.EpsilonEquals(self, other: Rhino.Geometry.Box, epsilon: float) -> bool
Rhino.Geometry.Box.FurthestPoint(self, point: Rhino.Geometry.Point3d) -> Point3d
Rhino.Geometry.Box.GetCorners(self) -> List[Point3d]
Rhino.Geometry.Box.Inflate(self, amount: float) -> None
Rhino.Geometry.Box.Inflate(self, xAmount: float, yAmount: float, zAmount: float) -> None
Rhino.Geometry.Box.MakeValid(self) -> bool
Rhino.Geometry.Box.PointAt(self, x: float, y: float, z: float) -> Point3d
Rhino.Geometry.Box.RepositionBasePlane(self, origin: Rhino.Geometry.Point3d) -> None
Rhino.Geometry.Box.ToBrep(self) -> Brep
Rhino.Geometry.Box.ToExtrusion(self) -> Extrusion
Rhino.Geometry.Box.Transform(self, xform: Rhino.Geometry.Transform) -> bool
Rhino.Geometry.Box.Union(self, point: Rhino.Geometry.Point3d) -> None
Rhino.Geometry.Box.__init__(self, basePlane: Rhino.Geometry.Plane, boundingbox: Rhino.Geometry.BoundingBox) -> None
Rhino.Geometry.Box.__init__(self, basePlane: Rhino.Geometry.Plane, geometry: Rhino.Geometry.GeometryBase) -> None
Rhino.Geometry.Box.__init__(self, basePlane: Rhino.Geometry.Plane, points: Iterable[Rhino.Geometry.Point3d]) -> None
Rhino.Geometry.Box.__init__(self, basePlane: Rhino.Geometry.Plane, xSize: Rhino.Geometry.Interval, ySize: Rhino.Geometry.Interval, zSize: Rhino.Geometry.Interval) -> None
Rhino.Geometry.Box.__init__(self, bbox: Rhino.Geometry.BoundingBox) -> None
Rhino.Geometry.Box.__init__(self, other: Rhino.Geometry.Box) -> None
Rhino.Geometry.Brep.AddEdgeCurve(self, curve: Rhino.Geometry.Curve) -> int
Rhino.Geometry.Brep.AddSurface(self, surface: Rhino.Geometry.Surface) -> int
Rhino.Geometry.Brep.AddTrimCurve(self, curve: Rhino.Geometry.Curve) -> int
Rhino.Geometry.Brep.Append(self, other: Rhino.Geometry.Brep) -> None
Rhino.Geometry.Brep.CapPlanarHoles(self, tolerance: float) -> Rhino.Geometry.Brep
Rhino.Geometry.Brep.ChangeSeam(face: Rhino.Geometry.BrepFace, direction: int, parameter: float, tolerance: float) -> Rhino.Geometry.Brep
Rhino.Geometry.Brep.ClosestPoint(self, testPoint: Rhino.Geometry.Point3d) -> Point3d
Rhino.Geometry.Brep.ClosestPoint(self, testPoint: Rhino.Geometry.Point3d, closestPoint: Rhino.Geometry.Point3d@, ci: Rhino.Geometry.ComponentIndex@, s: System.Double@, t: System.Double@, maximumDistance: float, normal: Rhino.Geometry.Vector3d@) -> bool
Rhino.Geometry.Brep.Compact(self) -> None
Rhino.Geometry.Brep.CopyTrimCurves(trimSource: Rhino.Geometry.BrepFace, surfaceSource: Rhino.Geometry.Surface, tolerance: float) -> Rhino.Geometry.Brep
Rhino.Geometry.Brep.CreateBaseballSphere(center: Rhino.Geometry.Point3d, radius: float, tolerance: float) -> Rhino.Geometry.Brep
Rhino.Geometry.Brep.CreateBlendShape(face0: Rhino.Geometry.BrepFace, edge0: Rhino.Geometry.BrepEdge, t0: float, rev0: bool, continuity0: Rhino.Geometry.BlendContinuity, face1: Rhino.Geometry.BrepFace, edge1: Rhino.Geometry.BrepEdge, t1: float, rev1: bool, continuity1: Rhino.Geometry.BlendContinuity) -> Curve
Rhino.Geometry.Brep.CreateBlendSurface(face0: Rhino.Geometry.BrepFace, edge0: Rhino.Geometry.BrepEdge, domain0: Rhino.Geometry.Interval, rev0: bool, continuity0: Rhino.Geometry.BlendContinuity, face1: Rhino.Geometry.BrepFace, edge1: Rhino.Geometry.BrepEdge, domain1: Rhino.Geometry.Interval, rev1: bool, continuity1: Rhino.Geometry.BlendContinuity) -> List[Rhino.Geometry.Brep]
Rhino.Geometry.Brep.CreateBooleanDifference(firstBrep: Rhino.Geometry.Brep, secondBrep: Rhino.Geometry.Brep, tolerance: float) -> List[Rhino.Geometry.Brep]
Rhino.Geometry.Brep.CreateBooleanDifference(firstBrep: Rhino.Geometry.Brep, secondBrep: Rhino.Geometry.Brep, tolerance: float, manifoldOnly: bool) -> List[Rhino.Geometry.Brep]
Rhino.Geometry.Brep.CreateBooleanDifference(firstSet: Iterable[Rhino.Geometry.Brep], secondSet: Iterable[Rhino.Geometry.Brep], tolerance: float) -> List[Rhino.Geometry.Brep]
Rhino.Geometry.Brep.CreateBooleanDifference(firstSet: Iterable[Rhino.Geometry.Brep], secondSet: Iterable[Rhino.Geometry.Brep], tolerance: float, manifoldOnly: bool) -> List[Rhino.Geometry.Brep]
Rhino.Geometry.Brep.CreateBooleanDifferenceWithIndexMap(firstSet: Iterable[Rhino.Geometry.Brep], secondSet: Iterable[Rhino.Geometry.Brep], tolerance: float, manifoldOnly: bool, indexMap: System.Int32[]@) -> List[Rhino.Geometry.Brep]
Rhino.Geometry.Brep.CreateBooleanIntersection(firstBrep: Rhino.Geometry.Brep, secondBrep: Rhino.Geometry.Brep, tolerance: float) -> List[Rhino.Geometry.Brep]
Rhino.Geometry.Brep.CreateBooleanIntersection(firstBrep: Rhino.Geometry.Brep, secondBrep: Rhino.Geometry.Brep, tolerance: float, manifoldOnly: bool) -> List[Rhino.Geometry.Brep]
Rhino.Geometry.Brep.CreateBooleanIntersection(firstSet: Iterable[Rhino.Geometry.Brep], secondSet: Iterable[Rhino.Geometry.Brep], tolerance: float) -> List[Rhino.Geometry.Brep]
Rhino.Geometry.Brep.CreateBooleanIntersection(firstSet: Iterable[Rhino.Geometry.Brep], secondSet: Iterable[Rhino.Geometry.Brep], tolerance: float, manifoldOnly: bool) -> List[Rhino.Geometry.Brep]
Rhino.Geometry.Brep.CreateBooleanSplit(firstBrep: Rhino.Geometry.Brep, secondBrep: Rhino.Geometry.Brep, tolerance: float) -> List[Rhino.Geometry.Brep]
Rhino.Geometry.Brep.CreateBooleanSplit(firstSet: Iterable[Rhino.Geometry.Brep], secondSet: Iterable[Rhino.Geometry.Brep], tolerance: float) -> List[Rhino.Geometry.Brep]
Rhino.Geometry.Brep.CreateBooleanUnion(breps: Iterable[Rhino.Geometry.Brep], tolerance: float) -> List[Rhino.Geometry.Brep]
Rhino.Geometry.Brep.CreateBooleanUnion(breps: Iterable[Rhino.Geometry.Brep], tolerance: float, manifoldOnly: bool) -> List[Rhino.Geometry.Brep]
Rhino.Geometry.Brep.CreateBooleanUnion(breps: Iterable[Rhino.Geometry.Brep], tolerance: float, manifoldOnly: bool, nakedEdgePoints: Rhino.Geometry.Point3d[]@, badIntersectionPoints: Rhino.Geometry.Point3d[]@, nonManifoldEdgePoints: Rhino.Geometry.Point3d[]@) -> List[Rhino.Geometry.Brep]
Rhino.Geometry.Brep.CreateChamferSurface(face0: Rhino.Geometry.BrepFace, uv0: Rhino.Geometry.Point2d, radius0: float, face1: Rhino.Geometry.BrepFace, uv1: Rhino.Geometry.Point2d, radius1: float, extend: bool, tolerance: float) -> List[Rhino.Geometry.Brep]
Rhino.Geometry.Brep.CreateChamferSurface(face0: Rhino.Geometry.BrepFace, uv0: Rhino.Geometry.Point2d, radius0: float, face1: Rhino.Geometry.BrepFace, uv1: Rhino.Geometry.Point2d, radius1: float, trim: bool, extend: bool, tolerance: float, outBreps0: Rhino.Geometry.Brep[]@, outBreps1: Rhino.Geometry.Brep[]@) -> List[Rhino.Geometry.Brep]
Rhino.Geometry.Brep.CreateContourCurves(brepToContour: Rhino.Geometry.Brep, contourStart: Rhino.Geometry.Point3d, contourEnd: Rhino.Geometry.Point3d, interval: float) -> List[Curve]
Rhino.Geometry.Brep.CreateContourCurves(brepToContour: Rhino.Geometry.Brep, sectionPlane: Rhino.Geometry.Plane) -> List[Curve]
Rhino.Geometry.Brep.CreateCurvatureAnalysisMesh(brep: Rhino.Geometry.Brep, state: Rhino.ApplicationSettings.CurvatureAnalysisSettingsState) -> List[Mesh]
Rhino.Geometry.Brep.CreateDevelopableLoft(crv0: Rhino.Geometry.Curve, crv1: Rhino.Geometry.Curve, reverse0: bool, reverse1: bool, density: int) -> List[Rhino.Geometry.Brep]
Rhino.Geometry.Brep.CreateDevelopableLoft(rail0: Rhino.Geometry.NurbsCurve, rail1: Rhino.Geometry.NurbsCurve, fixedRulings: Iterable[Rhino.Geometry.Point2d]) -> List[Rhino.Geometry.Brep]
Rhino.Geometry.Brep.CreateEdgeSurface(curves: Iterable[Rhino.Geometry.Curve]) -> Rhino.Geometry.Brep
Rhino.Geometry.Brep.CreateFilletEdges(brep: Rhino.Geometry.Brep, edgeIndices: Iterable[int], startRadii: Iterable[float], endRadii: Iterable[float], blendType: Rhino.Geometry.BlendType, railType: Rhino.Geometry.RailType, setbackFillets: bool, tolerance: float, angleTolerance: float) -> List[Rhino.Geometry.Brep]
Rhino.Geometry.Brep.CreateFilletEdges(brep: Rhino.Geometry.Brep, edgeIndices: Iterable[int], startRadii: Iterable[float], endRadii: Iterable[float], blendType: Rhino.Geometry.BlendType, railType: Rhino.Geometry.RailType, tolerance: float) -> List[Rhino.Geometry.Brep]
Rhino.Geometry.Brep.CreateFilletEdgesVariableRadius(brep: Rhino.Geometry.Brep, edgeIndices: Iterable[int], edgeDistances: Dict[int, List[Rhino.Geometry.BrepEdgeFilletDistance]], blendType: Rhino.Geometry.BlendType, railType: Rhino.Geometry.RailType, setbackFillets: bool, tolerance: float, angleTolerance: float) -> List[Rhino.Geometry.Brep]
Rhino.Geometry.Brep.CreateFilletSurface(face0: Rhino.Geometry.BrepFace, uv0: Rhino.Geometry.Point2d, face1: Rhino.Geometry.BrepFace, uv1: Rhino.Geometry.Point2d, radius: float, extend: bool, tolerance: float) -> List[Rhino.Geometry.Brep]
Rhino.Geometry.Brep.CreateFilletSurface(face0: Rhino.Geometry.BrepFace, uv0: Rhino.Geometry.Point2d, face1: Rhino.Geometry.BrepFace, uv1: Rhino.Geometry.Point2d, radius: float, trim: bool, extend: bool, tolerance: float, outBreps0: Rhino.Geometry.Brep[]@, outBreps1: Rhino.Geometry.Brep[]@) -> List[Rhino.Geometry.Brep]
Rhino.Geometry.Brep.CreateFromBox(box: Rhino.Geometry.BoundingBox) -> Rhino.Geometry.Brep
Rhino.Geometry.Brep.CreateFromBox(box: Rhino.Geometry.Box) -> Rhino.Geometry.Brep
Rhino.Geometry.Brep.CreateFromBox(corners: Iterable[Rhino.Geometry.Point3d]) -> Rhino.Geometry.Brep
Rhino.Geometry.Brep.CreateFromCone(cone: Rhino.Geometry.Cone, capBottom: bool) -> Rhino.Geometry.Brep
Rhino.Geometry.Brep.CreateFromCornerPoints(corner1: Rhino.Geometry.Point3d, corner2: Rhino.Geometry.Point3d, corner3: Rhino.Geometry.Point3d, corner4: Rhino.Geometry.Point3d, tolerance: float) -> Rhino.Geometry.Brep
Rhino.Geometry.Brep.CreateFromCornerPoints(corner1: Rhino.Geometry.Point3d, corner2: Rhino.Geometry.Point3d, corner3: Rhino.Geometry.Point3d, tolerance: float) -> Rhino.Geometry.Brep
Rhino.Geometry.Brep.CreateFromCylinder(cylinder: Rhino.Geometry.Cylinder, capBottom: bool, capTop: bool) -> Rhino.Geometry.Brep
Rhino.Geometry.Brep.CreateFromJoinedEdges(brep0: Rhino.Geometry.Brep, edgeIndex0: int, brep1: Rhino.Geometry.Brep, edgeIndex1: int, joinTolerance: float) -> Rhino.Geometry.Brep
Rhino.Geometry.Brep.CreateFromLoft(curves: Iterable[Rhino.Geometry.Curve], start: Rhino.Geometry.Point3d, end: Rhino.Geometry.Point3d, StartTangent: bool, EndTangent: bool, StartTrim: Rhino.Geometry.BrepTrim, EndTrim: Rhino.Geometry.BrepTrim, loftType: Rhino.Geometry.LoftType, closed: bool) -> List[Rhino.Geometry.Brep]
Rhino.Geometry.Brep.CreateFromLoft(curves: Iterable[Rhino.Geometry.Curve], start: Rhino.Geometry.Point3d, end: Rhino.Geometry.Point3d, loftType: Rhino.Geometry.LoftType, closed: bool) -> List[Rhino.Geometry.Brep]
Rhino.Geometry.Brep.CreateFromLoft(curves: Iterable[Rhino.Geometry.Curve], start: Rhino.Geometry.Point3d, end: Rhino.Geometry.Point3d, loftType: Rhino.Geometry.LoftType, closed: bool, angleTol: float) -> List[Rhino.Geometry.Brep]
Rhino.Geometry.Brep.CreateFromLoftRebuild(curves: Iterable[Rhino.Geometry.Curve], start: Rhino.Geometry.Point3d, end: Rhino.Geometry.Point3d, loftType: Rhino.Geometry.LoftType, closed: bool, angleTol: float, rebuildPointCount: int) -> List[Rhino.Geometry.Brep]
Rhino.Geometry.Brep.CreateFromLoftRebuild(curves: Iterable[Rhino.Geometry.Curve], start: Rhino.Geometry.Point3d, end: Rhino.Geometry.Point3d, loftType: Rhino.Geometry.LoftType, closed: bool, rebuildPointCount: int) -> List[Rhino.Geometry.Brep]
Rhino.Geometry.Brep.CreateFromLoftRefit(curves: Iterable[Rhino.Geometry.Curve], start: Rhino.Geometry.Point3d, end: Rhino.Geometry.Point3d, loftType: Rhino.Geometry.LoftType, closed: bool, angleTol: float, refitTolerance: float) -> List[Rhino.Geometry.Brep]
Rhino.Geometry.Brep.CreateFromLoftRefit(curves: Iterable[Rhino.Geometry.Curve], start: Rhino.Geometry.Point3d, end: Rhino.Geometry.Point3d, loftType: Rhino.Geometry.LoftType, closed: bool, refitTolerance: float) -> List[Rhino.Geometry.Brep]
Rhino.Geometry.Brep.CreateFromMatch(edge: Rhino.Geometry.BrepEdge, targetCurve: Rhino.Geometry.Curve, settings: Rhino.Geometry.MatchSrfSettings, matched: Rhino.Geometry.Brep@, target: Rhino.Geometry.Brep@) -> bool
Rhino.Geometry.Brep.CreateFromMatch(edge: Rhino.Geometry.BrepEdge, targetCurves: Iterable[Rhino.Geometry.Curve], settings: Rhino.Geometry.MatchSrfSettings, matched: Rhino.Geometry.Brep@, target: Rhino.Geometry.Brep@) -> bool
Rhino.Geometry.Brep.CreateFromMesh(mesh: Rhino.Geometry.Mesh, trimmedTriangles: bool) -> Rhino.Geometry.Brep
Rhino.Geometry.Brep.CreateFromOffsetFace(face: Rhino.Geometry.BrepFace, offsetDistance: float, offsetTolerance: float, bothSides: bool, createSolid: bool) -> Rhino.Geometry.Brep
Rhino.Geometry.Brep.CreateFromRevSurface(surface: Rhino.Geometry.RevSurface, capStart: bool, capEnd: bool) -> Rhino.Geometry.Brep
Rhino.Geometry.Brep.CreateFromSphere(sphere: Rhino.Geometry.Sphere) -> Rhino.Geometry.Brep
Rhino.Geometry.Brep.CreateFromSurface(surface: Rhino.Geometry.Surface) -> Rhino.Geometry.Brep
Rhino.Geometry.Brep.CreateFromSweep(rail1: Rhino.Geometry.Curve, rail2: Rhino.Geometry.Curve, shape: Rhino.Geometry.Curve, closed: bool, tolerance: float) -> List[Rhino.Geometry.Brep]
Rhino.Geometry.Brep.CreateFromSweep(rail1: Rhino.Geometry.Curve, rail2: Rhino.Geometry.Curve, shapes: Iterable[Rhino.Geometry.Curve], closed: bool, tolerance: float) -> List[Rhino.Geometry.Brep]
Rhino.Geometry.Brep.CreateFromSweep(rail1: Rhino.Geometry.Curve, rail2: Rhino.Geometry.Curve, shapes: Iterable[Rhino.Geometry.Curve], start: Rhino.Geometry.Point3d, end: Rhino.Geometry.Point3d, closed: bool, tolerance: float, rebuild: Rhino.Geometry.SweepRebuild, rebuildPointCount: int, refitTolerance: float, preserveHeight: bool) -> List[Rhino.Geometry.Brep]
Rhino.Geometry.Brep.CreateFromSweep(rail1: Rhino.Geometry.Curve, rail2: Rhino.Geometry.Curve, shapes: Iterable[Rhino.Geometry.Curve], start: Rhino.Geometry.Point3d, end: Rhino.Geometry.Point3d, closed: bool, tolerance: float, rebuild: Rhino.Geometry.SweepRebuild, rebuildPointCount: int, refitTolerance: float, preserveHeight: bool, autoAdjust: bool) -> List[Rhino.Geometry.Brep]
Rhino.Geometry.Brep.CreateFromSweep(rail: Rhino.Geometry.Curve, shape: Rhino.Geometry.Curve, closed: bool, tolerance: float) -> List[Rhino.Geometry.Brep]
Rhino.Geometry.Brep.CreateFromSweep(rail: Rhino.Geometry.Curve, shapes: Iterable[Rhino.Geometry.Curve], closed: bool, tolerance: float) -> List[Rhino.Geometry.Brep]
Rhino.Geometry.Brep.CreateFromSweep(rail: Rhino.Geometry.Curve, shapes: Iterable[Rhino.Geometry.Curve], startPoint: Rhino.Geometry.Point3d, endPoint: Rhino.Geometry.Point3d, frameType: Rhino.Geometry.SweepFrame, roadlikeNormal: Rhino.Geometry.Vector3d, closed: bool, blendType: Rhino.Geometry.SweepBlend, miterType: Rhino.Geometry.SweepMiter, tolerance: float, rebuildType: Rhino.Geometry.SweepRebuild, rebuildPointCount: int, refitTolerance: float) -> List[Rhino.Geometry.Brep]
Rhino.Geometry.Brep.CreateFromSweepInParts(rail1: Rhino.Geometry.Curve, rail2: Rhino.Geometry.Curve, shapes: Iterable[Rhino.Geometry.Curve], rail_params: Iterable[Rhino.Geometry.Point2d], closed: bool, tolerance: float) -> List[Rhino.Geometry.Brep]
Rhino.Geometry.Brep.CreateFromSweepSegmented(rail: Rhino.Geometry.Curve, shape: Rhino.Geometry.Curve, closed: bool, tolerance: float) -> List[Rhino.Geometry.Brep]
Rhino.Geometry.Brep.CreateFromSweepSegmented(rail: Rhino.Geometry.Curve, shapes: Iterable[Rhino.Geometry.Curve], closed: bool, tolerance: float) -> List[Rhino.Geometry.Brep]
Rhino.Geometry.Brep.CreateFromSweepSegmented(rail: Rhino.Geometry.Curve, shapes: Iterable[Rhino.Geometry.Curve], startPoint: Rhino.Geometry.Point3d, endPoint: Rhino.Geometry.Point3d, frameType: Rhino.Geometry.SweepFrame, roadlikeNormal: Rhino.Geometry.Vector3d, closed: bool, blendType: Rhino.Geometry.SweepBlend, miterType: Rhino.Geometry.SweepMiter, tolerance: float, rebuildType: Rhino.Geometry.SweepRebuild, rebuildPointCount: int, refitTolerance: float) -> List[Rhino.Geometry.Brep]
Rhino.Geometry.Brep.CreateFromTaperedExtrude(curveToExtrude: Rhino.Geometry.Curve, distance: float, direction: Rhino.Geometry.Vector3d, basePoint: Rhino.Geometry.Point3d, draftAngleRadians: float, cornerType: Rhino.Geometry.ExtrudeCornerType, tolerance: float, angleToleranceRadians: float) -> List[Rhino.Geometry.Brep]
Rhino.Geometry.Brep.CreateFromTaperedExtrudeWithRef(curve: Rhino.Geometry.Curve, direction: Rhino.Geometry.Vector3d, distance: float, draftAngle: float, plane: Rhino.Geometry.Plane, tolerance: float) -> List[Rhino.Geometry.Brep]
Rhino.Geometry.Brep.CreateFromTorus(torus: Rhino.Geometry.Torus) -> Rhino.Geometry.Brep
Rhino.Geometry.Brep.CreateOffsetBrep(brep: Rhino.Geometry.Brep, distance: float, solid: bool, extend: bool, shrink: bool, tolerance: float, outBlends: Rhino.Geometry.Brep[]@, outWalls: Rhino.Geometry.Brep[]@) -> List[Rhino.Geometry.Brep]
Rhino.Geometry.Brep.CreateOffsetBrep(brep: Rhino.Geometry.Brep, distance: float, solid: bool, extend: bool, tolerance: float, outBlends: Rhino.Geometry.Brep[]@, outWalls: Rhino.Geometry.Brep[]@) -> List[Rhino.Geometry.Brep]
Rhino.Geometry.Brep.CreatePatch(geometry: Iterable[Rhino.Geometry.GeometryBase], startingSurface: Rhino.Geometry.Surface, tolerance: float) -> Rhino.Geometry.Brep
Rhino.Geometry.Brep.CreatePatch(geometry: Iterable[Rhino.Geometry.GeometryBase], startingSurface: Rhino.Geometry.Surface, uSpans: int, vSpans: int, trim: bool, tangency: bool, pointSpacing: float, flexibility: float, surfacePull: float, fixEdges: List[bool], tolerance: float) -> Rhino.Geometry.Brep
Rhino.Geometry.Brep.CreatePatch(geometry: Iterable[Rhino.Geometry.GeometryBase], uSpans: int, vSpans: int, tolerance: float) -> Rhino.Geometry.Brep
Rhino.Geometry.Brep.CreatePipe(rail: Rhino.Geometry.Curve, radius: float, localBlending: bool, cap: Rhino.Geometry.PipeCapMode, fitRail: bool, absoluteTolerance: float, angleToleranceRadians: float) -> List[Rhino.Geometry.Brep]
Rhino.Geometry.Brep.CreatePipe(rail: Rhino.Geometry.Curve, railRadiiParameters: Iterable[float], radii: Iterable[float], localBlending: bool, cap: Rhino.Geometry.PipeCapMode, fitRail: bool, absoluteTolerance: float, angleToleranceRadians: float) -> List[Rhino.Geometry.Brep]
Rhino.Geometry.Brep.CreatePlanarBreps(inputLoop: Rhino.Geometry.Curve, tolerance: float) -> List[Rhino.Geometry.Brep]
Rhino.Geometry.Brep.CreatePlanarBreps(inputLoops: Iterable[Rhino.Geometry.Curve], tolerance: float) -> List[Rhino.Geometry.Brep]
Rhino.Geometry.Brep.CreatePlanarBreps(inputLoops: Rhino.Collections.CurveList, tolerance: float) -> List[Rhino.Geometry.Brep]
Rhino.Geometry.Brep.CreatePlanarDifference(b0: Rhino.Geometry.Brep, b1: Rhino.Geometry.Brep, plane: Rhino.Geometry.Plane, tolerance: float) -> List[Rhino.Geometry.Brep]
Rhino.Geometry.Brep.CreatePlanarIntersection(b0: Rhino.Geometry.Brep, b1: Rhino.Geometry.Brep, plane: Rhino.Geometry.Plane, tolerance: float) -> List[Rhino.Geometry.Brep]
Rhino.Geometry.Brep.CreatePlanarUnion(b0: Rhino.Geometry.Brep, b1: Rhino.Geometry.Brep, plane: Rhino.Geometry.Plane, tolerance: float) -> List[Rhino.Geometry.Brep]
Rhino.Geometry.Brep.CreatePlanarUnion(breps: Iterable[Rhino.Geometry.Brep], plane: Rhino.Geometry.Plane, tolerance: float) -> List[Rhino.Geometry.Brep]
Rhino.Geometry.Brep.CreateQuadSphere(sphere: Rhino.Geometry.Sphere) -> Rhino.Geometry.Brep
Rhino.Geometry.Brep.CreateShell(brep: Rhino.Geometry.Brep, facesToRemove: Iterable[int], distance: float, tolerance: float) -> List[Rhino.Geometry.Brep]
Rhino.Geometry.Brep.CreateSolid(breps: Iterable[Rhino.Geometry.Brep], tolerance: float) -> List[Rhino.Geometry.Brep]
Rhino.Geometry.Brep.CreateThickPipe(rail: Rhino.Geometry.Curve, radius0: float, radius1: float, localBlending: bool, cap: Rhino.Geometry.PipeCapMode, fitRail: bool, absoluteTolerance: float, angleToleranceRadians: float) -> List[Rhino.Geometry.Brep]
Rhino.Geometry.Brep.CreateThickPipe(rail: Rhino.Geometry.Curve, railRadiiParameters: Iterable[float], radii0: Iterable[float], radii1: Iterable[float], localBlending: bool, cap: Rhino.Geometry.PipeCapMode, fitRail: bool, absoluteTolerance: float, angleToleranceRadians: float) -> List[Rhino.Geometry.Brep]
Rhino.Geometry.Brep.CreateTrimmedPlane(plane: Rhino.Geometry.Plane, curve: Rhino.Geometry.Curve) -> Rhino.Geometry.Brep
Rhino.Geometry.Brep.CreateTrimmedPlane(plane: Rhino.Geometry.Plane, curves: Iterable[Rhino.Geometry.Curve]) -> Rhino.Geometry.Brep
Rhino.Geometry.Brep.CreateTrimmedSurface(trimSource: Rhino.Geometry.BrepFace, surfaceSource: Rhino.Geometry.Surface, tolerance: float) -> Rhino.Geometry.Brep
Rhino.Geometry.Brep.CullUnused2dCurves(self) -> bool
Rhino.Geometry.Brep.CullUnused3dCurves(self) -> bool
Rhino.Geometry.Brep.CullUnusedEdges(self) -> bool
Rhino.Geometry.Brep.CullUnusedFaces(self) -> bool
Rhino.Geometry.Brep.CullUnusedLoops(self) -> bool
Rhino.Geometry.Brep.CullUnusedSurfaces(self) -> bool
Rhino.Geometry.Brep.CullUnusedTrims(self) -> bool
Rhino.Geometry.Brep.CullUnusedVertices(self) -> bool
Rhino.Geometry.Brep.CutUpSurface(surface: Rhino.Geometry.Surface, curves: Iterable[Rhino.Geometry.Curve], flip: bool, fitTolerance: float, keepTolerance: float) -> List[Rhino.Geometry.Brep]
Rhino.Geometry.Brep.CutUpSurface(surface: Rhino.Geometry.Surface, curves: Iterable[Rhino.Geometry.Curve], useEdgeCurves: bool, tolerance: float) -> List[Rhino.Geometry.Brep]
Rhino.Geometry.Brep.DestroyRegionTopology(self) -> None
Rhino.Geometry.Brep.Duplicate(self) -> GeometryBase
Rhino.Geometry.Brep.DuplicateBrep(self) -> Rhino.Geometry.Brep
Rhino.Geometry.Brep.DuplicateEdgeCurves(self) -> List[Curve]
Rhino.Geometry.Brep.DuplicateEdgeCurves(self, nakedOnly: bool) -> List[Curve]
Rhino.Geometry.Brep.DuplicateNakedEdgeCurves(self, nakedOuter: bool, nakedInner: bool) -> List[Curve]
Rhino.Geometry.Brep.DuplicateSubBrep(self, faceIndices: Iterable[int]) -> Rhino.Geometry.Brep
Rhino.Geometry.Brep.DuplicateVertices(self) -> List[Point3d]
Rhino.Geometry.Brep.ExtendBrepFacesToConnect(Face0: Rhino.Geometry.BrepFace, edgeIndex0: int, Face1: Rhino.Geometry.BrepFace, edgeIndex1: int, tol: float, angleTol: float, outBrep0: Rhino.Geometry.Brep@, outBrep1: Rhino.Geometry.Brep@) -> bool
Rhino.Geometry.Brep.ExtendBrepFacesToConnect(Face0: Rhino.Geometry.BrepFace, f0_sel_pt: Rhino.Geometry.Point3d, Face1: Rhino.Geometry.BrepFace, f1_sel_pt: Rhino.Geometry.Point3d, tol: float, angleTol: float, outBrep0: Rhino.Geometry.Brep@, outBrep1: Rhino.Geometry.Brep@) -> bool
Rhino.Geometry.Brep.FindCoincidentBrepComponents(self, point: Rhino.Geometry.Point3d, tolerance: float, faces: System.Int32[]@, edges: System.Int32[]@, vertices: System.Int32[]@) -> None
Rhino.Geometry.Brep.Flip(self) -> None
Rhino.Geometry.Brep.GetArea(self) -> float
Rhino.Geometry.Brep.GetArea(self, relativeTolerance: float, absoluteTolerance: float) -> float
Rhino.Geometry.Brep.GetConnectedComponents(self) -> List[Rhino.Geometry.Brep]
Rhino.Geometry.Brep.GetPointInside(self, tolerance: float, point: Rhino.Geometry.Point3d@) -> bool
Rhino.Geometry.Brep.GetRegions(self) -> List[BrepRegion]
Rhino.Geometry.Brep.GetTangentConnectedComponents(self, angleTolerance: float, includeMeshes: bool) -> List[Rhino.Geometry.Brep]
Rhino.Geometry.Brep.GetVolume(self) -> float
Rhino.Geometry.Brep.GetVolume(self, relativeTolerance: float, absoluteTolerance: float) -> float
Rhino.Geometry.Brep.GetWireframe(self, density: int) -> List[Curve]
Rhino.Geometry.Brep.InsetFaces(self, faceIndices: Iterable[int], distance: float, loose: bool, ignoreSeams: bool, creaseCorners: bool, tolerance: float, angleTolerance: float) -> Rhino.Geometry.Brep
Rhino.Geometry.Brep.IsBox(self) -> bool
Rhino.Geometry.Brep.IsBox(self, tolerance: float) -> bool
Rhino.Geometry.Brep.IsDuplicate(self, other: Rhino.Geometry.Brep, tolerance: float) -> bool
Rhino.Geometry.Brep.IsPointInside(self, point: Rhino.Geometry.Point3d, tolerance: float, strictlyIn: bool) -> bool
Rhino.Geometry.Brep.IsValidGeometry(self, log: System.String@) -> bool
Rhino.Geometry.Brep.IsValidTolerancesAndFlags(self, log: System.String@) -> bool
Rhino.Geometry.Brep.IsValidTopology(self, log: System.String@) -> bool
Rhino.Geometry.Brep.Join(self, otherBrep: Rhino.Geometry.Brep, tolerance: float, compact: bool) -> bool
Rhino.Geometry.Brep.JoinBreps(brepsToJoin: Iterable[Rhino.Geometry.Brep], tolerance: float) -> List[Rhino.Geometry.Brep]
Rhino.Geometry.Brep.JoinBreps(brepsToJoin: Iterable[Rhino.Geometry.Brep], tolerance: float, angleTolerance: float) -> List[Rhino.Geometry.Brep]
Rhino.Geometry.Brep.JoinBreps(brepsToJoin: Iterable[Rhino.Geometry.Brep], tolerance: float, angleTolerance: float, indexMap: System.Collections.Generic.List{System.Int32[]}@) -> List[Rhino.Geometry.Brep]
Rhino.Geometry.Brep.JoinEdges(self, edgeIndex0: int, edgeIndex1: int, joinTolerance: float, compact: bool) -> bool
Rhino.Geometry.Brep.JoinNakedEdges(self, tolerance: float) -> int
Rhino.Geometry.Brep.MakeValidForV2(self) -> bool
Rhino.Geometry.Brep.MergeBreps(brepsToMerge: Iterable[Rhino.Geometry.Brep], tolerance: float) -> Rhino.Geometry.Brep
Rhino.Geometry.Brep.MergeCoplanarFaces(self, faceIndex0: int, faceIndex1: int, tolerance: float, angleTolerance: float) -> bool
Rhino.Geometry.Brep.MergeCoplanarFaces(self, faceIndex: int, tolerance: float, angleTolerance: float) -> bool
Rhino.Geometry.Brep.MergeCoplanarFaces(self, tolerance: float) -> bool
Rhino.Geometry.Brep.MergeCoplanarFaces(self, tolerance: float, angleTolerance: float) -> bool
Rhino.Geometry.Brep.MergeSurfaces(brep0: Rhino.Geometry.Brep, brep1: Rhino.Geometry.Brep, tolerance: float, angleToleranceRadians: float) -> Rhino.Geometry.Brep
Rhino.Geometry.Brep.MergeSurfaces(brep0: Rhino.Geometry.Brep, brep1: Rhino.Geometry.Brep, tolerance: float, angleToleranceRadians: float, point0: Rhino.Geometry.Point2d, point1: Rhino.Geometry.Point2d, roundness: float, smooth: bool) -> Rhino.Geometry.Brep
Rhino.Geometry.Brep.MergeSurfaces(surface0: Rhino.Geometry.Surface, surface1: Rhino.Geometry.Surface, tolerance: float, angleToleranceRadians: float) -> Rhino.Geometry.Brep
Rhino.Geometry.Brep.PushPullExtend(self, faceIndex: int, transform: Rhino.Geometry.Transform, tolerance: float) -> Rhino.Geometry.Brep
Rhino.Geometry.Brep.RebuildTrimsForV2(self, face: Rhino.Geometry.BrepFace, nurbsSurface: Rhino.Geometry.NurbsSurface) -> None
Rhino.Geometry.Brep.RemoveFins(self) -> bool
Rhino.Geometry.Brep.RemoveHoles(self, loops: Iterable[Rhino.Geometry.ComponentIndex], tolerance: float) -> Rhino.Geometry.Brep
Rhino.Geometry.Brep.RemoveHoles(self, tolerance: float) -> Rhino.Geometry.Brep
Rhino.Geometry.Brep.Repair(self, tolerance: float) -> bool
Rhino.Geometry.Brep.SetTolerancesBoxesAndFlags(self) -> None
Rhino.Geometry.Brep.SetTolerancesBoxesAndFlags(self, bLazy: bool, bSetVertexTolerances: bool, bSetEdgeTolerances: bool, bSetTrimTolerances: bool, bSetTrimIsoFlags: bool, bSetTrimTypeFlags: bool, bSetLoopTypeFlags: bool, bSetTrimBoxes: bool) -> None
Rhino.Geometry.Brep.SetTrimIsoFlags(self) -> None
Rhino.Geometry.Brep.SetVertices(self) -> None
Rhino.Geometry.Brep.Split(self, cutter: Rhino.Geometry.Brep, intersectionTolerance: float) -> List[Rhino.Geometry.Brep]
Rhino.Geometry.Brep.Split(self, cutter: Rhino.Geometry.Brep, intersectionTolerance: float, toleranceWasRaised: System.Boolean@) -> List[Rhino.Geometry.Brep]
Rhino.Geometry.Brep.Split(self, cutters: Iterable[Rhino.Geometry.Brep], intersectionTolerance: float) -> List[Rhino.Geometry.Brep]
Rhino.Geometry.Brep.Split(self, cutters: Iterable[Rhino.Geometry.Curve], intersectionTolerance: float) -> List[Rhino.Geometry.Brep]
Rhino.Geometry.Brep.Split(self, cutters: Iterable[Rhino.Geometry.GeometryBase], normal: Rhino.Geometry.Vector3d, planView: bool, intersectionTolerance: float) -> List[Rhino.Geometry.Brep]
Rhino.Geometry.Brep.SplitDisjointPieces(brep: Rhino.Geometry.Brep) -> List[Rhino.Geometry.Brep]
Rhino.Geometry.Brep.SplitDisjointPieces(brep: Rhino.Geometry.Brep, indexMap: System.Collections.Generic.List{System.Int32[]}@) -> List[Rhino.Geometry.Brep]
Rhino.Geometry.Brep.Standardize(self) -> None
Rhino.Geometry.Brep.TransformComponent(self, components: Iterable[Rhino.Geometry.ComponentIndex], xform: Rhino.Geometry.Transform, tolerance: float, timeLimit: float, useMultipleThreads: bool) -> bool
Rhino.Geometry.Brep.Trim(self, cutter: Rhino.Geometry.Brep, intersectionTolerance: float) -> List[Rhino.Geometry.Brep]
Rhino.Geometry.Brep.Trim(self, cutter: Rhino.Geometry.Plane, intersectionTolerance: float) -> List[Rhino.Geometry.Brep]
Rhino.Geometry.Brep.TryConvertBrep(geometry: Rhino.Geometry.GeometryBase) -> Rhino.Geometry.Brep
Rhino.Geometry.Brep.UnjoinEdges(self, edgesToUnjoin: Iterable[int]) -> List[Rhino.Geometry.Brep]
Rhino.Geometry.Brep.[ObsoleteAttribute(self, arg1: Iterable[Rhino.Geometry.Curve]) -> None
Rhino.Geometry.Brep.[ObsoleteAttribute(self, arg1: Rhino.Collections.CurveList) -> None
Rhino.Geometry.Brep.[ObsoleteAttribute(self, arg1: Rhino.Geometry.BrepFace, arg2: Rhino.Geometry.Surface) -> None
Rhino.Geometry.Brep.[ObsoleteAttribute(self, arg1: Rhino.Geometry.Curve) -> None
Rhino.Geometry.Brep.[ObsoleteAttribute(self, arg1: Rhino.Geometry.Curve, arg2: float, arg3: Rhino.Geometry.Vector3d, arg4: Rhino.Geometry.Point3d, arg5: float, arg6: Rhino.Geometry.ExtrudeCornerType) -> None
Rhino.Geometry.Brep.__init__(self) -> None
Rhino.Geometry.Brep.__init__(self, info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext) -> None
Rhino.Geometry.BrepEdge.AdjacentFaces(self) -> List[int]
Rhino.Geometry.BrepEdge.ConcavityAt(self, t: float, tolerance: float) -> Concavity
Rhino.Geometry.BrepEdge.GetEdgeParameter(self, trimIndex: int, trimParameter: float, edgeParameter: System.Double@) -> bool
Rhino.Geometry.BrepEdge.IsSmoothManifoldEdge(self, angleToleranceRadians: float) -> bool
Rhino.Geometry.BrepEdge.SetEdgeCurve(self, curve3dIndex: int) -> bool
Rhino.Geometry.BrepEdge.SetEdgeCurve(self, curve3dIndex: int, subDomain: Rhino.Geometry.Interval) -> bool
Rhino.Geometry.BrepEdge.TrimIndices(self) -> List[int]
Rhino.Geometry.BrepEdgeFilletDistance.__init__(self, edgeParameter: float, filletDistance: float) -> None
Rhino.Geometry.BrepFace.AdjacentEdges(self) -> List[int]
Rhino.Geometry.BrepFace.AdjacentFaces(self) -> List[int]
Rhino.Geometry.BrepFace.ChangeSurface(self, surfaceIndex: int) -> bool
Rhino.Geometry.BrepFace.ClearMaterialChannelIndex(self) -> None
Rhino.Geometry.BrepFace.ClearPackId(self) -> None
Rhino.Geometry.BrepFace.CreateExtrusion(self, pathCurve: Rhino.Geometry.Curve, cap: bool) -> Brep
Rhino.Geometry.BrepFace.DraftAnglePoint(self, testPoint: Rhino.Geometry.Point2d, testAngle: float, pullDirection: Rhino.Geometry.Vector3d, edge: bool, draftPoint: Rhino.Geometry.Point3d@, draftAngle: System.Double@) -> bool
Rhino.Geometry.BrepFace.DuplicateFace(self, duplicateMeshes: bool) -> Brep
Rhino.Geometry.BrepFace.DuplicateSurface(self) -> Surface
Rhino.Geometry.BrepFace.FilletSurfaceToCurve(self, curve: Rhino.Geometry.Curve, t: float, u: float, v: float, radius: float, alignToCurve: int, railDegree: int, arcDegree: int, arcSliders: Iterable[float], numBezierSrfs: int, tolerance: float, out_fillets: List[Rhino.Geometry.Brep], fitResults: System.Double[]@) -> bool
Rhino.Geometry.BrepFace.FilletSurfaceToRail(self, curveOnFace: Rhino.Geometry.Curve, secondFace: Rhino.Geometry.BrepFace, u1: float, v1: float, railDegree: int, arcDegree: int, arcSliders: Iterable[float], numBezierSrfs: int, extend: bool, split_type: Rhino.Geometry.FilletSurfaceSplitType, tolerance: float, out_fillets: List[Rhino.Geometry.Brep], out_breps0: List[Rhino.Geometry.Brep], out_breps1: List[Rhino.Geometry.Brep], fitResults: System.Double[]@) -> bool
Rhino.Geometry.BrepFace.GetMesh(self, meshType: Rhino.Geometry.MeshType) -> Mesh
Rhino.Geometry.BrepFace.IsPointOnFace(self, u: float, v: float) -> PointFaceRelation
Rhino.Geometry.BrepFace.IsPointOnFace(self, u: float, v: float, tolerance: float) -> PointFaceRelation
Rhino.Geometry.BrepFace.PullPointsToFace(self, points: Iterable[Rhino.Geometry.Point3d], tolerance: float) -> List[Point3d]
Rhino.Geometry.BrepFace.RebuildEdges(self, tolerance: float, rebuildSharedEdges: bool, rebuildVertices: bool) -> bool
Rhino.Geometry.BrepFace.RefitTrim(self, edge: Rhino.Geometry.BrepEdge, knots: Iterable[float], tolerance: float, bSections: bool, fitQuality: System.Double@) -> List[Surface]
Rhino.Geometry.BrepFace.RemoveHoles(self, tolerance: float) -> Brep
Rhino.Geometry.BrepFace.SetDomain(self, direction: int, domain: Rhino.Geometry.Interval) -> bool
Rhino.Geometry.BrepFace.SetMesh(self, meshType: Rhino.Geometry.MeshType, mesh: Rhino.Geometry.Mesh) -> bool
Rhino.Geometry.BrepFace.SetPackId(self, packId: System.UInt32) -> None
Rhino.Geometry.BrepFace.ShrinkFace(self, arg1: Rhino.Geometry.BrepFace.ShrinkDisableSide) -> bool
Rhino.Geometry.BrepFace.ShrinkSurfaceToEdge(self) -> bool
Rhino.Geometry.BrepFace.Split(self, curves: Iterable[Rhino.Geometry.Curve], tolerance: float) -> Brep
Rhino.Geometry.BrepFace.TrimAwareIsoCurve(self, direction: int, constantParameter: float) -> List[Curve]
Rhino.Geometry.BrepFace.TrimAwareIsoIntervals(self, direction: int, constantParameter: float) -> List[Interval]
Rhino.Geometry.BrepFace.UnderlyingSurface(self) -> Surface
Rhino.Geometry.BrepLoop.To2dCurve(self) -> Curve
Rhino.Geometry.BrepLoop.To3dCurve(self) -> Curve
Rhino.Geometry.BrepRegion.BoundaryBrep(self) -> Brep
Rhino.Geometry.BrepRegion.GetFaceSides(self) -> List[BrepRegionFaceSide]
Rhino.Geometry.BrepRegion.NonConstOperation(self) -> None
Rhino.Geometry.BrepRegionFaceSide.NonConstOperation(self) -> None
Rhino.Geometry.BrepTrim.GetTolerances(self, toleranceU: System.Double@, toleranceV: System.Double@) -> None
Rhino.Geometry.BrepTrim.GetTrimParameter(self, edgeParameter: float, trimParameter: System.Double@) -> bool
Rhino.Geometry.BrepTrim.IsReversed(self) -> bool
Rhino.Geometry.BrepTrim.SetTolerances(self, toleranceU: float, toleranceV: float) -> None
Rhino.Geometry.BrepTrim.SetTrimCurve(self, curve2dIndex: int) -> bool
Rhino.Geometry.BrepTrim.SetTrimCurve(self, curve2dIndex: int, subDomain: Rhino.Geometry.Interval) -> bool
Rhino.Geometry.BrepVertex.EdgeIndices(self) -> List[int]
Rhino.Geometry.Centermark.AdjustFromPoints(self, plane: Rhino.Geometry.Plane, centerPoint: Rhino.Geometry.Point3d) -> bool
Rhino.Geometry.Centermark.Create(dimStyle: Rhino.DocObjects.DimensionStyle, plane: Rhino.Geometry.Plane, centerPoint: Rhino.Geometry.Point3d, radius: float) -> Rhino.Geometry.Centermark
Rhino.Geometry.Centermark.Create(dimStyle: Rhino.DocObjects.DimensionStyle, plane: Rhino.Geometry.Plane, curve: Rhino.Geometry.Curve, curveParameter: float) -> Rhino.Geometry.Centermark
Rhino.Geometry.Centermark.__init__(self) -> None
Rhino.Geometry.Centermark.__init__(self, info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext) -> None
Rhino.Geometry.Centermark.__init__(self, plane: Rhino.Geometry.Plane, centerPoint: Rhino.Geometry.Point3d, radius: float) -> None
Rhino.Geometry.Centermark.__init__(self, plane: Rhino.Geometry.Plane, curve: Rhino.Geometry.Curve, curveParameter: float) -> None
Rhino.Geometry.Circle.ClosestParameter(self, testPoint: Rhino.Geometry.Point3d, t: System.Double@) -> bool
Rhino.Geometry.Circle.ClosestPoint(self, testPoint: Rhino.Geometry.Point3d) -> Point3d
Rhino.Geometry.Circle.DerivativeAt(self, derivative: int, t: float) -> Vector3d
Rhino.Geometry.Circle.EpsilonEquals(self, other: Rhino.Geometry.Circle, epsilon: float) -> bool
Rhino.Geometry.Circle.IsInPlane(self, plane: Rhino.Geometry.Plane, tolerance: float) -> bool
Rhino.Geometry.Circle.PointAt(self, t: float) -> Point3d
Rhino.Geometry.Circle.Reverse(self) -> None
Rhino.Geometry.Circle.Rotate(self, angle: float, axis: Rhino.Geometry.Vector3d) -> bool
Rhino.Geometry.Circle.Rotate(self, angle: float, axis: Rhino.Geometry.Vector3d, point: Rhino.Geometry.Point3d) -> bool
Rhino.Geometry.Circle.Rotate(self, sinAngle: float, cosAngle: float, axis: Rhino.Geometry.Vector3d) -> bool
Rhino.Geometry.Circle.Rotate(self, sinAngle: float, cosAngle: float, axis: Rhino.Geometry.Vector3d, point: Rhino.Geometry.Point3d) -> bool
Rhino.Geometry.Circle.TangentAt(self, t: float) -> Vector3d
Rhino.Geometry.Circle.ToNurbsCurve(self) -> NurbsCurve
Rhino.Geometry.Circle.ToNurbsCurve(self, degree: int, cvCount: int) -> NurbsCurve
Rhino.Geometry.Circle.Transform(self, xform: Rhino.Geometry.Transform) -> bool
Rhino.Geometry.Circle.Translate(self, delta: Rhino.Geometry.Vector3d) -> bool
Rhino.Geometry.Circle.TryFitCircleTT(c1: Rhino.Geometry.Curve, c2: Rhino.Geometry.Curve, t1: float, t2: float) -> Rhino.Geometry.Circle
Rhino.Geometry.Circle.TryFitCircleTTT(c1: Rhino.Geometry.Curve, c2: Rhino.Geometry.Curve, c3: Rhino.Geometry.Curve, t1: float, t2: float, t3: float) -> Rhino.Geometry.Circle
Rhino.Geometry.Circle.TryFitCircleToPoints(points: Iterable[Rhino.Geometry.Point3d], circle: Rhino.Geometry.Circle@) -> bool
Rhino.Geometry.Circle.TrySmallestEnclosingCircle(points: Iterable[Rhino.Geometry.Point2d], tolerance: float, circle: Rhino.Geometry.Circle@, indicesOnCircle: System.Int32[]@) -> bool
Rhino.Geometry.Circle.__init__(self, arc: Rhino.Geometry.Arc) -> None
Rhino.Geometry.Circle.__init__(self, center: Rhino.Geometry.Point3d, radius: float) -> None
Rhino.Geometry.Circle.__init__(self, plane: Rhino.Geometry.Plane, center: Rhino.Geometry.Point3d, radius: float) -> None
Rhino.Geometry.Circle.__init__(self, plane: Rhino.Geometry.Plane, radius: float) -> None
Rhino.Geometry.Circle.__init__(self, point1: Rhino.Geometry.Point3d, point2: Rhino.Geometry.Point3d, point3: Rhino.Geometry.Point3d) -> None
Rhino.Geometry.Circle.__init__(self, radius: float) -> None
Rhino.Geometry.Circle.__init__(self, startPoint: Rhino.Geometry.Point3d, tangentAtP: Rhino.Geometry.Vector3d, pointOnCircle: Rhino.Geometry.Point3d) -> None
Rhino.Geometry.ClippingPlaneSurface.AddClipViewportId(self, viewportId: System.Guid) -> bool
Rhino.Geometry.ClippingPlaneSurface.ClearClipParticipationLists(self) -> None
Rhino.Geometry.ClippingPlaneSurface.GetClipParticipation(self, objectIds: System.Collections.Generic.IEnumerable{System.Guid}@, layerIndices: System.Collections.Generic.IEnumerable{System.Int32}@, isExclusionList: System.Boolean@) -> None
Rhino.Geometry.ClippingPlaneSurface.RemoveClipViewportId(self, viewportId: System.Guid) -> bool
Rhino.Geometry.ClippingPlaneSurface.SetClipParticipation(self, objectIds: Iterable[System.Guid], layerIndices: Iterable[int], isExclusionList: bool) -> None
Rhino.Geometry.ClippingPlaneSurface.ViewportIds(self) -> List[Guid]
Rhino.Geometry.ClippingPlaneSurface.__init__(self) -> None
Rhino.Geometry.ClippingPlaneSurface.__init__(self, info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext) -> None
Rhino.Geometry.ClippingPlaneSurface.__init__(self, plane: Rhino.Geometry.Plane) -> None
Rhino.Geometry.ClippingPlaneSurface.__init__(self, planeSurface: Rhino.Geometry.PlaneSurface) -> None
Rhino.Geometry.Collections.BrepCurveList.Add(self, curve: Rhino.Geometry.Curve) -> int
Rhino.Geometry.Collections.BrepCurveList.GetEnumerator(self) -> IEnumerator<Curve>
Rhino.Geometry.Collections.BrepEdgeList.Add(self, curve3dIndex: int) -> BrepEdge
Rhino.Geometry.Collections.BrepEdgeList.Add(self, startVertex: Rhino.Geometry.BrepVertex, endVertex: Rhino.Geometry.BrepVertex, curve3dIndex: int, edgeTolerance: float) -> BrepEdge
Rhino.Geometry.Collections.BrepEdgeList.Add(self, startVertex: Rhino.Geometry.BrepVertex, endVertex: Rhino.Geometry.BrepVertex, curve3dIndex: int, subDomain: Rhino.Geometry.Interval, edgeTolerance: float) -> BrepEdge
Rhino.Geometry.Collections.BrepEdgeList.Add(self, startVertexIndex: int, endVertexIndex: int, curve3dIndex: int, edgeTolerance: float) -> BrepEdge
Rhino.Geometry.Collections.BrepEdgeList.Add(self, startVertexIndex: int, endVertexIndex: int, curve3dIndex: int, subDomain: Rhino.Geometry.Interval, edgeTolerance: float) -> BrepEdge
Rhino.Geometry.Collections.BrepEdgeList.GetEnumerator(self) -> IEnumerator<BrepEdge>
Rhino.Geometry.Collections.BrepEdgeList.MergeAllEdges(self, angleTolerance: float) -> int
Rhino.Geometry.Collections.BrepEdgeList.MergeEdge(self, edgeIndex: int, angleTolerance: float) -> int
Rhino.Geometry.Collections.BrepEdgeList.RemoveNakedMicroEdges(self, tolerance: float) -> int
Rhino.Geometry.Collections.BrepEdgeList.RemoveNakedMicroEdges(self, tolerance: float, cleanUp: bool) -> int
Rhino.Geometry.Collections.BrepEdgeList.SplitEdgeAtParameters(self, edgeIndex: int, edgeParameters: Iterable[float]) -> int
Rhino.Geometry.Collections.BrepEdgeList.SplitKinkyEdge(self, edgeIndex: int, kinkToleranceRadians: float) -> bool
Rhino.Geometry.Collections.BrepFaceList.Add(self, surface: Rhino.Geometry.Surface) -> BrepFace
Rhino.Geometry.Collections.BrepFaceList.Add(self, surfaceIndex: int) -> BrepFace
Rhino.Geometry.Collections.BrepFaceList.AddConeFace(self, vertex: Rhino.Geometry.BrepVertex, edge: Rhino.Geometry.BrepEdge, revEdge: bool) -> BrepFace
Rhino.Geometry.Collections.BrepFaceList.AddRuledFace(self, edgeA: Rhino.Geometry.BrepEdge, revEdgeA: bool, edgeB: Rhino.Geometry.BrepEdge, revEdgeB: bool) -> BrepFace
Rhino.Geometry.Collections.BrepFaceList.ClearPerFaceColors(self) -> uint
Rhino.Geometry.Collections.BrepFaceList.ExtractFace(self, faceIndex: int) -> Brep
Rhino.Geometry.Collections.BrepFaceList.Flip(self, onlyReversedFaces: bool) -> None
Rhino.Geometry.Collections.BrepFaceList.GetEnumerator(self) -> IEnumerator<BrepFace>
Rhino.Geometry.Collections.BrepFaceList.RemoveAt(self, faceIndex: int) -> None
Rhino.Geometry.Collections.BrepFaceList.RemoveSlits(self) -> bool
Rhino.Geometry.Collections.BrepFaceList.ShrinkFaces(self) -> bool
Rhino.Geometry.Collections.BrepFaceList.SplitBipolarFaces(self) -> bool
Rhino.Geometry.Collections.BrepFaceList.SplitClosedFaces(self, minimumDegree: int) -> bool
Rhino.Geometry.Collections.BrepFaceList.SplitFaceAtTangents(self, faceIndex: int) -> bool
Rhino.Geometry.Collections.BrepFaceList.SplitFacesAtTangents(self) -> bool
Rhino.Geometry.Collections.BrepFaceList.SplitKinkyFace(self, faceIndex: int, kinkTolerance: float) -> bool
Rhino.Geometry.Collections.BrepFaceList.SplitKinkyFaces(self) -> bool
Rhino.Geometry.Collections.BrepFaceList.SplitKinkyFaces(self, kinkTolerance: float) -> bool
Rhino.Geometry.Collections.BrepFaceList.SplitKinkyFaces(self, kinkTolerance: float, compact: bool) -> bool
Rhino.Geometry.Collections.BrepFaceList.StandardizeFaceSurface(self, faceIndex: int) -> bool
Rhino.Geometry.Collections.BrepFaceList.StandardizeFaceSurfaces(self) -> None
Rhino.Geometry.Collections.BrepLoopList.Add(self, loopType: Rhino.Geometry.BrepLoopType) -> BrepLoop
Rhino.Geometry.Collections.BrepLoopList.Add(self, loopType: Rhino.Geometry.BrepLoopType, face: Rhino.Geometry.BrepFace) -> BrepLoop
Rhino.Geometry.Collections.BrepLoopList.AddOuterLoop(self, faceIndex: int) -> BrepLoop
Rhino.Geometry.Collections.BrepLoopList.AddPlanarFaceLoop(self, faceIndex: int, loopType: Rhino.Geometry.BrepLoopType, boundaryCurves: Iterable[Rhino.Geometry.Curve]) -> BrepLoop
Rhino.Geometry.Collections.BrepLoopList.GetEnumerator(self) -> IEnumerator<BrepLoop>
Rhino.Geometry.Collections.BrepSurfaceList.GetEnumerator(self) -> IEnumerator<Surface>
Rhino.Geometry.Collections.BrepTrimList.Add(self, curve2dIndex: int) -> BrepTrim
Rhino.Geometry.Collections.BrepTrimList.Add(self, edge: Rhino.Geometry.BrepEdge, rev3d: bool, loop: Rhino.Geometry.BrepLoop, curve2dIndex: int) -> BrepTrim
Rhino.Geometry.Collections.BrepTrimList.Add(self, rev3d: bool, edge: Rhino.Geometry.BrepEdge, curve2dIndex: int) -> BrepTrim
Rhino.Geometry.Collections.BrepTrimList.Add(self, rev3d: bool, loop: Rhino.Geometry.BrepLoop, curve2dIndex: int) -> BrepTrim
Rhino.Geometry.Collections.BrepTrimList.AddCurveOnFace(self, face: Rhino.Geometry.BrepFace, edge: Rhino.Geometry.BrepEdge, rev3d: bool, curve2dIndex: int) -> BrepTrim
Rhino.Geometry.Collections.BrepTrimList.AddSingularTrim(self, vertex: Rhino.Geometry.BrepVertex, loop: Rhino.Geometry.BrepLoop, iso: Rhino.Geometry.IsoStatus, curve2dIndex: int) -> BrepTrim
Rhino.Geometry.Collections.BrepTrimList.GetEnumerator(self) -> IEnumerator<BrepTrim>
Rhino.Geometry.Collections.BrepTrimList.MatchEnds(self) -> bool
Rhino.Geometry.Collections.BrepTrimList.MatchEnds(self, loop: Rhino.Geometry.BrepLoop) -> bool
Rhino.Geometry.Collections.BrepTrimList.MatchEnds(self, trim0: Rhino.Geometry.BrepTrim, trim1: Rhino.Geometry.BrepTrim) -> bool
Rhino.Geometry.Collections.BrepTrimList.MatchEnds(self, trimIndex: int) -> bool
Rhino.Geometry.Collections.BrepVertexList.Add(self) -> BrepVertex
Rhino.Geometry.Collections.BrepVertexList.Add(self, point: Rhino.Geometry.Point3d, vertexTolerance: float) -> BrepVertex
Rhino.Geometry.Collections.BrepVertexList.AddPointOnFace(self, face: Rhino.Geometry.BrepFace, s: float, t: float) -> BrepVertex
Rhino.Geometry.Collections.BrepVertexList.GetEnumerator(self) -> IEnumerator<BrepVertex>
Rhino.Geometry.Collections.MeshFaceList.AddFace(self, face: Rhino.Geometry.MeshFace) -> int
Rhino.Geometry.Collections.MeshFaceList.AddFace(self, vertex1: int, vertex2: int, vertex3: int) -> int
Rhino.Geometry.Collections.MeshFaceList.AddFace(self, vertex1: int, vertex2: int, vertex3: int, vertex4: int) -> int
Rhino.Geometry.Collections.MeshFaceList.AddFaces(self, faces: Iterable[Rhino.Geometry.MeshFace]) -> List[int]
Rhino.Geometry.Collections.MeshFaceList.AdjacentFaces(self, faceIndex: int) -> List[int]
Rhino.Geometry.Collections.MeshFaceList.Clear(self) -> None
Rhino.Geometry.Collections.MeshFaceList.ConvertNonPlanarQuadsToTriangles(self, planarTolerance: float, angleToleranceRadians: float, splitMethod: int) -> int
Rhino.Geometry.Collections.MeshFaceList.ConvertQuadsToTriangles(self) -> bool
Rhino.Geometry.Collections.MeshFaceList.ConvertTrianglesToQuads(self, angleToleranceRadians: float, minimumDiagonalLengthRatio: float) -> bool
Rhino.Geometry.Collections.MeshFaceList.CullDegenerateFaces(self) -> int
Rhino.Geometry.Collections.MeshFaceList.DeleteFaces(self, faceIndexes: Iterable[int]) -> int
Rhino.Geometry.Collections.MeshFaceList.DeleteFaces(self, faceIndexes: Iterable[int], compact: bool) -> int
Rhino.Geometry.Collections.MeshFaceList.Destroy(self) -> None
Rhino.Geometry.Collections.MeshFaceList.ExtractDuplicateFaces(self) -> Mesh
Rhino.Geometry.Collections.MeshFaceList.ExtractFaces(self, faceIndices: Iterable[int]) -> Mesh
Rhino.Geometry.Collections.MeshFaceList.GetClashingFacePairs(self, maxPairCount: int) -> List[IndexPair]
Rhino.Geometry.Collections.MeshFaceList.GetConnectedFaces(self, faceIndex: int) -> List[int]
Rhino.Geometry.Collections.MeshFaceList.GetConnectedFaces(self, faceIndex: int, angleRadians: float, greaterThanAngle: bool) -> List[int]
Rhino.Geometry.Collections.MeshFaceList.GetConnectedFacesToEdges(self, startFaceIndex: int, treatNonmanifoldLikeUnwelded: bool) -> List[int]
Rhino.Geometry.Collections.MeshFaceList.GetDuplicateFaces(self) -> List[int]
Rhino.Geometry.Collections.MeshFaceList.GetEnumerator(self) -> IEnumerator<MeshFace>
Rhino.Geometry.Collections.MeshFaceList.GetFace(self, index: int) -> MeshFace
Rhino.Geometry.Collections.MeshFaceList.GetFaceAspectRatio(self, index: int) -> float
Rhino.Geometry.Collections.MeshFaceList.GetFaceBoundingBox(self, faceIndex: int) -> BoundingBox
Rhino.Geometry.Collections.MeshFaceList.GetFaceCenter(self, faceIndex: int) -> Point3d
Rhino.Geometry.Collections.MeshFaceList.GetFaceVertices(self, faceIndex: int, a: Rhino.Geometry.Point3f@, b: Rhino.Geometry.Point3f@, c: Rhino.Geometry.Point3f@, d: Rhino.Geometry.Point3f@) -> bool
Rhino.Geometry.Collections.MeshFaceList.GetTopologicalVertices(self, faceIndex: int) -> List[int]
Rhino.Geometry.Collections.MeshFaceList.GetZeroAreaFaces(self, whollyDegenerateFaces: System.Int32[]@, partiallyDegenerateFaces: System.Int32[]@) -> bool
Rhino.Geometry.Collections.MeshFaceList.HasNakedEdges(self, faceIndex: int) -> bool
Rhino.Geometry.Collections.MeshFaceList.Insert(self, index: int, face: Rhino.Geometry.MeshFace) -> None
Rhino.Geometry.Collections.MeshFaceList.IsHidden(self, faceIndex: int) -> bool
Rhino.Geometry.Collections.MeshFaceList.MergeAdjacentFaces(self, edgeIndex: int) -> bool
Rhino.Geometry.Collections.MeshFaceList.RemoveAt(self, index: int) -> None
Rhino.Geometry.Collections.MeshFaceList.RemoveAt(self, index: int, compact: bool) -> None
Rhino.Geometry.Collections.MeshFaceList.RemoveZeroAreaFaces(self, fixedFaceCount: System.Int32@) -> int
Rhino.Geometry.Collections.MeshFaceList.SetFace(self, index: int, face: Rhino.Geometry.MeshFace) -> bool
Rhino.Geometry.Collections.MeshFaceList.SetFace(self, index: int, vertex1: int, vertex2: int, vertex3: int) -> bool
Rhino.Geometry.Collections.MeshFaceList.SetFace(self, index: int, vertex1: int, vertex2: int, vertex3: int, vertex4: int) -> bool
Rhino.Geometry.Collections.MeshFaceList.ToIntArray(self, asTriangles: bool) -> List[int]
Rhino.Geometry.Collections.MeshFaceList.ToIntArray(self, asTriangles: bool, replacedIndices: System.Collections.Generic.List{System.Int32}@) -> List[int]
Rhino.Geometry.Collections.MeshFaceNormalList.AddFaceNormal(self, normal: Rhino.Geometry.Vector3d) -> int
Rhino.Geometry.Collections.MeshFaceNormalList.AddFaceNormal(self, normal: Rhino.Geometry.Vector3f) -> int
Rhino.Geometry.Collections.MeshFaceNormalList.AddFaceNormal(self, x: float, y: float, z: float) -> int
Rhino.Geometry.Collections.MeshFaceNormalList.AddFaceNormal(self, x: float, y: float, z: float) -> int
Rhino.Geometry.Collections.MeshFaceNormalList.Clear(self) -> None
Rhino.Geometry.Collections.MeshFaceNormalList.ComputeFaceNormals(self) -> bool
Rhino.Geometry.Collections.MeshFaceNormalList.Destroy(self) -> None
Rhino.Geometry.Collections.MeshFaceNormalList.GetEnumerator(self) -> IEnumerator<Vector3f>
Rhino.Geometry.Collections.MeshFaceNormalList.SetFaceNormal(self, index: int, normal: Rhino.Geometry.Vector3d) -> bool
Rhino.Geometry.Collections.MeshFaceNormalList.SetFaceNormal(self, index: int, normal: Rhino.Geometry.Vector3f) -> bool
Rhino.Geometry.Collections.MeshFaceNormalList.SetFaceNormal(self, index: int, x: float, y: float, z: float) -> bool
Rhino.Geometry.Collections.MeshFaceNormalList.SetFaceNormal(self, index: int, x: float, y: float, z: float) -> bool
Rhino.Geometry.Collections.MeshFaceNormalList.UnitizeFaceNormals(self) -> bool
Rhino.Geometry.Collections.MeshNgonList.AddNgon(self, ngon: Rhino.Geometry.MeshNgon) -> int
Rhino.Geometry.Collections.MeshNgonList.AddNgons(self, ngons: Iterable[Rhino.Geometry.MeshNgon]) -> List[int]
Rhino.Geometry.Collections.MeshNgonList.AddPlanarNgons(self, planarTolerance: float) -> int
Rhino.Geometry.Collections.MeshNgonList.AddPlanarNgons(self, planarTolerance: float, minimumNgonVertexCount: int, minimumNgonFaceCount: int, allowHoles: bool) -> int
Rhino.Geometry.Collections.MeshNgonList.Clear(self) -> None
Rhino.Geometry.Collections.MeshNgonList.GetEnumerator(self) -> IEnumerator<MeshNgon>
Rhino.Geometry.Collections.MeshNgonList.GetNgon(self, index: int) -> MeshNgon
Rhino.Geometry.Collections.MeshNgonList.GetNgonBoundary(self, ngonFaceIndexList: Iterable[int]) -> List[int]
Rhino.Geometry.Collections.MeshNgonList.GetNgonBoundingBox(self, index: int) -> BoundingBox
Rhino.Geometry.Collections.MeshNgonList.GetNgonBoundingBox(self, ngon: Rhino.Geometry.MeshNgon) -> BoundingBox
Rhino.Geometry.Collections.MeshNgonList.GetNgonCenter(self, index: int) -> Point3d
Rhino.Geometry.Collections.MeshNgonList.GetNgonCenter(self, ngon: Rhino.Geometry.MeshNgon) -> Point3d
Rhino.Geometry.Collections.MeshNgonList.GetNgonEdgeCount(self, index: int) -> int
Rhino.Geometry.Collections.MeshNgonList.GetNgonOuterEdgeCount(self, index: int) -> int
Rhino.Geometry.Collections.MeshNgonList.Insert(self, index: int, ngon: Rhino.Geometry.MeshNgon) -> None
Rhino.Geometry.Collections.MeshNgonList.IsValid(self, index: int) -> uint
Rhino.Geometry.Collections.MeshNgonList.IsValid(self, index: int, textLog: Rhino.FileIO.TextLog) -> uint
Rhino.Geometry.Collections.MeshNgonList.NgonBoundaryVertexList(self, ngon: Rhino.Geometry.MeshNgon, bAppendStartPoint: bool) -> List[Point3d]
Rhino.Geometry.Collections.MeshNgonList.NgonHasHoles(self, index: int) -> bool
Rhino.Geometry.Collections.MeshNgonList.NgonIndexFromFaceIndex(self, meshFaceIndex: int) -> int
Rhino.Geometry.Collections.MeshNgonList.Orientation(self, index: int, permitHoles: bool) -> int
Rhino.Geometry.Collections.MeshNgonList.RemoveAt(self, index: int) -> None
Rhino.Geometry.Collections.MeshNgonList.RemoveNgons(self, indices: Iterable[int]) -> int
Rhino.Geometry.Collections.MeshNgonList.ReverseOuterBoundary(self, index: int) -> None
Rhino.Geometry.Collections.MeshNgonList.SetNgon(self, index: int, ngon: Rhino.Geometry.MeshNgon) -> None
Rhino.Geometry.Collections.MeshTextureCoordinateList.Add(self, s: float, t: float) -> int
Rhino.Geometry.Collections.MeshTextureCoordinateList.Add(self, s: float, t: float) -> int
Rhino.Geometry.Collections.MeshTextureCoordinateList.Add(self, tc: Rhino.Geometry.Point2f) -> int
Rhino.Geometry.Collections.MeshTextureCoordinateList.Add(self, tc: Rhino.Geometry.Point3d) -> int
Rhino.Geometry.Collections.MeshTextureCoordinateList.AddRange(self, textureCoordinates: List[Rhino.Geometry.Point2f]) -> bool
Rhino.Geometry.Collections.MeshTextureCoordinateList.Clear(self) -> None
Rhino.Geometry.Collections.MeshTextureCoordinateList.Destroy(self) -> None
Rhino.Geometry.Collections.MeshTextureCoordinateList.GetEnumerator(self) -> IEnumerator<Point2f>
Rhino.Geometry.Collections.MeshTextureCoordinateList.NormalizeTextureCoordinates(self) -> bool
Rhino.Geometry.Collections.MeshTextureCoordinateList.ReverseTextureCoordinates(self, direction: int) -> bool
Rhino.Geometry.Collections.MeshTextureCoordinateList.SetTextureCoordinate(self, index: int, s: float, t: float) -> bool
Rhino.Geometry.Collections.MeshTextureCoordinateList.SetTextureCoordinate(self, index: int, s: float, t: float) -> bool
Rhino.Geometry.Collections.MeshTextureCoordinateList.SetTextureCoordinate(self, index: int, tc: Rhino.Geometry.Point2f) -> bool
Rhino.Geometry.Collections.MeshTextureCoordinateList.SetTextureCoordinate(self, index: int, tc: Rhino.Geometry.Point3f) -> bool
Rhino.Geometry.Collections.MeshTextureCoordinateList.SetTextureCoordinates(self, mapping: Rhino.Render.TextureMapping) -> bool
Rhino.Geometry.Collections.MeshTextureCoordinateList.SetTextureCoordinates(self, textureCoordinates: List[Rhino.Geometry.Point2f]) -> bool
Rhino.Geometry.Collections.MeshTextureCoordinateList.ToFloatArray(self) -> List[float]
Rhino.Geometry.Collections.MeshTextureCoordinateList.TransposeTextureCoordinates(self) -> bool
Rhino.Geometry.Collections.MeshTopologyEdgeList.CollapseEdge(self, topologyEdgeIndex: int) -> bool
Rhino.Geometry.Collections.MeshTopologyEdgeList.EdgeLine(self, topologyEdgeIndex: int) -> Line
Rhino.Geometry.Collections.MeshTopologyEdgeList.GetConnectedFaces(self, topologyEdgeIndex: int) -> List[int]
Rhino.Geometry.Collections.MeshTopologyEdgeList.GetConnectedFaces(self, topologyEdgeIndex: int, faceOrientationMatchesEdgeDirection: System.Boolean[]@) -> List[int]
Rhino.Geometry.Collections.MeshTopologyEdgeList.GetEdgeIndex(self, topologyVertex1: int, topologyVertex2: int) -> int
Rhino.Geometry.Collections.MeshTopologyEdgeList.GetEdgesForFace(self, faceIndex: int) -> List[int]
Rhino.Geometry.Collections.MeshTopologyEdgeList.GetEdgesForFace(self, faceIndex: int, sameOrientation: System.Boolean[]@) -> List[int]
Rhino.Geometry.Collections.MeshTopologyEdgeList.GetTopologyVertices(self, topologyEdgeIndex: int) -> IndexPair
Rhino.Geometry.Collections.MeshTopologyEdgeList.IsEdgeUnwelded(self, topologyEdgeIndex: int) -> bool
Rhino.Geometry.Collections.MeshTopologyEdgeList.IsHidden(self, topologyEdgeIndex: int) -> bool
Rhino.Geometry.Collections.MeshTopologyEdgeList.IsNgonInterior(self, topologyEdgeIndex: int) -> bool
Rhino.Geometry.Collections.MeshTopologyEdgeList.IsSwappableEdge(self, topologyEdgeIndex: int) -> bool
Rhino.Geometry.Collections.MeshTopologyEdgeList.SplitEdge(self, topologyEdgeIndex: int, point: Rhino.Geometry.Point3d) -> bool
Rhino.Geometry.Collections.MeshTopologyEdgeList.SplitEdge(self, topologyEdgeIndex: int, t: float) -> bool
Rhino.Geometry.Collections.MeshTopologyEdgeList.SwapEdge(self, topologyEdgeIndex: int) -> bool
Rhino.Geometry.Collections.MeshTopologyVertexList.ConnectedEdge(self, topologyVertexIndex: int, edgeAtVertexIndex: int) -> int
Rhino.Geometry.Collections.MeshTopologyVertexList.ConnectedEdges(self, topologyVertexIndex: int) -> List[int]
Rhino.Geometry.Collections.MeshTopologyVertexList.ConnectedEdgesCount(self, topologyVertexIndex: int) -> int
Rhino.Geometry.Collections.MeshTopologyVertexList.ConnectedFaces(self, topologyVertexIndex: int) -> List[int]
Rhino.Geometry.Collections.MeshTopologyVertexList.ConnectedTopologyVertices(self, topologyVertexIndex: int) -> List[int]
Rhino.Geometry.Collections.MeshTopologyVertexList.ConnectedTopologyVertices(self, topologyVertexIndex: int, sorted: bool) -> List[int]
Rhino.Geometry.Collections.MeshTopologyVertexList.GetEnumerator(self) -> IEnumerator<Point3f>
Rhino.Geometry.Collections.MeshTopologyVertexList.IndicesFromFace(self, faceIndex: int) -> List[int]
Rhino.Geometry.Collections.MeshTopologyVertexList.IsHidden(self, topologyVertexIndex: int) -> bool
Rhino.Geometry.Collections.MeshTopologyVertexList.MeshVertexIndices(self, topologyVertexIndex: int) -> List[int]
Rhino.Geometry.Collections.MeshTopologyVertexList.SortEdges(self) -> bool
Rhino.Geometry.Collections.MeshTopologyVertexList.SortEdges(self, topologyVertexIndex: int) -> bool
Rhino.Geometry.Collections.MeshTopologyVertexList.TopologyVertexIndex(self, vertexIndex: int) -> int
Rhino.Geometry.Collections.MeshVertexColorList.Add(self, color: System.Drawing.Color) -> int
Rhino.Geometry.Collections.MeshVertexColorList.Add(self, red: int, green: int, blue: int) -> int
Rhino.Geometry.Collections.MeshVertexColorList.AddRange(self, colors: Iterable[System.Drawing.Color]) -> bool
Rhino.Geometry.Collections.MeshVertexColorList.AppendColors(self, colors: List[System.Drawing.Color]) -> bool
Rhino.Geometry.Collections.MeshVertexColorList.Clear(self) -> None
Rhino.Geometry.Collections.MeshVertexColorList.CreateMonotoneMesh(self, baseColor: System.Drawing.Color) -> bool
Rhino.Geometry.Collections.MeshVertexColorList.Destroy(self) -> None
Rhino.Geometry.Collections.MeshVertexColorList.GetEnumerator(self) -> IEnumerator<Color>
Rhino.Geometry.Collections.MeshVertexColorList.SetColor(self, face: Rhino.Geometry.MeshFace, color: System.Drawing.Color) -> bool
Rhino.Geometry.Collections.MeshVertexColorList.SetColor(self, index: int, color: System.Drawing.Color) -> bool
Rhino.Geometry.Collections.MeshVertexColorList.SetColor(self, index: int, red: int, green: int, blue: int) -> bool
Rhino.Geometry.Collections.MeshVertexColorList.SetColors(self, colors: List[System.Drawing.Color]) -> bool
Rhino.Geometry.Collections.MeshVertexColorList.ToARGBArray(self) -> List[int]
Rhino.Geometry.Collections.MeshVertexList.Add(self, vertex: Rhino.Geometry.Point3d) -> int
Rhino.Geometry.Collections.MeshVertexList.Add(self, vertex: Rhino.Geometry.Point3f) -> int
Rhino.Geometry.Collections.MeshVertexList.Add(self, x: float, y: float, z: float) -> int
Rhino.Geometry.Collections.MeshVertexList.Add(self, x: float, y: float, z: float) -> int
Rhino.Geometry.Collections.MeshVertexList.AddVertices(self, vertices: Iterable[Rhino.Geometry.Point3d]) -> None
Rhino.Geometry.Collections.MeshVertexList.AddVertices(self, vertices: Iterable[Rhino.Geometry.Point3f]) -> None
Rhino.Geometry.Collections.MeshVertexList.Clear(self) -> None
Rhino.Geometry.Collections.MeshVertexList.CombineIdentical(self, ignoreNormals: bool, ignoreAdditional: bool) -> bool
Rhino.Geometry.Collections.MeshVertexList.CullUnused(self) -> int
Rhino.Geometry.Collections.MeshVertexList.Destroy(self) -> None
Rhino.Geometry.Collections.MeshVertexList.GetConnectedVertices(self, vertexIndex: int) -> List[int]
Rhino.Geometry.Collections.MeshVertexList.GetEnumerator(self) -> IEnumerator<Point3f>
Rhino.Geometry.Collections.MeshVertexList.GetTopologicalIndenticalVertices(self, vertexIndex: int) -> List[int]
Rhino.Geometry.Collections.MeshVertexList.GetVertexFaces(self, vertexIndex: int) -> List[int]
Rhino.Geometry.Collections.MeshVertexList.Hide(self, vertexIndex: int) -> None
Rhino.Geometry.Collections.MeshVertexList.HideAll(self) -> None
Rhino.Geometry.Collections.MeshVertexList.IsHidden(self, vertexIndex: int) -> bool
Rhino.Geometry.Collections.MeshVertexList.Point3dAt(self, index: int) -> Point3d
Rhino.Geometry.Collections.MeshVertexList.Remove(self, index: int, shrinkFaces: bool) -> bool
Rhino.Geometry.Collections.MeshVertexList.Remove(self, indices: Iterable[int], shrinkFaces: bool) -> bool
Rhino.Geometry.Collections.MeshVertexList.SetVertex(self, index: int, vertex: Rhino.Geometry.Point3d) -> bool
Rhino.Geometry.Collections.MeshVertexList.SetVertex(self, index: int, vertex: Rhino.Geometry.Point3f) -> bool
Rhino.Geometry.Collections.MeshVertexList.SetVertex(self, index: int, x: float, y: float, z: float) -> bool
Rhino.Geometry.Collections.MeshVertexList.SetVertex(self, index: int, x: float, y: float, z: float) -> bool
Rhino.Geometry.Collections.MeshVertexList.SetVertex(self, index: int, x: float, y: float, z: float, updateNormals: bool) -> bool
Rhino.Geometry.Collections.MeshVertexList.Show(self, vertexIndex: int) -> None
Rhino.Geometry.Collections.MeshVertexList.ShowAll(self) -> None
Rhino.Geometry.Collections.MeshVertexList.ToFloatArray(self) -> List[float]
Rhino.Geometry.Collections.MeshVertexList.ToPoint3dArray(self) -> List[Point3d]
Rhino.Geometry.Collections.MeshVertexList.ToPoint3fArray(self) -> List[Point3f]
Rhino.Geometry.Collections.MeshVertexList._AlignMeshVertices(self, arg1: Iterable[Rhino.Geometry.Mesh], arg2: float, arg3: Iterable[Iterable[bool]]) -> None
Rhino.Geometry.Collections.MeshVertexList._AlignMeshVertices(self, arg1: float, arg2: Iterable[bool]) -> None
Rhino.Geometry.Collections.MeshVertexNormalList.Add(self, normal: Rhino.Geometry.Vector3d) -> int
Rhino.Geometry.Collections.MeshVertexNormalList.Add(self, normal: Rhino.Geometry.Vector3f) -> int
Rhino.Geometry.Collections.MeshVertexNormalList.Add(self, x: float, y: float, z: float) -> int
Rhino.Geometry.Collections.MeshVertexNormalList.Add(self, x: float, y: float, z: float) -> int
Rhino.Geometry.Collections.MeshVertexNormalList.AddRange(self, normals: List[Rhino.Geometry.Vector3f]) -> bool
Rhino.Geometry.Collections.MeshVertexNormalList.Clear(self) -> None
Rhino.Geometry.Collections.MeshVertexNormalList.ComputeNormals(self) -> bool
Rhino.Geometry.Collections.MeshVertexNormalList.Destroy(self) -> None
Rhino.Geometry.Collections.MeshVertexNormalList.Flip(self) -> None
Rhino.Geometry.Collections.MeshVertexNormalList.GetEnumerator(self) -> IEnumerator<Vector3f>
Rhino.Geometry.Collections.MeshVertexNormalList.SetNormal(self, index: int, normal: Rhino.Geometry.Vector3d) -> bool
Rhino.Geometry.Collections.MeshVertexNormalList.SetNormal(self, index: int, normal: Rhino.Geometry.Vector3f) -> bool
Rhino.Geometry.Collections.MeshVertexNormalList.SetNormal(self, index: int, x: float, y: float, z: float) -> bool
Rhino.Geometry.Collections.MeshVertexNormalList.SetNormal(self, index: int, x: float, y: float, z: float) -> bool
Rhino.Geometry.Collections.MeshVertexNormalList.SetNormals(self, normals: List[Rhino.Geometry.Vector3f]) -> bool
Rhino.Geometry.Collections.MeshVertexNormalList.ToFloatArray(self) -> List[float]
Rhino.Geometry.Collections.MeshVertexNormalList.UnitizeNormals(self) -> bool
Rhino.Geometry.Collections.MeshVertexStatusList.Add(self, hidden: bool) -> None
Rhino.Geometry.Collections.MeshVertexStatusList.AddRange(self, values: Iterable[bool]) -> None
Rhino.Geometry.Collections.MeshVertexStatusList.Clear(self) -> None
Rhino.Geometry.Collections.MeshVertexStatusList.Contains(self, hidden: bool) -> bool
Rhino.Geometry.Collections.MeshVertexStatusList.CopyTo(self, array: List[bool], arrayIndex: int) -> None
Rhino.Geometry.Collections.MeshVertexStatusList.Destroy(self) -> None
Rhino.Geometry.Collections.MeshVertexStatusList.GetEnumerator(self) -> IEnumerator<bool>
Rhino.Geometry.Collections.NurbsCurveKnotList.ClampEnd(self, end: Rhino.Geometry.CurveEnd) -> bool
Rhino.Geometry.Collections.NurbsCurveKnotList.Contains(self, item: float) -> bool
Rhino.Geometry.Collections.NurbsCurveKnotList.CopyTo(self, array: List[float], arrayIndex: int) -> None
Rhino.Geometry.Collections.NurbsCurveKnotList.CreatePeriodicKnots(self, knotSpacing: float) -> bool
Rhino.Geometry.Collections.NurbsCurveKnotList.CreateUniformKnots(self, knotSpacing: float) -> bool
Rhino.Geometry.Collections.NurbsCurveKnotList.EnsurePrivateCopy(self) -> None
Rhino.Geometry.Collections.NurbsCurveKnotList.EpsilonEquals(self, other: Rhino.Geometry.Collections.NurbsCurveKnotList, epsilon: float) -> bool
Rhino.Geometry.Collections.NurbsCurveKnotList.IndexOf(self, item: float) -> int
Rhino.Geometry.Collections.NurbsCurveKnotList.InsertKnot(self, value: float) -> bool
Rhino.Geometry.Collections.NurbsCurveKnotList.InsertKnot(self, value: float, multiplicity: int) -> bool
Rhino.Geometry.Collections.NurbsCurveKnotList.KnotMultiplicity(self, index: int) -> int
Rhino.Geometry.Collections.NurbsCurveKnotList.RemoveKnotAt(self, t: float) -> bool
Rhino.Geometry.Collections.NurbsCurveKnotList.RemoveKnots(self, index0: int, index1: int) -> bool
Rhino.Geometry.Collections.NurbsCurveKnotList.RemoveMultipleKnots(self, minimumMultiplicity: int, maximumMultiplicity: int, tolerance: float) -> int
Rhino.Geometry.Collections.NurbsCurveKnotList.SuperfluousKnot(self, start: bool) -> float
Rhino.Geometry.Collections.NurbsCurvePointList.ChangeEndWeights(self, w0: float, w1: float) -> bool
Rhino.Geometry.Collections.NurbsCurvePointList.Contains(self, item: Rhino.Geometry.ControlPoint) -> bool
Rhino.Geometry.Collections.NurbsCurvePointList.ControlPolygon(self) -> Polyline
Rhino.Geometry.Collections.NurbsCurvePointList.CopyTo(self, array: List[Rhino.Geometry.ControlPoint], arrayIndex: int) -> None
Rhino.Geometry.Collections.NurbsCurvePointList.EnsurePrivateCopy(self) -> None
Rhino.Geometry.Collections.NurbsCurvePointList.EpsilonEquals(self, other: Rhino.Geometry.Collections.NurbsCurvePointList, epsilon: float) -> bool
Rhino.Geometry.Collections.NurbsCurvePointList.GetPoint(self, index: int, point: Rhino.Geometry.Point3d@) -> bool
Rhino.Geometry.Collections.NurbsCurvePointList.GetPoint(self, index: int, point: Rhino.Geometry.Point4d@) -> bool
Rhino.Geometry.Collections.NurbsCurvePointList.GetWeight(self, index: int) -> float
Rhino.Geometry.Collections.NurbsCurvePointList.IndexOf(self, item: Rhino.Geometry.ControlPoint) -> int
Rhino.Geometry.Collections.NurbsCurvePointList.MakeNonRational(self) -> bool
Rhino.Geometry.Collections.NurbsCurvePointList.MakeRational(self) -> bool
Rhino.Geometry.Collections.NurbsCurvePointList.SetPoint(self, index: int, point: Rhino.Geometry.Point3d) -> bool
Rhino.Geometry.Collections.NurbsCurvePointList.SetPoint(self, index: int, point: Rhino.Geometry.Point3d, weight: float) -> bool
Rhino.Geometry.Collections.NurbsCurvePointList.SetPoint(self, index: int, point: Rhino.Geometry.Point4d) -> bool
Rhino.Geometry.Collections.NurbsCurvePointList.SetPoint(self, index: int, x: float, y: float, z: float) -> bool
Rhino.Geometry.Collections.NurbsCurvePointList.SetPoint(self, index: int, x: float, y: float, z: float, weight: float) -> bool
Rhino.Geometry.Collections.NurbsCurvePointList.SetWeight(self, index: int, weight: float) -> bool
Rhino.Geometry.Collections.NurbsCurvePointList.UVNDirectionsAt(self, index: int, uDir: Rhino.Geometry.Vector3d@, vDir: Rhino.Geometry.Vector3d@, nDir: Rhino.Geometry.Vector3d@) -> bool
Rhino.Geometry.Collections.NurbsCurvePointList.ValidateSpacing(self, closeTolerance: float, stackTolerance: float, closeIndices: System.Int32[]@, stackedIndices: System.Int32[]@) -> bool
Rhino.Geometry.Collections.NurbsSurfaceKnotList.CreatePeriodicKnots(self, knotSpacing: float) -> bool
Rhino.Geometry.Collections.NurbsSurfaceKnotList.CreateUniformKnots(self, knotSpacing: float) -> bool
Rhino.Geometry.Collections.NurbsSurfaceKnotList.EnsurePrivateCopy(self) -> None
Rhino.Geometry.Collections.NurbsSurfaceKnotList.EpsilonEquals(self, other: Rhino.Geometry.Collections.NurbsSurfaceKnotList, epsilon: float) -> bool
Rhino.Geometry.Collections.NurbsSurfaceKnotList.InsertKnot(self, value: float) -> bool
Rhino.Geometry.Collections.NurbsSurfaceKnotList.InsertKnot(self, value: float, multiplicity: int) -> bool
Rhino.Geometry.Collections.NurbsSurfaceKnotList.KnotMultiplicity(self, index: int) -> int
Rhino.Geometry.Collections.NurbsSurfaceKnotList.RemoveKnots(self, index0: int, index1: int) -> bool
Rhino.Geometry.Collections.NurbsSurfaceKnotList.RemoveKnotsAt(self, u: float, v: float) -> bool
Rhino.Geometry.Collections.NurbsSurfaceKnotList.RemoveMultipleKnots(self, minimumMultiplicity: int, maximumMultiplicity: int, tolerance: float) -> int
Rhino.Geometry.Collections.NurbsSurfaceKnotList.SuperfluousKnot(self, start: bool) -> float
Rhino.Geometry.Collections.NurbsSurfacePointList.EnsurePrivateCopy(self) -> None
Rhino.Geometry.Collections.NurbsSurfacePointList.EpsilonEquals(self, other: Rhino.Geometry.Collections.NurbsSurfacePointList, epsilon: float) -> bool
Rhino.Geometry.Collections.NurbsSurfacePointList.GetControlPoint(self, u: int, v: int) -> ControlPoint
Rhino.Geometry.Collections.NurbsSurfacePointList.GetGrevillePoint(self, u: int, v: int) -> Point2d
Rhino.Geometry.Collections.NurbsSurfacePointList.GetPoint(self, u: int, v: int, point: Rhino.Geometry.Point3d@) -> bool
Rhino.Geometry.Collections.NurbsSurfacePointList.GetPoint(self, u: int, v: int, point: Rhino.Geometry.Point4d@) -> bool
Rhino.Geometry.Collections.NurbsSurfacePointList.GetWeight(self, u: int, v: int) -> float
Rhino.Geometry.Collections.NurbsSurfacePointList.SetControlPoint(self, u: int, v: int, cp: Rhino.Geometry.ControlPoint) -> bool
Rhino.Geometry.Collections.NurbsSurfacePointList.SetPoint(self, u: int, v: int, point: Rhino.Geometry.Point3d) -> bool
Rhino.Geometry.Collections.NurbsSurfacePointList.SetPoint(self, u: int, v: int, point: Rhino.Geometry.Point3d, weight: float) -> bool
Rhino.Geometry.Collections.NurbsSurfacePointList.SetPoint(self, u: int, v: int, point: Rhino.Geometry.Point4d) -> bool
Rhino.Geometry.Collections.NurbsSurfacePointList.SetPoint(self, u: int, v: int, x: float, y: float, z: float) -> bool
Rhino.Geometry.Collections.NurbsSurfacePointList.SetPoint(self, u: int, v: int, x: float, y: float, z: float, weight: float) -> bool
Rhino.Geometry.Collections.NurbsSurfacePointList.SetWeight(self, u: int, v: int, weight: float) -> bool
Rhino.Geometry.Collections.NurbsSurfacePointList.UVNDirectionsAt(self, u: int, v: int, uDir: Rhino.Geometry.Vector3d@, vDir: Rhino.Geometry.Vector3d@, nDir: Rhino.Geometry.Vector3d@) -> bool
Rhino.Geometry.Collections.NurbsSurfacePointList.ValidateSpacing(self, closeTolerance: float, stackTolerance: float, closeIndices: Rhino.IndexPair[]@, stackedIndices: Rhino.IndexPair[]@) -> bool
Rhino.Geometry.Collections.NurbsSurfacePointList.[ObsoleteAttribute(self, arg1: int, arg2: int, arg3: Rhino.Geometry.Point3d) -> None
Rhino.Geometry.Collections.SubDEdgeList.Add(self, tag: Rhino.Geometry.SubDEdgeTag, v0: Rhino.Geometry.SubDVertex, v1: Rhino.Geometry.SubDVertex) -> SubDEdge
Rhino.Geometry.Collections.SubDEdgeList.Find(self, id: System.UInt32) -> SubDEdge
Rhino.Geometry.Collections.SubDEdgeList.Find(self, id: int) -> SubDEdge
Rhino.Geometry.Collections.SubDEdgeList.GetEnumerator(self) -> IEnumerator<SubDEdge>
Rhino.Geometry.Collections.SubDEdgeList.SetEdgeTags(self, edgeIndices: Iterable[int], tag: Rhino.Geometry.SubDEdgeTag) -> None
Rhino.Geometry.Collections.SubDEdgeList.SetEdgeTags(self, edges: Iterable[Rhino.Geometry.SubDEdge], tag: Rhino.Geometry.SubDEdgeTag) -> None
Rhino.Geometry.Collections.SubDFaceList.ClearPerFaceColors(self) -> uint
Rhino.Geometry.Collections.SubDFaceList.Find(self, id: System.UInt32) -> SubDFace
Rhino.Geometry.Collections.SubDFaceList.Find(self, id: int) -> SubDFace
Rhino.Geometry.Collections.SubDFaceList.GetEnumerator(self) -> IEnumerator<SubDFace>
Rhino.Geometry.Collections.SubDVertexList.Add(self, tag: Rhino.Geometry.SubDVertexTag, vertex: Rhino.Geometry.Point3d) -> SubDVertex
Rhino.Geometry.Collections.SubDVertexList.Find(self, id: System.UInt32) -> SubDVertex
Rhino.Geometry.Collections.SubDVertexList.Find(self, id: int) -> SubDVertex
Rhino.Geometry.ComponentIndex.!=(a: Rhino.Geometry.ComponentIndex, b: Rhino.Geometry.ComponentIndex) -> operator
Rhino.Geometry.ComponentIndex.<(a: Rhino.Geometry.ComponentIndex, b: Rhino.Geometry.ComponentIndex) -> operator
Rhino.Geometry.ComponentIndex.<=(a: Rhino.Geometry.ComponentIndex, b: Rhino.Geometry.ComponentIndex) -> operator
Rhino.Geometry.ComponentIndex.==(a: Rhino.Geometry.ComponentIndex, b: Rhino.Geometry.ComponentIndex) -> operator
Rhino.Geometry.ComponentIndex.>(a: Rhino.Geometry.ComponentIndex, b: Rhino.Geometry.ComponentIndex) -> operator
Rhino.Geometry.ComponentIndex.>=(a: Rhino.Geometry.ComponentIndex, b: Rhino.Geometry.ComponentIndex) -> operator
Rhino.Geometry.ComponentIndex.CompareTo(self, other: Rhino.Geometry.ComponentIndex) -> int
Rhino.Geometry.ComponentIndex.Equals(self, obj: Any) -> bool
Rhino.Geometry.ComponentIndex.Equals(self, other: Rhino.Geometry.ComponentIndex) -> bool
Rhino.Geometry.ComponentIndex.GetHashCode(self) -> int
Rhino.Geometry.ComponentIndex.IsUnset(self) -> bool
Rhino.Geometry.ComponentIndex.__init__(self, type: Rhino.Geometry.ComponentIndexType, index: int) -> None
Rhino.Geometry.ComponentStatus.!=(a: Rhino.Geometry.ComponentStatus, b: Rhino.Geometry.ComponentStatus) -> operator
Rhino.Geometry.ComponentStatus.+(a: Rhino.Geometry.ComponentStatus, b: Rhino.Geometry.ComponentStatus) -> operator
Rhino.Geometry.ComponentStatus.==(a: Rhino.Geometry.ComponentStatus, b: Rhino.Geometry.ComponentStatus) -> operator
Rhino.Geometry.ComponentStatus.Equals(self, obj: Any) -> bool
Rhino.Geometry.ComponentStatus.Equals(self, other: Rhino.Geometry.ComponentStatus) -> bool
Rhino.Geometry.ComponentStatus.GetHashCode(self) -> int
Rhino.Geometry.ComponentStatus.HasAllEqualStates(self, statesFilter: Rhino.Geometry.ComponentStatus, comparand: Rhino.Geometry.ComponentStatus) -> bool
Rhino.Geometry.ComponentStatus.HasNoEqualStates(self, statesFilter: Rhino.Geometry.ComponentStatus, comparand: Rhino.Geometry.ComponentStatus) -> bool
Rhino.Geometry.ComponentStatus.HasSomeEqualStates(self, statesFilter: Rhino.Geometry.ComponentStatus, comparand: Rhino.Geometry.ComponentStatus) -> bool
Rhino.Geometry.ComponentStatus.ToString(self) -> str
Rhino.Geometry.ComponentStatus.WithStates(self, additionalStatus: Rhino.Geometry.ComponentStatus) -> Rhino.Geometry.ComponentStatus
Rhino.Geometry.Cone.AngleInDegrees(self) -> float
Rhino.Geometry.Cone.AngleInRadians(self) -> float
Rhino.Geometry.Cone.EpsilonEquals(self, other: Rhino.Geometry.Cone, epsilon: float) -> bool
Rhino.Geometry.Cone.ToBrep(self, capBottom: bool) -> Brep
Rhino.Geometry.Cone.ToNurbsSurface(self) -> NurbsSurface
Rhino.Geometry.Cone.ToRevSurface(self) -> RevSurface
Rhino.Geometry.Cone.__init__(self, plane: Rhino.Geometry.Plane, height: float, radius: float) -> None
Rhino.Geometry.ControlPoint.EpsilonEquals(self, other: Rhino.Geometry.ControlPoint, epsilon: float) -> bool
Rhino.Geometry.ControlPoint.Equals(self, other: Rhino.Geometry.ControlPoint) -> bool
Rhino.Geometry.ControlPoint.__init__(self, euclideanPt: Rhino.Geometry.Point3d, weight: float) -> None
Rhino.Geometry.ControlPoint.__init__(self, pt: Rhino.Geometry.Point3d) -> None
Rhino.Geometry.ControlPoint.__init__(self, pt: Rhino.Geometry.Point4d) -> None
Rhino.Geometry.ControlPoint.__init__(self, x: float, y: float, z: float) -> None
Rhino.Geometry.ControlPoint.__init__(self, x: float, y: float, z: float, weight: float) -> None
Rhino.Geometry.Curve.ChangeClosedCurveSeam(self, t: float) -> bool
Rhino.Geometry.Curve.ChangeDimension(self, desiredDimension: int) -> bool
Rhino.Geometry.Curve.ClosedCurveOrientation(self) -> CurveOrientation
Rhino.Geometry.Curve.ClosedCurveOrientation(self, plane: Rhino.Geometry.Plane) -> CurveOrientation
Rhino.Geometry.Curve.ClosedCurveOrientation(self, upDirection: Rhino.Geometry.Vector3d) -> CurveOrientation
Rhino.Geometry.Curve.ClosedCurveOrientation(self, xform: Rhino.Geometry.Transform) -> CurveOrientation
Rhino.Geometry.Curve.ClosestPoint(self, testPoint: Rhino.Geometry.Point3d, t: System.Double@) -> bool
Rhino.Geometry.Curve.ClosestPoint(self, testPoint: Rhino.Geometry.Point3d, t: System.Double@, maximumDistance: float) -> bool
Rhino.Geometry.Curve.ClosestPoints(self, geometry: Iterable[Rhino.Geometry.GeometryBase], pointOnCurve: Rhino.Geometry.Point3d@, pointOnObject: Rhino.Geometry.Point3d@, whichGeometry: System.Int32@) -> bool
Rhino.Geometry.Curve.ClosestPoints(self, geometry: Iterable[Rhino.Geometry.GeometryBase], pointOnCurve: Rhino.Geometry.Point3d@, pointOnObject: Rhino.Geometry.Point3d@, whichGeometry: System.Int32@, maximumDistance: float) -> bool
Rhino.Geometry.Curve.ClosestPoints(self, otherCurve: Rhino.Geometry.Curve, pointOnThisCurve: Rhino.Geometry.Point3d@, pointOnOtherCurve: Rhino.Geometry.Point3d@) -> bool
Rhino.Geometry.Curve.CombineShortSegments(self, tolerance: float) -> bool
Rhino.Geometry.Curve.Contains(self, testPoint: Rhino.Geometry.Point3d, plane: Rhino.Geometry.Plane, tolerance: float) -> PointContainment
Rhino.Geometry.Curve.ControlPolygon(self) -> Polyline
Rhino.Geometry.Curve.CreateArcBlend(startPt: Rhino.Geometry.Point3d, startDir: Rhino.Geometry.Vector3d, endPt: Rhino.Geometry.Point3d, endDir: Rhino.Geometry.Vector3d, controlPointLengthRatio: float) -> Rhino.Geometry.Curve
Rhino.Geometry.Curve.CreateArcCornerRectangle(rectangle: Rhino.Geometry.Rectangle3d, radius: float) -> Rhino.Geometry.Curve
Rhino.Geometry.Curve.CreateArcLineArcBlend(startPt: Rhino.Geometry.Point3d, startDir: Rhino.Geometry.Vector3d, endPt: Rhino.Geometry.Point3d, endDir: Rhino.Geometry.Vector3d, radius: float) -> Rhino.Geometry.Curve
Rhino.Geometry.Curve.CreateBlendCurve(curve0: Rhino.Geometry.Curve, t0: float, reverse0: bool, continuity0: Rhino.Geometry.BlendContinuity, curve1: Rhino.Geometry.Curve, t1: float, reverse1: bool, continuity1: Rhino.Geometry.BlendContinuity) -> Rhino.Geometry.Curve
Rhino.Geometry.Curve.CreateBlendCurve(curveA: Rhino.Geometry.Curve, curveB: Rhino.Geometry.Curve, continuity: Rhino.Geometry.BlendContinuity) -> Rhino.Geometry.Curve
Rhino.Geometry.Curve.CreateBlendCurve(curveA: Rhino.Geometry.Curve, curveB: Rhino.Geometry.Curve, continuity: Rhino.Geometry.BlendContinuity, bulgeA: float, bulgeB: float) -> Rhino.Geometry.Curve
Rhino.Geometry.Curve.CreateBooleanDifference(curveA: Rhino.Geometry.Curve, curveB: Rhino.Geometry.Curve, tolerance: float) -> List[Rhino.Geometry.Curve]
Rhino.Geometry.Curve.CreateBooleanDifference(curveA: Rhino.Geometry.Curve, subtractors: Iterable[Rhino.Geometry.Curve], tolerance: float) -> List[Rhino.Geometry.Curve]
Rhino.Geometry.Curve.CreateBooleanIntersection(curveA: Rhino.Geometry.Curve, curveB: Rhino.Geometry.Curve, tolerance: float) -> List[Rhino.Geometry.Curve]
Rhino.Geometry.Curve.CreateBooleanRegions(curves: Iterable[Rhino.Geometry.Curve], plane: Rhino.Geometry.Plane, combineRegions: bool, tolerance: float) -> CurveBooleanRegions
Rhino.Geometry.Curve.CreateBooleanRegions(curves: Iterable[Rhino.Geometry.Curve], plane: Rhino.Geometry.Plane, points: Iterable[Rhino.Geometry.Point3d], combineRegions: bool, tolerance: float) -> CurveBooleanRegions
Rhino.Geometry.Curve.CreateBooleanUnion(curves: Iterable[Rhino.Geometry.Curve], tolerance: float) -> List[Rhino.Geometry.Curve]
Rhino.Geometry.Curve.CreateConicCornerRectangle(rectangle: Rhino.Geometry.Rectangle3d, rho: float) -> Rhino.Geometry.Curve
Rhino.Geometry.Curve.CreateControlPointCurve(points: Iterable[Rhino.Geometry.Point3d]) -> Rhino.Geometry.Curve
Rhino.Geometry.Curve.CreateControlPointCurve(points: Iterable[Rhino.Geometry.Point3d], degree: int) -> Rhino.Geometry.Curve
Rhino.Geometry.Curve.CreateCurve2View(curveA: Rhino.Geometry.Curve, curveB: Rhino.Geometry.Curve, vectorA: Rhino.Geometry.Vector3d, vectorB: Rhino.Geometry.Vector3d, tolerance: float, angleTolerance: float) -> List[Rhino.Geometry.Curve]
Rhino.Geometry.Curve.CreateFillet(curve0: Rhino.Geometry.Curve, curve1: Rhino.Geometry.Curve, radius: float, t0Base: float, t1Base: float) -> Arc
Rhino.Geometry.Curve.CreateFilletCornersCurve(curve: Rhino.Geometry.Curve, radius: float, tolerance: float, angleTolerance: float) -> Rhino.Geometry.Curve
Rhino.Geometry.Curve.CreateFilletCurves(curve0: Rhino.Geometry.Curve, point0: Rhino.Geometry.Point3d, curve1: Rhino.Geometry.Curve, point1: Rhino.Geometry.Point3d, radius: float, join: bool, trim: bool, arcExtension: bool, tolerance: float, angleTolerance: float) -> List[Rhino.Geometry.Curve]
Rhino.Geometry.Curve.CreateInterpolatedCurve(points: Iterable[Rhino.Geometry.Point3d], degree: int) -> Rhino.Geometry.Curve
Rhino.Geometry.Curve.CreateInterpolatedCurve(points: Iterable[Rhino.Geometry.Point3d], degree: int, knots: Rhino.Geometry.CurveKnotStyle) -> Rhino.Geometry.Curve
Rhino.Geometry.Curve.CreateInterpolatedCurve(points: Iterable[Rhino.Geometry.Point3d], degree: int, knots: Rhino.Geometry.CurveKnotStyle, startTangent: Rhino.Geometry.Vector3d, endTangent: Rhino.Geometry.Vector3d) -> Rhino.Geometry.Curve
Rhino.Geometry.Curve.CreateMatchCurve(curve0: Rhino.Geometry.Curve, reverse0: bool, continuity: Rhino.Geometry.BlendContinuity, curve1: Rhino.Geometry.Curve, reverse1: bool, preserve: Rhino.Geometry.PreserveEnd, average: bool) -> List[Rhino.Geometry.Curve]
Rhino.Geometry.Curve.CreateMeanCurve(curveA: Rhino.Geometry.Curve, curveB: Rhino.Geometry.Curve) -> Rhino.Geometry.Curve
Rhino.Geometry.Curve.CreateMeanCurve(curveA: Rhino.Geometry.Curve, curveB: Rhino.Geometry.Curve, angleToleranceRadians: float) -> Rhino.Geometry.Curve
Rhino.Geometry.Curve.CreatePeriodicCurve(curve: Rhino.Geometry.Curve) -> Rhino.Geometry.Curve
Rhino.Geometry.Curve.CreatePeriodicCurve(curve: Rhino.Geometry.Curve, smooth: bool) -> Rhino.Geometry.Curve
Rhino.Geometry.Curve.CreateRevisionCloud(curve: Rhino.Geometry.Curve, segmentCount: int, angle: float, flip: bool) -> Rhino.Geometry.Curve
Rhino.Geometry.Curve.CreateRevisionCloud(points: Iterable[Rhino.Geometry.Point3d], angle: float, flip: bool) -> Rhino.Geometry.Curve
Rhino.Geometry.Curve.CreateSoftEditCurve(curve: Rhino.Geometry.Curve, t: float, delta: Rhino.Geometry.Vector3d, length: float, fixEnds: bool) -> Rhino.Geometry.Curve
Rhino.Geometry.Curve.CreateTextOutlines(text: str, font: str, textHeight: float, textStyle: int, closeLoops: bool, plane: Rhino.Geometry.Plane, smallCapsScale: float, tolerance: float) -> List[Rhino.Geometry.Curve]
Rhino.Geometry.Curve.CreateTweenCurves(curve0: Rhino.Geometry.Curve, curve1: Rhino.Geometry.Curve, numCurves: int, tolerance: float) -> List[Rhino.Geometry.Curve]
Rhino.Geometry.Curve.CreateTweenCurvesWithMatching(curve0: Rhino.Geometry.Curve, curve1: Rhino.Geometry.Curve, numCurves: int, tolerance: float) -> List[Rhino.Geometry.Curve]
Rhino.Geometry.Curve.CreateTweenCurvesWithSampling(curve0: Rhino.Geometry.Curve, curve1: Rhino.Geometry.Curve, numCurves: int, numSamples: int, tolerance: float) -> List[Rhino.Geometry.Curve]
Rhino.Geometry.Curve.CurvatureAt(self, t: float) -> Vector3d
Rhino.Geometry.Curve.DerivativeAt(self, t: float, derivativeCount: int) -> List[Vector3d]
Rhino.Geometry.Curve.DerivativeAt(self, t: float, derivativeCount: int, side: Rhino.Geometry.CurveEvaluationSide) -> List[Vector3d]
Rhino.Geometry.Curve.Dispose(self, disposing: bool) -> None
Rhino.Geometry.Curve.DivideAsContour(self, contourStart: Rhino.Geometry.Point3d, contourEnd: Rhino.Geometry.Point3d, interval: float) -> List[Point3d]
Rhino.Geometry.Curve.DivideByCount(self, segmentCount: int, includeEnds: bool) -> List[float]
Rhino.Geometry.Curve.DivideByCount(self, segmentCount: int, includeEnds: bool, points: Rhino.Geometry.Point3d[]@) -> List[float]
Rhino.Geometry.Curve.DivideByLength(self, segmentLength: float, includeEnds: bool) -> List[float]
Rhino.Geometry.Curve.DivideByLength(self, segmentLength: float, includeEnds: bool, points: Rhino.Geometry.Point3d[]@) -> List[float]
Rhino.Geometry.Curve.DivideByLength(self, segmentLength: float, includeEnds: bool, reverse: bool) -> List[float]
Rhino.Geometry.Curve.DivideByLength(self, segmentLength: float, includeEnds: bool, reverse: bool, points: Rhino.Geometry.Point3d[]@) -> List[float]
Rhino.Geometry.Curve.DivideEquidistant(self, distance: float) -> List[Point3d]
Rhino.Geometry.Curve.DivideEquidistant(self, distance: float, curveParameters: System.Double[]@) -> List[Point3d]
Rhino.Geometry.Curve.DoDirectionsMatch(curveA: Rhino.Geometry.Curve, curveB: Rhino.Geometry.Curve) -> bool
Rhino.Geometry.Curve.Duplicate(self) -> GeometryBase
Rhino.Geometry.Curve.DuplicateCurve(self) -> Rhino.Geometry.Curve
Rhino.Geometry.Curve.DuplicateSegments(self) -> List[Rhino.Geometry.Curve]
Rhino.Geometry.Curve.Extend(self, domain: Rhino.Geometry.Interval) -> Rhino.Geometry.Curve
Rhino.Geometry.Curve.Extend(self, side: Rhino.Geometry.CurveEnd, length: float, style: Rhino.Geometry.CurveExtensionStyle) -> Rhino.Geometry.Curve
Rhino.Geometry.Curve.Extend(self, side: Rhino.Geometry.CurveEnd, style: Rhino.Geometry.CurveExtensionStyle, endPoint: Rhino.Geometry.Point3d) -> Rhino.Geometry.Curve
Rhino.Geometry.Curve.Extend(self, side: Rhino.Geometry.CurveEnd, style: Rhino.Geometry.CurveExtensionStyle, geometry: Iterable[Rhino.Geometry.GeometryBase]) -> Rhino.Geometry.Curve
Rhino.Geometry.Curve.Extend(self, t0: float, t1: float) -> Rhino.Geometry.Curve
Rhino.Geometry.Curve.ExtendByArc(self, side: Rhino.Geometry.CurveEnd, geometry: Iterable[Rhino.Geometry.GeometryBase]) -> Rhino.Geometry.Curve
Rhino.Geometry.Curve.ExtendByLine(self, side: Rhino.Geometry.CurveEnd, geometry: Iterable[Rhino.Geometry.GeometryBase]) -> Rhino.Geometry.Curve
Rhino.Geometry.Curve.ExtendOnSurface(self, side: Rhino.Geometry.CurveEnd, face: Rhino.Geometry.BrepFace) -> Rhino.Geometry.Curve
Rhino.Geometry.Curve.ExtendOnSurface(self, side: Rhino.Geometry.CurveEnd, surface: Rhino.Geometry.Surface) -> Rhino.Geometry.Curve
Rhino.Geometry.Curve.ExtremeParameters(self, direction: Rhino.Geometry.Vector3d) -> List[float]
Rhino.Geometry.Curve.Fair(self, distanceTolerance: float, angleTolerance: float, clampStart: int, clampEnd: int, iterations: int) -> Rhino.Geometry.Curve
Rhino.Geometry.Curve.FilletSurfaceToCurve(self, face: Rhino.Geometry.BrepFace, t: float, u: float, v: float, radius: float, alignToCurve: int, railDegree: int, arcDegree: int, arcSliders: Iterable[float], numBezierSrfs: int, tolerance: float, out_fillets: List[Rhino.Geometry.Brep], fitResults: System.Double[]@) -> bool
Rhino.Geometry.Curve.FilletSurfaceToRail(self, faceWithCurve: Rhino.Geometry.BrepFace, secondFace: Rhino.Geometry.BrepFace, u1: float, v1: float, railDegree: int, arcDegree: int, arcSliders: Iterable[float], numBezierSrfs: int, extend: bool, split_type: Rhino.Geometry.FilletSurfaceSplitType, tolerance: float, out_fillets: List[Rhino.Geometry.Brep], out_breps0: List[Rhino.Geometry.Brep], out_breps1: List[Rhino.Geometry.Brep], fitResults: System.Double[]@) -> bool
Rhino.Geometry.Curve.FindLocalInflection(self, N: Rhino.Geometry.Vector3d, subDomain: Rhino.Geometry.Interval, seed: float, curveParameter: System.Double@, angleError: System.Double@) -> bool
Rhino.Geometry.Curve.Fit(self, degree: int, fitTolerance: float, angleTolerance: float) -> Rhino.Geometry.Curve
Rhino.Geometry.Curve.FrameAt(self, t: float, plane: Rhino.Geometry.Plane@) -> bool
Rhino.Geometry.Curve.GetConicSectionType(self) -> ConicSectionType
Rhino.Geometry.Curve.GetConicSectionType(self, focus1: Rhino.Geometry.Point3d@, focus2: Rhino.Geometry.Point3d@, center: Rhino.Geometry.Point3d@) -> ConicSectionType
Rhino.Geometry.Curve.GetCurveParameterFromNurbsFormParameter(self, nurbsParameter: float, curveParameter: System.Double@) -> bool
Rhino.Geometry.Curve.GetDistancesBetweenCurves(curveA: Rhino.Geometry.Curve, curveB: Rhino.Geometry.Curve, tolerance: float, maxDistance: System.Double@, maxDistanceParameterA: System.Double@, maxDistanceParameterB: System.Double@, minDistance: System.Double@, minDistanceParameterA: System.Double@, minDistanceParameterB: System.Double@) -> bool
Rhino.Geometry.Curve.GetFilletPoints(curve0: Rhino.Geometry.Curve, curve1: Rhino.Geometry.Curve, radius: float, t0Base: float, t1Base: float, t0: System.Double@, t1: System.Double@, filletPlane: Rhino.Geometry.Plane@) -> bool
Rhino.Geometry.Curve.GetLength(self) -> float
Rhino.Geometry.Curve.GetLength(self, fractionalTolerance: float) -> float
Rhino.Geometry.Curve.GetLength(self, fractionalTolerance: float, subdomain: Rhino.Geometry.Interval) -> float
Rhino.Geometry.Curve.GetLength(self, subdomain: Rhino.Geometry.Interval) -> float
Rhino.Geometry.Curve.GetLocalPerpPoint(self, testPoint: Rhino.Geometry.Point3d, seedParmameter: float, curveParameter: System.Double@) -> bool
Rhino.Geometry.Curve.GetLocalPerpPoint(self, testPoint: Rhino.Geometry.Point3d, seedParmameter: float, subDomain: Rhino.Geometry.Interval, curveParameter: System.Double@) -> bool
Rhino.Geometry.Curve.GetLocalTangentPoint(self, testPoint: Rhino.Geometry.Point3d, seedParmameter: float, curveParameter: System.Double@) -> bool
Rhino.Geometry.Curve.GetLocalTangentPoint(self, testPoint: Rhino.Geometry.Point3d, seedParmameter: float, subDomain: Rhino.Geometry.Interval, curveParameter: System.Double@) -> bool
Rhino.Geometry.Curve.GetNextDiscontinuity(self, continuityType: Rhino.Geometry.Continuity, t0: float, t1: float, cosAngleTolerance: float, curvatureTolerance: float, t: System.Double@) -> bool
Rhino.Geometry.Curve.GetNextDiscontinuity(self, continuityType: Rhino.Geometry.Continuity, t0: float, t1: float, t: System.Double@) -> bool
Rhino.Geometry.Curve.GetNurbsFormParameterFromCurveParameter(self, curveParameter: float, nurbsParameter: System.Double@) -> bool
Rhino.Geometry.Curve.GetPerpendicularFrames(self, parameters: Iterable[float]) -> List[Plane]
Rhino.Geometry.Curve.GetSubCurves(self) -> List[Rhino.Geometry.Curve]
Rhino.Geometry.Curve.HasNurbsForm(self) -> int
Rhino.Geometry.Curve.InflectionPoints(self) -> List[Point3d]
Rhino.Geometry.Curve.InflectionPoints(self, curveParameters: System.Double[]@) -> List[Point3d]
Rhino.Geometry.Curve.IsArc(self) -> bool
Rhino.Geometry.Curve.IsArc(self, tolerance: float) -> bool
Rhino.Geometry.Curve.IsCircle(self) -> bool
Rhino.Geometry.Curve.IsCircle(self, tolerance: float) -> bool
Rhino.Geometry.Curve.IsClosable(self, tolerance: float) -> bool
Rhino.Geometry.Curve.IsClosable(self, tolerance: float, minimumAbsoluteSize: float, minimumRelativeSize: float) -> bool
Rhino.Geometry.Curve.IsContinuous(self, continuityType: Rhino.Geometry.Continuity, t: float) -> bool
Rhino.Geometry.Curve.IsEllipse(self) -> bool
Rhino.Geometry.Curve.IsEllipse(self, tolerance: float) -> bool
Rhino.Geometry.Curve.IsInPlane(self, testPlane: Rhino.Geometry.Plane) -> bool
Rhino.Geometry.Curve.IsInPlane(self, testPlane: Rhino.Geometry.Plane, tolerance: float) -> bool
Rhino.Geometry.Curve.IsLinear(self) -> bool
Rhino.Geometry.Curve.IsLinear(self, tolerance: float) -> bool
Rhino.Geometry.Curve.IsPlanar(self) -> bool
Rhino.Geometry.Curve.IsPlanar(self, tolerance: float) -> bool
Rhino.Geometry.Curve.IsPolyline(self) -> bool
Rhino.Geometry.Curve.IsShort(self, tolerance: float) -> bool
Rhino.Geometry.Curve.IsShort(self, tolerance: float, subdomain: Rhino.Geometry.Interval) -> bool
Rhino.Geometry.Curve.JoinCurves(inputCurves: Iterable[Rhino.Geometry.Curve]) -> List[Rhino.Geometry.Curve]
Rhino.Geometry.Curve.JoinCurves(inputCurves: Iterable[Rhino.Geometry.Curve], joinTolerance: float) -> List[Rhino.Geometry.Curve]
Rhino.Geometry.Curve.JoinCurves(inputCurves: Iterable[Rhino.Geometry.Curve], joinTolerance: float, preserveDirection: bool) -> List[Rhino.Geometry.Curve]
Rhino.Geometry.Curve.JoinCurves(inputCurves: Iterable[Rhino.Geometry.Curve], joinTolerance: float, preserveDirection: bool, key: System.Int32[]@) -> List[Rhino.Geometry.Curve]
Rhino.Geometry.Curve.JoinCurves(inputCurves: Iterable[Rhino.Geometry.Curve], joinTolerance: float, preserveDirection: bool, simpleJoin: bool, key: System.Int32[]@) -> List[Rhino.Geometry.Curve]
Rhino.Geometry.Curve.LengthParameter(self, segmentLength: float, t: System.Double@) -> bool
Rhino.Geometry.Curve.LengthParameter(self, segmentLength: float, t: System.Double@, fractionalTolerance: float) -> bool
Rhino.Geometry.Curve.LengthParameter(self, segmentLength: float, t: System.Double@, fractionalTolerance: float, subdomain: Rhino.Geometry.Interval) -> bool
Rhino.Geometry.Curve.LengthParameter(self, segmentLength: float, t: System.Double@, subdomain: Rhino.Geometry.Interval) -> bool
Rhino.Geometry.Curve.LocalClosestPoint(self, testPoint: Rhino.Geometry.Point3d, seed: float, t: System.Double@) -> bool
Rhino.Geometry.Curve.MakeClosed(self, tolerance: float) -> bool
Rhino.Geometry.Curve.MakeEndsMeet(curveA: Rhino.Geometry.Curve, adjustStartCurveA: bool, curveB: Rhino.Geometry.Curve, adjustStartCurveB: bool) -> bool
Rhino.Geometry.Curve.MaxCurvaturePoints(self) -> List[Point3d]
Rhino.Geometry.Curve.MaxCurvaturePoints(self, curveParameters: System.Double[]@) -> List[Point3d]
Rhino.Geometry.Curve.NonConstOperation(self) -> None
Rhino.Geometry.Curve.NormalizedLengthParameter(self, s: float, t: System.Double@) -> bool
Rhino.Geometry.Curve.NormalizedLengthParameter(self, s: float, t: System.Double@, fractionalTolerance: float) -> bool
Rhino.Geometry.Curve.NormalizedLengthParameter(self, s: float, t: System.Double@, fractionalTolerance: float, subdomain: Rhino.Geometry.Interval) -> bool
Rhino.Geometry.Curve.NormalizedLengthParameter(self, s: float, t: System.Double@, subdomain: Rhino.Geometry.Interval) -> bool
Rhino.Geometry.Curve.NormalizedLengthParameters(self, s: List[float], absoluteTolerance: float) -> List[float]
Rhino.Geometry.Curve.NormalizedLengthParameters(self, s: List[float], absoluteTolerance: float, fractionalTolerance: float) -> List[float]
Rhino.Geometry.Curve.NormalizedLengthParameters(self, s: List[float], absoluteTolerance: float, fractionalTolerance: float, subdomain: Rhino.Geometry.Interval) -> List[float]
Rhino.Geometry.Curve.NormalizedLengthParameters(self, s: List[float], absoluteTolerance: float, subdomain: Rhino.Geometry.Interval) -> List[float]
Rhino.Geometry.Curve.Offset(self, directionPoint: Rhino.Geometry.Point3d, normal: Rhino.Geometry.Vector3d, distance: float, tolerance: float, angleTolerance: float, loose: bool, cornerStyle: Rhino.Geometry.CurveOffsetCornerStyle, endStyle: Rhino.Geometry.CurveOffsetEndStyle) -> List[Rhino.Geometry.Curve]
Rhino.Geometry.Curve.Offset(self, directionPoint: Rhino.Geometry.Point3d, normal: Rhino.Geometry.Vector3d, distance: float, tolerance: float, cornerStyle: Rhino.Geometry.CurveOffsetCornerStyle) -> List[Rhino.Geometry.Curve]
Rhino.Geometry.Curve.Offset(self, plane: Rhino.Geometry.Plane, distance: float, tolerance: float, cornerStyle: Rhino.Geometry.CurveOffsetCornerStyle) -> List[Rhino.Geometry.Curve]
Rhino.Geometry.Curve.OffsetNormalToSurface(self, surface: Rhino.Geometry.Surface, height: float) -> Rhino.Geometry.Curve
Rhino.Geometry.Curve.OffsetOnSurface(self, face: Rhino.Geometry.BrepFace, curveParameters: List[float], offsetDistances: List[float], fittingTolerance: float) -> List[Rhino.Geometry.Curve]
Rhino.Geometry.Curve.OffsetOnSurface(self, face: Rhino.Geometry.BrepFace, distance: float, fittingTolerance: float) -> List[Rhino.Geometry.Curve]
Rhino.Geometry.Curve.OffsetOnSurface(self, face: Rhino.Geometry.BrepFace, throughPoint: Rhino.Geometry.Point2d, fittingTolerance: float) -> List[Rhino.Geometry.Curve]
Rhino.Geometry.Curve.OffsetOnSurface(self, surface: Rhino.Geometry.Surface, curveParameters: List[float], offsetDistances: List[float], fittingTolerance: float) -> List[Rhino.Geometry.Curve]
Rhino.Geometry.Curve.OffsetOnSurface(self, surface: Rhino.Geometry.Surface, distance: float, fittingTolerance: float) -> List[Rhino.Geometry.Curve]
Rhino.Geometry.Curve.OffsetOnSurface(self, surface: Rhino.Geometry.Surface, throughPoint: Rhino.Geometry.Point2d, fittingTolerance: float) -> List[Rhino.Geometry.Curve]
Rhino.Geometry.Curve.OffsetTangentToSurface(self, surface: Rhino.Geometry.Surface, height: float) -> Rhino.Geometry.Curve
Rhino.Geometry.Curve.PerpendicularFrameAt(self, t: float, plane: Rhino.Geometry.Plane@) -> bool
Rhino.Geometry.Curve.PlanarClosedCurveRelationship(curveA: Rhino.Geometry.Curve, curveB: Rhino.Geometry.Curve, testPlane: Rhino.Geometry.Plane, tolerance: float) -> RegionContainment
Rhino.Geometry.Curve.PlanarCurveCollision(curveA: Rhino.Geometry.Curve, curveB: Rhino.Geometry.Curve, testPlane: Rhino.Geometry.Plane, tolerance: float) -> bool
Rhino.Geometry.Curve.PointAt(self, t: float) -> Point3d
Rhino.Geometry.Curve.PointAtLength(self, length: float) -> Point3d
Rhino.Geometry.Curve.PointAtNormalizedLength(self, length: float) -> Point3d
Rhino.Geometry.Curve.ProjectToBrep(curve: Rhino.Geometry.Curve, brep: Rhino.Geometry.Brep, direction: Rhino.Geometry.Vector3d, tolerance: float) -> List[Rhino.Geometry.Curve]
Rhino.Geometry.Curve.ProjectToBrep(curve: Rhino.Geometry.Curve, breps: Iterable[Rhino.Geometry.Brep], direction: Rhino.Geometry.Vector3d, tolerance: float) -> List[Rhino.Geometry.Curve]
Rhino.Geometry.Curve.ProjectToBrep(curve: Rhino.Geometry.Curve, breps: Iterable[Rhino.Geometry.Brep], direction: Rhino.Geometry.Vector3d, tolerance: float, brepIndices: System.Int32[]@) -> List[Rhino.Geometry.Curve]
Rhino.Geometry.Curve.ProjectToBrep(curves: Iterable[Rhino.Geometry.Curve], breps: Iterable[Rhino.Geometry.Brep], direction: Rhino.Geometry.Vector3d, tolerance: float) -> List[Rhino.Geometry.Curve]
Rhino.Geometry.Curve.ProjectToBrep(curves: Iterable[Rhino.Geometry.Curve], breps: Iterable[Rhino.Geometry.Brep], direction: Rhino.Geometry.Vector3d, tolerance: float, curveIndices: System.Int32[]@, brepIndices: System.Int32[]@) -> List[Rhino.Geometry.Curve]
Rhino.Geometry.Curve.ProjectToBrep(curves: Iterable[Rhino.Geometry.Curve], breps: Iterable[Rhino.Geometry.Brep], direction: Rhino.Geometry.Vector3d, tolerance: float, loose: bool, curveIndices: System.Int32[]@, brepIndices: System.Int32[]@) -> List[Rhino.Geometry.Curve]
Rhino.Geometry.Curve.ProjectToMesh(curve: Rhino.Geometry.Curve, mesh: Rhino.Geometry.Mesh, direction: Rhino.Geometry.Vector3d, tolerance: float) -> List[Rhino.Geometry.Curve]
Rhino.Geometry.Curve.ProjectToMesh(curve: Rhino.Geometry.Curve, meshes: Iterable[Rhino.Geometry.Mesh], direction: Rhino.Geometry.Vector3d, tolerance: float) -> List[Rhino.Geometry.Curve]
Rhino.Geometry.Curve.ProjectToMesh(curves: Iterable[Rhino.Geometry.Curve], meshes: Iterable[Rhino.Geometry.Mesh], direction: Rhino.Geometry.Vector3d, tolerance: float) -> List[Rhino.Geometry.Curve]
Rhino.Geometry.Curve.ProjectToMesh(curves: Iterable[Rhino.Geometry.Curve], meshes: Iterable[Rhino.Geometry.Mesh], direction: Rhino.Geometry.Vector3d, tolerance: float, loose: bool) -> List[Rhino.Geometry.Curve]
Rhino.Geometry.Curve.ProjectToPlane(curve: Rhino.Geometry.Curve, plane: Rhino.Geometry.Plane) -> Rhino.Geometry.Curve
Rhino.Geometry.Curve.PullToBrepFace(curve: Rhino.Geometry.Curve, face: Rhino.Geometry.BrepFace, tolerance: float) -> List[Rhino.Geometry.Curve]
Rhino.Geometry.Curve.PullToBrepFace(curve: Rhino.Geometry.Curve, face: Rhino.Geometry.BrepFace, tolerance: float, loose: bool) -> List[Rhino.Geometry.Curve]
Rhino.Geometry.Curve.PullToBrepFace(self, face: Rhino.Geometry.BrepFace, tolerance: float) -> List[Rhino.Geometry.Curve]
Rhino.Geometry.Curve.PullToMesh(self, mesh: Rhino.Geometry.Mesh, tolerance: float) -> PolylineCurve
Rhino.Geometry.Curve.PullToMesh(self, mesh: Rhino.Geometry.Mesh, tolerance: float, loose: bool) -> Rhino.Geometry.Curve
Rhino.Geometry.Curve.Rebuild(self, pointCount: int, degree: int, preserveTangents: bool) -> NurbsCurve
Rhino.Geometry.Curve.RemoveShortSegments(self, tolerance: float) -> bool
Rhino.Geometry.Curve.Repair(self, tolerance: float) -> bool
Rhino.Geometry.Curve.Reparameterize(self) -> Rhino.Geometry.Curve
Rhino.Geometry.Curve.Reverse(self) -> bool
Rhino.Geometry.Curve.RibbonOffset(self, distance: float, blendRadius: float, directionPoint: Rhino.Geometry.Point3d, normal: Rhino.Geometry.Vector3d, tolerance: float) -> Rhino.Geometry.Curve
Rhino.Geometry.Curve.RibbonOffset(self, distance: float, blendRadius: float, directionPoint: Rhino.Geometry.Point3d, normal: Rhino.Geometry.Vector3d, tolerance: float, crossSections: Rhino.Geometry.Curve[]@, ruledSurfaces: Rhino.Geometry.Surface[]@) -> Rhino.Geometry.Curve
Rhino.Geometry.Curve.RibbonOffset(self, distance: float, blendRadius: float, directionPoint: Rhino.Geometry.Point3d, normal: Rhino.Geometry.Vector3d, tolerance: float, outputParameters: System.Double[]@, curveParameters: System.Double[]@) -> Rhino.Geometry.Curve
Rhino.Geometry.Curve.RibbonOffset(self, ribbonParameters: Rhino.Geometry.RibbonOffsetParameters, railCurves: Rhino.Geometry.Curve[]@, crossSectionCurves: Rhino.Geometry.Curve[]@, brepSurfaces: Rhino.Geometry.Brep[]@) -> Rhino.Geometry.Curve
Rhino.Geometry.Curve.SetEndPoint(self, point: Rhino.Geometry.Point3d) -> bool
Rhino.Geometry.Curve.SetStartPoint(self, point: Rhino.Geometry.Point3d) -> bool
Rhino.Geometry.Curve.Simplify(self, options: Rhino.Geometry.CurveSimplifyOptions, distanceTolerance: float, angleToleranceRadians: float) -> Rhino.Geometry.Curve
Rhino.Geometry.Curve.SimplifyEnd(self, end: Rhino.Geometry.CurveEnd, options: Rhino.Geometry.CurveSimplifyOptions, distanceTolerance: float, angleToleranceRadians: float) -> Rhino.Geometry.Curve
Rhino.Geometry.Curve.Smooth(self, smoothFactor: float, bXSmooth: bool, bYSmooth: bool, bZSmooth: bool, bFixBoundaries: bool, coordinateSystem: Rhino.Geometry.SmoothingCoordinateSystem) -> Rhino.Geometry.Curve
Rhino.Geometry.Curve.Smooth(self, smoothFactor: float, bXSmooth: bool, bYSmooth: bool, bZSmooth: bool, bFixBoundaries: bool, coordinateSystem: Rhino.Geometry.SmoothingCoordinateSystem, plane: Rhino.Geometry.Plane) -> Rhino.Geometry.Curve
Rhino.Geometry.Curve.SpanDomain(self, spanIndex: int) -> Interval
Rhino.Geometry.Curve.SpanVector(self) -> List[float]
Rhino.Geometry.Curve.Split(self, cutter: Rhino.Geometry.Brep, tolerance: float, angleToleranceRadians: float) -> List[Rhino.Geometry.Curve]
Rhino.Geometry.Curve.Split(self, cutter: Rhino.Geometry.Surface, tolerance: float, angleToleranceRadians: float) -> List[Rhino.Geometry.Curve]
Rhino.Geometry.Curve.Split(self, t: Iterable[float]) -> List[Rhino.Geometry.Curve]
Rhino.Geometry.Curve.Split(self, t: float) -> List[Rhino.Geometry.Curve]
Rhino.Geometry.Curve.TangentAt(self, t: float) -> Vector3d
Rhino.Geometry.Curve.ToArcsAndLines(self, tolerance: float, angleTolerance: float, minimumLength: float, maximumLength: float) -> PolyCurve
Rhino.Geometry.Curve.ToNurbsCurve(self) -> NurbsCurve
Rhino.Geometry.Curve.ToNurbsCurve(self, subdomain: Rhino.Geometry.Interval) -> NurbsCurve
Rhino.Geometry.Curve.ToPolyline(self, mainSegmentCount: int, subSegmentCount: int, maxAngleRadians: float, maxChordLengthRatio: float, maxAspectRatio: float, tolerance: float, minEdgeLength: float, maxEdgeLength: float, keepStartPoint: bool) -> PolylineCurve
Rhino.Geometry.Curve.ToPolyline(self, mainSegmentCount: int, subSegmentCount: int, maxAngleRadians: float, maxChordLengthRatio: float, maxAspectRatio: float, tolerance: float, minEdgeLength: float, maxEdgeLength: float, keepStartPoint: bool, curveDomain: Rhino.Geometry.Interval) -> PolylineCurve
Rhino.Geometry.Curve.ToPolyline(self, tolerance: float, angleTolerance: float, minimumLength: float, maximumLength: float) -> PolylineCurve
Rhino.Geometry.Curve.TorsionAt(self, t: float) -> float
Rhino.Geometry.Curve.Trim(self, domain: Rhino.Geometry.Interval) -> Rhino.Geometry.Curve
Rhino.Geometry.Curve.Trim(self, side: Rhino.Geometry.CurveEnd, length: float) -> Rhino.Geometry.Curve
Rhino.Geometry.Curve.Trim(self, t0: float, t1: float) -> Rhino.Geometry.Curve
Rhino.Geometry.Curve.TryGetArc(self, arc: Rhino.Geometry.Arc@) -> bool
Rhino.Geometry.Curve.TryGetArc(self, arc: Rhino.Geometry.Arc@, tolerance: float) -> bool
Rhino.Geometry.Curve.TryGetArc(self, plane: Rhino.Geometry.Plane, arc: Rhino.Geometry.Arc@) -> bool
Rhino.Geometry.Curve.TryGetArc(self, plane: Rhino.Geometry.Plane, arc: Rhino.Geometry.Arc@, tolerance: float) -> bool
Rhino.Geometry.Curve.TryGetCircle(self, circle: Rhino.Geometry.Circle@) -> bool
Rhino.Geometry.Curve.TryGetCircle(self, circle: Rhino.Geometry.Circle@, tolerance: float) -> bool
Rhino.Geometry.Curve.TryGetEllipse(self, ellipse: Rhino.Geometry.Ellipse@) -> bool
Rhino.Geometry.Curve.TryGetEllipse(self, ellipse: Rhino.Geometry.Ellipse@, tolerance: float) -> bool
Rhino.Geometry.Curve.TryGetEllipse(self, plane: Rhino.Geometry.Plane, ellipse: Rhino.Geometry.Ellipse@) -> bool
Rhino.Geometry.Curve.TryGetEllipse(self, plane: Rhino.Geometry.Plane, ellipse: Rhino.Geometry.Ellipse@, tolerance: float) -> bool
Rhino.Geometry.Curve.TryGetPlane(self, plane: Rhino.Geometry.Plane@) -> bool
Rhino.Geometry.Curve.TryGetPlane(self, plane: Rhino.Geometry.Plane@, tolerance: float) -> bool
Rhino.Geometry.Curve.TryGetPolyline(self, polyline: Rhino.Geometry.Polyline@) -> bool
Rhino.Geometry.Curve.TryGetPolyline(self, polyline: Rhino.Geometry.Polyline@, parameters: System.Double[]@) -> bool
Rhino.Geometry.Curve.[ObsoleteAttribute(self, arg1: Iterable[Rhino.Geometry.Curve]) -> None
Rhino.Geometry.Curve.[ObsoleteAttribute(self, arg1: Rhino.Geometry.Brep, arg2: float) -> None
Rhino.Geometry.Curve.[ObsoleteAttribute(self, arg1: Rhino.Geometry.Curve, arg2: Iterable[Rhino.Geometry.Curve]) -> None
Rhino.Geometry.Curve.[ObsoleteAttribute(self, arg1: Rhino.Geometry.Curve, arg2: Rhino.Geometry.Curve) -> None
Rhino.Geometry.Curve.[ObsoleteAttribute(self, arg1: Rhino.Geometry.Curve, arg2: Rhino.Geometry.Curve) -> None
Rhino.Geometry.Curve.[ObsoleteAttribute(self, arg1: Rhino.Geometry.Curve, arg2: Rhino.Geometry.Curve, arg3: int) -> None
Rhino.Geometry.Curve.[ObsoleteAttribute(self, arg1: Rhino.Geometry.Curve, arg2: Rhino.Geometry.Curve, arg3: int) -> None
Rhino.Geometry.Curve.[ObsoleteAttribute(self, arg1: Rhino.Geometry.Curve, arg2: Rhino.Geometry.Curve, arg3: int, arg4: int) -> None
Rhino.Geometry.Curve.[ObsoleteAttribute(self, arg1: Rhino.Geometry.Point3d) -> None
Rhino.Geometry.Curve.[ObsoleteAttribute(self, arg1: Rhino.Geometry.Point3d, arg2: Rhino.Geometry.Plane) -> None
Rhino.Geometry.Curve.[ObsoleteAttribute(self, arg1: Rhino.Geometry.Surface, arg2: float) -> None
Rhino.Geometry.Curve.__init__(self, info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext) -> None
Rhino.Geometry.CurveBooleanRegions.BoundaryCount(self, regionIndex: int) -> int
Rhino.Geometry.CurveBooleanRegions.Dispose(self) -> None
Rhino.Geometry.CurveBooleanRegions.Dispose(self, disposing: bool) -> None
Rhino.Geometry.CurveBooleanRegions.PlanarCurve(self, planarCurveIndex: int) -> Curve
Rhino.Geometry.CurveBooleanRegions.RegionCurves(self, regionIndex: int) -> List[Curve]
Rhino.Geometry.CurveBooleanRegions.RegionPointIndex(self, pointIndex: int) -> int
Rhino.Geometry.CurveBooleanRegions.SegmentCount(self, regionIndex: int, boundaryIndex: int) -> int
Rhino.Geometry.CurveBooleanRegions.SegmentDetails(self, regionIndex: int, boundaryIndex: int, segmmentIndex: int, subDomain: Rhino.Geometry.Interval@, reversed: System.Boolean@) -> int
Rhino.Geometry.CurveBooleanRegions.__init__(self, info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext) -> None
Rhino.Geometry.CurveProxy.__init__(self) -> None
Rhino.Geometry.Cylinder.CircleAt(self, linearParameter: float) -> Circle
Rhino.Geometry.Cylinder.EpsilonEquals(self, other: Rhino.Geometry.Cylinder, epsilon: float) -> bool
Rhino.Geometry.Cylinder.LineAt(self, angularParameter: float) -> Line
Rhino.Geometry.Cylinder.ToBrep(self, capBottom: bool, capTop: bool) -> Brep
Rhino.Geometry.Cylinder.ToNurbsSurface(self) -> NurbsSurface
Rhino.Geometry.Cylinder.ToRevSurface(self) -> RevSurface
Rhino.Geometry.Cylinder.Transform(self, xform: Rhino.Geometry.Transform) -> bool
Rhino.Geometry.Cylinder.__init__(self, baseCircle: Rhino.Geometry.Circle) -> None
Rhino.Geometry.Cylinder.__init__(self, baseCircle: Rhino.Geometry.Circle, height: float) -> None
Rhino.Geometry.DetailView.SetScale(self, modelLength: float, modelUnits: Rhino.UnitSystem, pageLength: float, pageUnits: Rhino.UnitSystem) -> bool
Rhino.Geometry.DetailView.__init__(self, info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext) -> None
Rhino.Geometry.DevelopableSrf.GetLocalDevopableRuling(rail0: Rhino.Geometry.NurbsCurve, t0: float, dom0: Rhino.Geometry.Interval, rail1: Rhino.Geometry.NurbsCurve, t1: float, dom1: Rhino.Geometry.Interval, t0_out: System.Double@, t1_out: System.Double@) -> int
Rhino.Geometry.DevelopableSrf.RulingMinTwist(rail0: Rhino.Geometry.NurbsCurve, t0: float, dom0: Rhino.Geometry.Interval, rail1: Rhino.Geometry.NurbsCurve, t1: float, dom1: Rhino.Geometry.Interval, t0_out: System.Double@, t1_out: System.Double@, cos_twist_out: System.Double@) -> bool
Rhino.Geometry.DevelopableSrf.RulingMinTwist(rail0: Rhino.Geometry.NurbsCurve, t0: float, rail1: Rhino.Geometry.NurbsCurve, t1: float, dom1: Rhino.Geometry.Interval, t1_out: System.Double@, cos_twist_out: System.Double@) -> bool
Rhino.Geometry.DevelopableSrf.UntwistRulings(rail0: Rhino.Geometry.NurbsCurve, rail1: Rhino.Geometry.NurbsCurve, rulings: System.Collections.Generic.IEnumerable{Rhino.Geometry.Point2d}@) -> bool
Rhino.Geometry.DevelopableSrf.__init__(self) -> None
Rhino.Geometry.Dimension.Explode(self) -> List[GeometryBase]
Rhino.Geometry.Dimension.GetTextTransform(self, viewport: Rhino.DocObjects.ViewportInfo, style: Rhino.DocObjects.DimensionStyle, textScale: float, drawForward: bool) -> Transform
Rhino.Geometry.Dimension.SetAltDimensionLengthDisplayWithZeroSuppressionReset(self, arg1: Rhino.DocObjects.DimensionStyle.LengthDisplay) -> None
Rhino.Geometry.Dimension.SetDimensionLengthDisplayWithZeroSuppressionReset(self, arg1: Rhino.DocObjects.DimensionStyle.LengthDisplay) -> None
Rhino.Geometry.Dimension.UpdateDimensionText(self, style: Rhino.DocObjects.DimensionStyle, units: Rhino.UnitSystem) -> None
Rhino.Geometry.Dimension.__init__(self) -> None
Rhino.Geometry.Dimension.__init__(self, info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext) -> None
Rhino.Geometry.Ellipse.EpsilonEquals(self, other: Rhino.Geometry.Ellipse, epsilon: float) -> bool
Rhino.Geometry.Ellipse.GetFoci(self, F1: Rhino.Geometry.Point3d@, F2: Rhino.Geometry.Point3d@) -> None
Rhino.Geometry.Ellipse.ToNurbsCurve(self) -> NurbsCurve
Rhino.Geometry.Ellipse.__init__(self, center: Rhino.Geometry.Point3d, second: Rhino.Geometry.Point3d, third: Rhino.Geometry.Point3d) -> None
Rhino.Geometry.Ellipse.__init__(self, plane: Rhino.Geometry.Plane, radius1: float, radius2: float) -> None
Rhino.Geometry.Extrusion.AddInnerProfile(self, innerProfile: Rhino.Geometry.Curve) -> bool
Rhino.Geometry.Extrusion.Create(curve: Rhino.Geometry.Curve, plane: Rhino.Geometry.Plane, height: float, cap: bool) -> Rhino.Geometry.Extrusion
Rhino.Geometry.Extrusion.Create(planarCurve: Rhino.Geometry.Curve, height: float, cap: bool) -> Rhino.Geometry.Extrusion
Rhino.Geometry.Extrusion.CreateBoxExtrusion(box: Rhino.Geometry.Box, cap: bool) -> Rhino.Geometry.Extrusion
Rhino.Geometry.Extrusion.CreateCylinderExtrusion(cylinder: Rhino.Geometry.Cylinder, capBottom: bool, capTop: bool) -> Rhino.Geometry.Extrusion
Rhino.Geometry.Extrusion.CreatePipeExtrusion(cylinder: Rhino.Geometry.Cylinder, otherRadius: float, capTop: bool, capBottom: bool) -> Rhino.Geometry.Extrusion
Rhino.Geometry.Extrusion.GetBrepFormComponentIndex(self, extrusionComponentIndex: Rhino.Geometry.ComponentIndex) -> ComponentIndex
Rhino.Geometry.Extrusion.GetMesh(self, meshType: Rhino.Geometry.MeshType) -> Mesh
Rhino.Geometry.Extrusion.GetPathPlane(self, s: float) -> Plane
Rhino.Geometry.Extrusion.GetProfilePlane(self, s: float) -> Plane
Rhino.Geometry.Extrusion.GetProfileTransformation(self, s: float) -> Transform
Rhino.Geometry.Extrusion.GetWireframe(self) -> List[Curve]
Rhino.Geometry.Extrusion.PathLineCurve(self) -> LineCurve
Rhino.Geometry.Extrusion.Profile3d(self, ci: Rhino.Geometry.ComponentIndex) -> Curve
Rhino.Geometry.Extrusion.Profile3d(self, profileIndex: int, s: float) -> Curve
Rhino.Geometry.Extrusion.ProfileIndex(self, profileParameter: float) -> int
Rhino.Geometry.Extrusion.SetMesh(self, mesh: Rhino.Geometry.Mesh, meshType: Rhino.Geometry.MeshType) -> bool
Rhino.Geometry.Extrusion.SetOuterProfile(self, outerProfile: Rhino.Geometry.Curve, cap: bool) -> bool
Rhino.Geometry.Extrusion.SetPathAndUp(self, a: Rhino.Geometry.Point3d, b: Rhino.Geometry.Point3d, up: Rhino.Geometry.Vector3d) -> bool
Rhino.Geometry.Extrusion.ToBrep(self, splitKinkyFaces: bool) -> Brep
Rhino.Geometry.Extrusion.WallEdge(self, ci: Rhino.Geometry.ComponentIndex) -> Curve
Rhino.Geometry.Extrusion.WallSurface(self, ci: Rhino.Geometry.ComponentIndex) -> Surface
Rhino.Geometry.Extrusion.__init__(self) -> None
Rhino.Geometry.Extrusion.__init__(self, info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext) -> None
Rhino.Geometry.GeometryBase.ComponentIndex(self) -> ComponentIndex
Rhino.Geometry.GeometryBase.DataCRC(self, currentRemainder: System.UInt32) -> uint
Rhino.Geometry.GeometryBase.DeleteAllUserStrings(self) -> None
Rhino.Geometry.GeometryBase.DeleteUserString(self, key: str) -> bool
Rhino.Geometry.GeometryBase.Dispose(self, disposing: bool) -> None
Rhino.Geometry.GeometryBase.Duplicate(self) -> Rhino.Geometry.GeometryBase
Rhino.Geometry.GeometryBase.DuplicateShallow(self) -> Rhino.Geometry.GeometryBase
Rhino.Geometry.GeometryBase.GeometryEquals(first: Rhino.Geometry.GeometryBase, second: Rhino.Geometry.GeometryBase) -> bool
Rhino.Geometry.GeometryBase.GeometryReferenceEquals(one: Rhino.Geometry.GeometryBase, other: Rhino.Geometry.GeometryBase) -> bool
Rhino.Geometry.GeometryBase.GetBoundingBox(self, accurate: bool) -> BoundingBox
Rhino.Geometry.GeometryBase.GetBoundingBox(self, plane: Rhino.Geometry.Plane) -> BoundingBox
Rhino.Geometry.GeometryBase.GetBoundingBox(self, plane: Rhino.Geometry.Plane, worldBox: Rhino.Geometry.Box@) -> BoundingBox
Rhino.Geometry.GeometryBase.GetBoundingBox(self, xform: Rhino.Geometry.Transform) -> BoundingBox
Rhino.Geometry.GeometryBase.GetUserString(self, key: str) -> str
Rhino.Geometry.GeometryBase.GetUserStrings(self) -> NameValueCollection
Rhino.Geometry.GeometryBase.MakeDeformable(self) -> bool
Rhino.Geometry.GeometryBase.MemoryEstimate(self) -> uint
Rhino.Geometry.GeometryBase.NonConstOperation(self) -> None
Rhino.Geometry.GeometryBase.OnSwitchToNonConst(self) -> None
Rhino.Geometry.GeometryBase.Rotate(self, angleRadians: float, rotationAxis: Rhino.Geometry.Vector3d, rotationCenter: Rhino.Geometry.Point3d) -> bool
Rhino.Geometry.GeometryBase.Scale(self, scaleFactor: float) -> bool
Rhino.Geometry.GeometryBase.SetUserString(self, key: str, value: str) -> bool
Rhino.Geometry.GeometryBase.Transform(self, xform: Rhino.Geometry.Transform) -> bool
Rhino.Geometry.GeometryBase.Translate(self, translationVector: Rhino.Geometry.Vector3d) -> bool
Rhino.Geometry.GeometryBase.Translate(self, x: float, y: float, z: float) -> bool
Rhino.Geometry.GeometryBase.__init__(self, info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext) -> None
Rhino.Geometry.Hatch.Create(curve: Rhino.Geometry.Curve, hatchPatternIndex: int, rotationRadians: float, scale: float, tolerance: float) -> List[Rhino.Geometry.Hatch]
Rhino.Geometry.Hatch.Create(curves: Iterable[Rhino.Geometry.Curve], hatchPatternIndex: int, rotationRadians: float, scale: float, tolerance: float) -> List[Rhino.Geometry.Hatch]
Rhino.Geometry.Hatch.Create(hatchPlane: Rhino.Geometry.Plane, outerLoop: Rhino.Geometry.Curve, innerLoops: Iterable[Rhino.Geometry.Curve], hatchPatternIndex: int, rotationRadians: float, scale: float) -> Rhino.Geometry.Hatch
Rhino.Geometry.Hatch.CreateDisplayGeometry(self, pattern: Rhino.DocObjects.HatchPattern, patternScale: float, bounds: Rhino.Geometry.Curve[]@, lines: Rhino.Geometry.Line[]@, solidBrep: Rhino.Geometry.Brep@) -> None
Rhino.Geometry.Hatch.CreateFromBrep(brep: Rhino.Geometry.Brep, brepFaceIndex: int, hatchPatternIndex: int, rotationRadians: float, scale: float, basePoint: Rhino.Geometry.Point3d) -> Rhino.Geometry.Hatch
Rhino.Geometry.Hatch.Explode(self) -> List[GeometryBase]
Rhino.Geometry.Hatch.Get2dCurves(self, outer: bool) -> List[Curve]
Rhino.Geometry.Hatch.Get3dCurves(self, outer: bool) -> List[Curve]
Rhino.Geometry.Hatch.GetGradientFill(self) -> ColorGradient
Rhino.Geometry.Hatch.ScalePattern(self, xform: Rhino.Geometry.Transform) -> None
Rhino.Geometry.Hatch.SetGradientFill(self, fill: Rhino.Display.ColorGradient) -> None
Rhino.Geometry.Hatch.ToBrep(self) -> Brep
Rhino.Geometry.Hatch.[ObsoleteAttribute(self, arg1: Iterable[Rhino.Geometry.Curve], arg2: int, arg3: float, arg4: float) -> None
Rhino.Geometry.Hatch.[ObsoleteAttribute(self, arg1: Rhino.Geometry.Curve, arg2: int, arg3: float, arg4: float) -> None
Rhino.Geometry.Hatch.__init__(self, info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext) -> None
Rhino.Geometry.HermiteSurface.Dispose(self) -> None
Rhino.Geometry.HermiteSurface.Finalize(self) -> None
Rhino.Geometry.HermiteSurface.PointAt(self, uIndex: int, vIndex: int) -> Point3d
Rhino.Geometry.HermiteSurface.SetPointAt(self, uIndex: int, vIndex: int, point: Rhino.Geometry.Point3d) -> None
Rhino.Geometry.HermiteSurface.SetTwistAt(self, uIndex: int, vIndex: int, twist: Rhino.Geometry.Vector3d) -> None
Rhino.Geometry.HermiteSurface.SetUParameterAt(self, index: int, parameter: float) -> None
Rhino.Geometry.HermiteSurface.SetUTangentAt(self, uIndex: int, vIndex: int, tangent: Rhino.Geometry.Vector3d) -> None
Rhino.Geometry.HermiteSurface.SetVParameterAt(self, index: int, parameter: float) -> None
Rhino.Geometry.HermiteSurface.SetVTangentAt(self, uIndex: int, vIndex: int, tangent: Rhino.Geometry.Vector3d) -> None
Rhino.Geometry.HermiteSurface.ToNurbsSurface(self) -> NurbsSurface
Rhino.Geometry.HermiteSurface.TwistAt(self, uIndex: int, vIndex: int) -> Vector3d
Rhino.Geometry.HermiteSurface.UParameterAt(self, index: int) -> float
Rhino.Geometry.HermiteSurface.UTangentAt(self, uIndex: int, vIndex: int) -> Vector3d
Rhino.Geometry.HermiteSurface.VParameterAt(self, index: int) -> float
Rhino.Geometry.HermiteSurface.VTangentAt(self, uIndex: int, vIndex: int) -> Vector3d
Rhino.Geometry.HermiteSurface.__init__(self) -> None
Rhino.Geometry.HermiteSurface.__init__(self, uCount: int, vCount: int) -> None
Rhino.Geometry.HiddenLineDrawing.BoundingBox(self, includeHidden: bool) -> BoundingBox
Rhino.Geometry.HiddenLineDrawing.Compute(parameters: Rhino.Geometry.HiddenLineDrawingParameters, multipleThreads: bool) -> Rhino.Geometry.HiddenLineDrawing
Rhino.Geometry.HiddenLineDrawing.Compute(parameters: Rhino.Geometry.HiddenLineDrawingParameters, multipleThreads: bool, progress: IProgress[float], cancelToken: System.Threading.CancellationToken) -> Rhino.Geometry.HiddenLineDrawing
Rhino.Geometry.HiddenLineDrawing.Dispose(self) -> None
Rhino.Geometry.HiddenLineDrawing.Finalize(self) -> None
Rhino.Geometry.HiddenLineDrawing.RejoinCompatibleVisible(self) -> None
Rhino.Geometry.HiddenLineDrawingObjectCurve.Curve(self, t: float) -> HiddenLineDrawingSegment
Rhino.Geometry.HiddenLineDrawingObjectCurve.Curve(self, t: float, side: int) -> HiddenLineDrawingSegment
Rhino.Geometry.HiddenLineDrawingParameters.AddClippingPlane(self, plane: Rhino.Geometry.Plane) -> None
Rhino.Geometry.HiddenLineDrawingParameters.AddGeometry(self, geometry: Rhino.Geometry.GeometryBase, tag: Any) -> bool
Rhino.Geometry.HiddenLineDrawingParameters.AddGeometry(self, geometry: Rhino.Geometry.GeometryBase, tag: Any, occluding_sections: bool) -> bool
Rhino.Geometry.HiddenLineDrawingParameters.AddGeometry(self, geometry: Rhino.Geometry.GeometryBase, xform: Rhino.Geometry.Transform, tag: Any) -> bool
Rhino.Geometry.HiddenLineDrawingParameters.AddGeometry(self, geometry: Rhino.Geometry.GeometryBase, xform: Rhino.Geometry.Transform, tag: Any, occluding_sections: bool) -> bool
Rhino.Geometry.HiddenLineDrawingParameters.AddGeometryAndPlanes(self, geometry: Rhino.Geometry.GeometryBase, tag: Any, clips: List[Rhino.Geometry.Plane]) -> bool
Rhino.Geometry.HiddenLineDrawingParameters.AddGeometryAndPlanes(self, geometry: Rhino.Geometry.GeometryBase, tag: Any, occluding_sections: bool, clips: List[Rhino.Geometry.Plane]) -> bool
Rhino.Geometry.HiddenLineDrawingParameters.AddGeometryAndPlanes(self, geometry: Rhino.Geometry.GeometryBase, xform: Rhino.Geometry.Transform, tag: Any, clips: List[Rhino.Geometry.Plane]) -> bool
Rhino.Geometry.HiddenLineDrawingParameters.AddGeometryAndPlanes(self, geometry: Rhino.Geometry.GeometryBase, xform: Rhino.Geometry.Transform, tag: Any, occluding_sections: bool, clips: List[Rhino.Geometry.Plane]) -> bool
Rhino.Geometry.HiddenLineDrawingParameters.SetViewport(self, viewport: Rhino.Display.RhinoViewport) -> None
Rhino.Geometry.HiddenLineDrawingParameters.SetViewport(self, viewport: Rhino.DocObjects.ViewportInfo) -> None
Rhino.Geometry.HiddenLineDrawingParameters.__init__(self) -> None
Rhino.Geometry.InstanceDefinitionGeometry.DeleteAllUserStrings(self) -> None
Rhino.Geometry.InstanceDefinitionGeometry.DeleteUserString(self, key: str) -> bool
Rhino.Geometry.InstanceDefinitionGeometry.GetObjectIds(self) -> List[Guid]
Rhino.Geometry.InstanceDefinitionGeometry.GetUserString(self, key: str) -> str
Rhino.Geometry.InstanceDefinitionGeometry.GetUserStrings(self) -> NameValueCollection
Rhino.Geometry.InstanceDefinitionGeometry.SetUserString(self, key: str, value: str) -> bool
Rhino.Geometry.InstanceDefinitionGeometry.__init__(self) -> None
Rhino.Geometry.InstanceReferenceGeometry.__init__(self, info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext) -> None
Rhino.Geometry.InstanceReferenceGeometry.__init__(self, instanceDefinitionId: System.Guid, transform: Rhino.Geometry.Transform) -> None
Rhino.Geometry.Interpolator.InterpolateCatmullRom(self, t: float) -> float
Rhino.Geometry.Interpolator.InterpolateCosine(self, t: float) -> float
Rhino.Geometry.Interpolator.InterpolateCubic(self, t: float) -> float
Rhino.Geometry.Interpolator.InterpolateLinear(self, t: float) -> float
Rhino.Geometry.Interpolator.InterpolateNearestNeighbour(self, t: float) -> float
Rhino.Geometry.Interpolator.__init__(self) -> None
Rhino.Geometry.Interpolator.__init__(self, amount: int, defaultValue: float) -> None
Rhino.Geometry.Interpolator.__init__(self, collection: Iterable[float]) -> None
Rhino.Geometry.Interpolator.__init__(self, initialCapacity: int) -> None
Rhino.Geometry.Interpolator.__init__(self, list: RhinoList[float]) -> None
Rhino.Geometry.Intersect.CurveIntersections.CopyTo(self, array: List[Rhino.Geometry.Intersect.IntersectionEvent], arrayIndex: int) -> None
Rhino.Geometry.Intersect.CurveIntersections.Dispose(self) -> None
Rhino.Geometry.Intersect.CurveIntersections.Dispose(self, disposing: bool) -> None
Rhino.Geometry.Intersect.CurveIntersections.Finalize(self) -> None
Rhino.Geometry.Intersect.CurveIntersections.GetEnumerator(self) -> IEnumerator<IntersectionEvent>
Rhino.Geometry.Intersect.Intersection.ArcArc(arcA: Rhino.Geometry.Arc, arcB: Rhino.Geometry.Arc, intersectionPoint1: Rhino.Geometry.Point3d@, intersectionPoint2: Rhino.Geometry.Point3d@) -> ArcArcIntersection
Rhino.Geometry.Intersect.Intersection.BrepBrep(brepA: Rhino.Geometry.Brep, brepB: Rhino.Geometry.Brep, tolerance: float, intersectionCurves: Rhino.Geometry.Curve[]@, intersectionPoints: Rhino.Geometry.Point3d[]@) -> bool
Rhino.Geometry.Intersect.Intersection.BrepBrep(brepA: Rhino.Geometry.Brep, brepB: Rhino.Geometry.Brep, tolerance: float, joinCurves: bool, intersectionCurves: Rhino.Geometry.Curve[]@, intersectionPoints: Rhino.Geometry.Point3d[]@) -> bool
Rhino.Geometry.Intersect.Intersection.BrepPlane(brep: Rhino.Geometry.Brep, plane: Rhino.Geometry.Plane, tolerance: float, intersectionCurves: Rhino.Geometry.Curve[]@, intersectionPoints: Rhino.Geometry.Point3d[]@) -> bool
Rhino.Geometry.Intersect.Intersection.BrepSurface(brep: Rhino.Geometry.Brep, surface: Rhino.Geometry.Surface, tolerance: float, intersectionCurves: Rhino.Geometry.Curve[]@, intersectionPoints: Rhino.Geometry.Point3d[]@) -> bool
Rhino.Geometry.Intersect.Intersection.BrepSurface(brep: Rhino.Geometry.Brep, surface: Rhino.Geometry.Surface, tolerance: float, joinCurves: bool, intersectionCurves: Rhino.Geometry.Curve[]@, intersectionPoints: Rhino.Geometry.Point3d[]@) -> bool
Rhino.Geometry.Intersect.Intersection.CircleCircle(circleA: Rhino.Geometry.Circle, circleB: Rhino.Geometry.Circle, intersectionPoint1: Rhino.Geometry.Point3d@, intersectionPoint2: Rhino.Geometry.Point3d@) -> CircleCircleIntersection
Rhino.Geometry.Intersect.Intersection.CurveBrep(curve: Rhino.Geometry.Curve, brep: Rhino.Geometry.Brep, tolerance: float, angleTolerance: float, t: System.Double[]@) -> bool
Rhino.Geometry.Intersect.Intersection.CurveBrep(curve: Rhino.Geometry.Curve, brep: Rhino.Geometry.Brep, tolerance: float, overlapCurves: Rhino.Geometry.Curve[]@, intersectionPoints: Rhino.Geometry.Point3d[]@) -> bool
Rhino.Geometry.Intersect.Intersection.CurveBrep(curve: Rhino.Geometry.Curve, brep: Rhino.Geometry.Brep, tolerance: float, overlapCurves: Rhino.Geometry.Curve[]@, intersectionPoints: Rhino.Geometry.Point3d[]@, curveParameters: System.Double[]@) -> bool
Rhino.Geometry.Intersect.Intersection.CurveBrepFace(curve: Rhino.Geometry.Curve, face: Rhino.Geometry.BrepFace, tolerance: float, overlapCurves: Rhino.Geometry.Curve[]@, intersectionPoints: Rhino.Geometry.Point3d[]@) -> bool
Rhino.Geometry.Intersect.Intersection.CurveCurve(curveA: Rhino.Geometry.Curve, curveB: Rhino.Geometry.Curve, tolerance: float, overlapTolerance: float) -> CurveIntersections
Rhino.Geometry.Intersect.Intersection.CurveCurveValidate(curveA: Rhino.Geometry.Curve, curveB: Rhino.Geometry.Curve, tolerance: float, overlapTolerance: float, invalidIndices: System.Int32[]@, textLog: Rhino.FileIO.TextLog@) -> CurveIntersections
Rhino.Geometry.Intersect.Intersection.CurveLine(curve: Rhino.Geometry.Curve, line: Rhino.Geometry.Line, tolerance: float, overlapTolerance: float) -> CurveIntersections
Rhino.Geometry.Intersect.Intersection.CurvePlane(curve: Rhino.Geometry.Curve, plane: Rhino.Geometry.Plane, tolerance: float) -> CurveIntersections
Rhino.Geometry.Intersect.Intersection.CurveSelf(curve: Rhino.Geometry.Curve, tolerance: float) -> CurveIntersections
Rhino.Geometry.Intersect.Intersection.CurveSurface(curve: Rhino.Geometry.Curve, curveDomain: Rhino.Geometry.Interval, surface: Rhino.Geometry.Surface, tolerance: float, overlapTolerance: float) -> CurveIntersections
Rhino.Geometry.Intersect.Intersection.CurveSurface(curve: Rhino.Geometry.Curve, surface: Rhino.Geometry.Surface, tolerance: float, overlapTolerance: float) -> CurveIntersections
Rhino.Geometry.Intersect.Intersection.CurveSurfaceValidate(curve: Rhino.Geometry.Curve, curveDomain: Rhino.Geometry.Interval, surface: Rhino.Geometry.Surface, tolerance: float, overlapTolerance: float, invalidIndices: System.Int32[]@, textLog: Rhino.FileIO.TextLog@) -> CurveIntersections
Rhino.Geometry.Intersect.Intersection.CurveSurfaceValidate(curve: Rhino.Geometry.Curve, surface: Rhino.Geometry.Surface, tolerance: float, overlapTolerance: float, invalidIndices: System.Int32[]@, textLog: Rhino.FileIO.TextLog@) -> CurveIntersections
Rhino.Geometry.Intersect.Intersection.LineBox(line: Rhino.Geometry.Line, box: Rhino.Geometry.BoundingBox, tolerance: float, lineParameters: Rhino.Geometry.Interval@) -> bool
Rhino.Geometry.Intersect.Intersection.LineBox(line: Rhino.Geometry.Line, box: Rhino.Geometry.Box, tolerance: float, lineParameters: Rhino.Geometry.Interval@) -> bool
Rhino.Geometry.Intersect.Intersection.LineCircle(line: Rhino.Geometry.Line, circle: Rhino.Geometry.Circle, t1: System.Double@, point1: Rhino.Geometry.Point3d@, t2: System.Double@, point2: Rhino.Geometry.Point3d@) -> LineCircleIntersection
Rhino.Geometry.Intersect.Intersection.LineCylinder(line: Rhino.Geometry.Line, cylinder: Rhino.Geometry.Cylinder, intersectionPoint1: Rhino.Geometry.Point3d@, intersectionPoint2: Rhino.Geometry.Point3d@) -> LineCylinderIntersection
Rhino.Geometry.Intersect.Intersection.LineLine(lineA: Rhino.Geometry.Line, lineB: Rhino.Geometry.Line, a: System.Double@, b: System.Double@) -> bool
Rhino.Geometry.Intersect.Intersection.LineLine(lineA: Rhino.Geometry.Line, lineB: Rhino.Geometry.Line, a: System.Double@, b: System.Double@, tolerance: float, finiteSegments: bool) -> bool
Rhino.Geometry.Intersect.Intersection.LinePlane(line: Rhino.Geometry.Line, plane: Rhino.Geometry.Plane, lineParameter: System.Double@) -> bool
Rhino.Geometry.Intersect.Intersection.LineSphere(line: Rhino.Geometry.Line, sphere: Rhino.Geometry.Sphere, intersectionPoint1: Rhino.Geometry.Point3d@, intersectionPoint2: Rhino.Geometry.Point3d@) -> LineSphereIntersection
Rhino.Geometry.Intersect.Intersection.MeshLine(mesh: Rhino.Geometry.Mesh, line: Rhino.Geometry.Line) -> List[Point3d]
Rhino.Geometry.Intersect.Intersection.MeshLine(mesh: Rhino.Geometry.Mesh, line: Rhino.Geometry.Line, faceIds: System.Int32[]@) -> List[Point3d]
Rhino.Geometry.Intersect.Intersection.MeshLineSorted(mesh: Rhino.Geometry.Mesh, line: Rhino.Geometry.Line, faceIds: System.Int32[]@) -> List[Point3d]
Rhino.Geometry.Intersect.Intersection.MeshMesh(meshes: Iterable[Rhino.Geometry.Mesh], tolerance: float, intersections: Rhino.Geometry.Polyline[]@, overlapsPolylines: bool, overlapsPolylinesResult: Rhino.Geometry.Polyline[]@, overlapsMesh: bool, overlapsMeshResult: Rhino.Geometry.Mesh@, textLog: Rhino.FileIO.TextLog, cancel: System.Threading.CancellationToken, progress: IProgress[float]) -> bool
Rhino.Geometry.Intersect.Intersection.MeshMeshAccurate(meshA: Rhino.Geometry.Mesh, meshB: Rhino.Geometry.Mesh, tolerance: float) -> List[Polyline]
Rhino.Geometry.Intersect.Intersection.MeshMeshFast(meshA: Rhino.Geometry.Mesh, meshB: Rhino.Geometry.Mesh) -> List[Line]
Rhino.Geometry.Intersect.Intersection.MeshMeshPredicate(meshes: Iterable[Rhino.Geometry.Mesh], tolerance: float, pairs: System.Int32[]@, textLog: Rhino.FileIO.TextLog) -> bool
Rhino.Geometry.Intersect.Intersection.MeshPlane(mesh: Rhino.Geometry.Mesh, cache: Rhino.Geometry.Intersect.MeshIntersectionCache, plane: Rhino.Geometry.Plane, tolerance: float) -> List[Polyline]
Rhino.Geometry.Intersect.Intersection.MeshPlane(mesh: Rhino.Geometry.Mesh, cache: Rhino.Geometry.Intersect.MeshIntersectionCache, planes: Iterable[Rhino.Geometry.Plane], tolerance: float) -> List[Polyline]
Rhino.Geometry.Intersect.Intersection.MeshPlane(mesh: Rhino.Geometry.Mesh, plane: Rhino.Geometry.Plane) -> List[Polyline]
Rhino.Geometry.Intersect.Intersection.MeshPlane(mesh: Rhino.Geometry.Mesh, planes: Iterable[Rhino.Geometry.Plane]) -> List[Polyline]
Rhino.Geometry.Intersect.Intersection.MeshPolyline(mesh: Rhino.Geometry.Mesh, curve: Rhino.Geometry.PolylineCurve, faceIds: System.Int32[]@) -> List[Point3d]
Rhino.Geometry.Intersect.Intersection.MeshPolylineSorted(mesh: Rhino.Geometry.Mesh, curve: Rhino.Geometry.PolylineCurve, faceIds: System.Int32[]@) -> List[Point3d]
Rhino.Geometry.Intersect.Intersection.MeshRay(mesh: Rhino.Geometry.Mesh, ray: Rhino.Geometry.Ray3d) -> float
Rhino.Geometry.Intersect.Intersection.MeshRay(mesh: Rhino.Geometry.Mesh, ray: Rhino.Geometry.Ray3d, meshFaceIndices: System.Int32[]@) -> float
Rhino.Geometry.Intersect.Intersection.PlaneBoundingBox(plane: Rhino.Geometry.Plane, boundingBox: Rhino.Geometry.BoundingBox, polyline: Rhino.Geometry.Polyline@) -> bool
Rhino.Geometry.Intersect.Intersection.PlaneCircle(plane: Rhino.Geometry.Plane, circle: Rhino.Geometry.Circle, firstCircleParameter: System.Double@, secondCircleParameter: System.Double@) -> PlaneCircleIntersection
Rhino.Geometry.Intersect.Intersection.PlanePlane(planeA: Rhino.Geometry.Plane, planeB: Rhino.Geometry.Plane, intersectionLine: Rhino.Geometry.Line@) -> bool
Rhino.Geometry.Intersect.Intersection.PlanePlanePlane(planeA: Rhino.Geometry.Plane, planeB: Rhino.Geometry.Plane, planeC: Rhino.Geometry.Plane, intersectionPoint: Rhino.Geometry.Point3d@) -> bool
Rhino.Geometry.Intersect.Intersection.PlaneSphere(plane: Rhino.Geometry.Plane, sphere: Rhino.Geometry.Sphere, intersectionCircle: Rhino.Geometry.Circle@) -> PlaneSphereIntersection
Rhino.Geometry.Intersect.Intersection.ProjectPointsToBreps(breps: Iterable[Rhino.Geometry.Brep], points: Iterable[Rhino.Geometry.Point3d], direction: Rhino.Geometry.Vector3d, tolerance: float) -> List[Point3d]
Rhino.Geometry.Intersect.Intersection.ProjectPointsToBrepsEx(breps: Iterable[Rhino.Geometry.Brep], points: Iterable[Rhino.Geometry.Point3d], direction: Rhino.Geometry.Vector3d, tolerance: float, indices: System.Int32[]@) -> List[Point3d]
Rhino.Geometry.Intersect.Intersection.ProjectPointsToMeshes(meshes: Iterable[Rhino.Geometry.Mesh], points: Iterable[Rhino.Geometry.Point3d], direction: Rhino.Geometry.Vector3d, tolerance: float) -> List[Point3d]
Rhino.Geometry.Intersect.Intersection.ProjectPointsToMeshesEx(meshes: Iterable[Rhino.Geometry.Mesh], points: Iterable[Rhino.Geometry.Point3d], direction: Rhino.Geometry.Vector3d, tolerance: float, indices: System.Int32[]@) -> List[Point3d]
Rhino.Geometry.Intersect.Intersection.RayShoot(geometry: Iterable[Rhino.Geometry.GeometryBase], ray: Rhino.Geometry.Ray3d, maxReflections: int) -> List[RayShootEvent]
Rhino.Geometry.Intersect.Intersection.RayShoot(ray: Rhino.Geometry.Ray3d, geometry: Iterable[Rhino.Geometry.GeometryBase], maxReflections: int) -> List[Point3d]
Rhino.Geometry.Intersect.Intersection.SphereSphere(sphereA: Rhino.Geometry.Sphere, sphereB: Rhino.Geometry.Sphere, intersectionCircle: Rhino.Geometry.Circle@) -> SphereSphereIntersection
Rhino.Geometry.Intersect.Intersection.SurfaceSurface(surfaceA: Rhino.Geometry.Surface, surfaceB: Rhino.Geometry.Surface, tolerance: float, intersectionCurves: Rhino.Geometry.Curve[]@, intersectionPoints: Rhino.Geometry.Point3d[]@) -> bool
Rhino.Geometry.Intersect.IntersectionEvent.CompareEquivalent(eventA: Rhino.Geometry.Intersect.IntersectionEvent, eventB: Rhino.Geometry.Intersect.IntersectionEvent, relativePointTolerance: float) -> bool
Rhino.Geometry.Intersect.IntersectionEvent.CompareEquivalent(eventA: Rhino.Geometry.Intersect.IntersectionEvent, eventB: Rhino.Geometry.Intersect.IntersectionEvent, relativePointTolerance: float, log: Rhino.FileIO.TextLog) -> bool
Rhino.Geometry.Intersect.IntersectionEvent.SurfaceOverlapParameter(self, uDomain: Rhino.Geometry.Interval@, vDomain: Rhino.Geometry.Interval@) -> None
Rhino.Geometry.Intersect.IntersectionEvent.SurfacePointParameter(self, u: System.Double@, v: System.Double@) -> None
Rhino.Geometry.Intersect.IntersectionEvent.__init__(self) -> None
Rhino.Geometry.Intersect.MeshClash.FindDetail(objA: Rhino.DocObjects.RhinoObject, objB: Rhino.DocObjects.RhinoObject, distance: float) -> List[Mesh]
Rhino.Geometry.Intersect.MeshClash.FindDetail(objA: Rhino.DocObjects.RhinoObject, objB: Rhino.DocObjects.RhinoObject, distance: float, meshType: Rhino.Geometry.MeshType, meshingParameters: Rhino.Geometry.MeshingParameters) -> List[Mesh]
Rhino.Geometry.Intersect.MeshClash.Search(meshA: Rhino.Geometry.Mesh, meshB: Rhino.Geometry.Mesh, distance: float, maxEventCount: int) -> List[Rhino.Geometry.Intersect.MeshClash]
Rhino.Geometry.Intersect.MeshClash.Search(meshA: Rhino.Geometry.Mesh, setB: Iterable[Rhino.Geometry.Mesh], distance: float, maxEventCount: int) -> List[Rhino.Geometry.Intersect.MeshClash]
Rhino.Geometry.Intersect.MeshClash.Search(setA: Iterable[Rhino.DocObjects.RhinoObject], setB: Iterable[Rhino.DocObjects.RhinoObject], distance: float) -> List[MeshInterference]
Rhino.Geometry.Intersect.MeshClash.Search(setA: Iterable[Rhino.DocObjects.RhinoObject], setB: Iterable[Rhino.DocObjects.RhinoObject], distance: float, meshType: Rhino.Geometry.MeshType, meshingParameters: Rhino.Geometry.MeshingParameters) -> List[MeshInterference]
Rhino.Geometry.Intersect.MeshClash.Search(setA: Iterable[Rhino.Geometry.Mesh], setB: Iterable[Rhino.Geometry.Mesh], distance: float, maxEventCount: int) -> List[Rhino.Geometry.Intersect.MeshClash]
Rhino.Geometry.Intersect.MeshIntersectionCache.Dispose(self) -> None
Rhino.Geometry.Intersect.MeshIntersectionCache.Dispose(self, disposing: bool) -> None
Rhino.Geometry.Intersect.MeshIntersectionCache.Finalize(self) -> None
Rhino.Geometry.Intersect.MeshIntersectionCache.__init__(self) -> None
Rhino.Geometry.Interval.!=(a: Rhino.Geometry.Interval, b: Rhino.Geometry.Interval) -> operator
Rhino.Geometry.Interval.+(interval: Rhino.Geometry.Interval, number: float) -> operator
Rhino.Geometry.Interval.+(number: float, interval: Rhino.Geometry.Interval) -> operator
Rhino.Geometry.Interval.-(interval: Rhino.Geometry.Interval, number: float) -> operator
Rhino.Geometry.Interval.-(number: float, interval: Rhino.Geometry.Interval) -> operator
Rhino.Geometry.Interval.<(a: Rhino.Geometry.Interval, b: Rhino.Geometry.Interval) -> operator
Rhino.Geometry.Interval.<=(a: Rhino.Geometry.Interval, b: Rhino.Geometry.Interval) -> operator
Rhino.Geometry.Interval.==(a: Rhino.Geometry.Interval, b: Rhino.Geometry.Interval) -> operator
Rhino.Geometry.Interval.>(a: Rhino.Geometry.Interval, b: Rhino.Geometry.Interval) -> operator
Rhino.Geometry.Interval.>=(a: Rhino.Geometry.Interval, b: Rhino.Geometry.Interval) -> operator
Rhino.Geometry.Interval.CompareTo(self, other: Rhino.Geometry.Interval) -> int
Rhino.Geometry.Interval.EpsilonEquals(self, other: Rhino.Geometry.Interval, epsilon: float) -> bool
Rhino.Geometry.Interval.Equals(self, obj: Any) -> bool
Rhino.Geometry.Interval.Equals(self, other: Rhino.Geometry.Interval) -> bool
Rhino.Geometry.Interval.FromIntersection(a: Rhino.Geometry.Interval, b: Rhino.Geometry.Interval) -> Rhino.Geometry.Interval
Rhino.Geometry.Interval.FromUnion(a: Rhino.Geometry.Interval, b: Rhino.Geometry.Interval) -> Rhino.Geometry.Interval
Rhino.Geometry.Interval.GetHashCode(self) -> int
Rhino.Geometry.Interval.Grow(self, value: float) -> None
Rhino.Geometry.Interval.IncludesInterval(self, interval: Rhino.Geometry.Interval) -> bool
Rhino.Geometry.Interval.IncludesInterval(self, interval: Rhino.Geometry.Interval, strict: bool) -> bool
Rhino.Geometry.Interval.IncludesParameter(self, t: float) -> bool
Rhino.Geometry.Interval.IncludesParameter(self, t: float, strict: bool) -> bool
Rhino.Geometry.Interval.MakeIncreasing(self) -> None
Rhino.Geometry.Interval.NormalizedIntervalAt(self, intervalParameter: Rhino.Geometry.Interval) -> Rhino.Geometry.Interval
Rhino.Geometry.Interval.NormalizedParameterAt(self, intervalParameter: float) -> float
Rhino.Geometry.Interval.ParameterAt(self, normalizedParameter: float) -> float
Rhino.Geometry.Interval.ParameterIntervalAt(self, normalizedInterval: Rhino.Geometry.Interval) -> Rhino.Geometry.Interval
Rhino.Geometry.Interval.Reverse(self) -> None
Rhino.Geometry.Interval.Swap(self) -> None
Rhino.Geometry.Interval.ToString(self) -> str
Rhino.Geometry.Interval.__init__(self, other: Rhino.Geometry.Interval) -> None
Rhino.Geometry.Interval.__init__(self, t0: float, t1: float) -> None
Rhino.Geometry.InvalidDimensionStyleIdException.__init__(self, msg: str) -> None
Rhino.Geometry.Leader.Create(text: str, plane: Rhino.Geometry.Plane, dimstyle: Rhino.DocObjects.DimensionStyle, points: List[Rhino.Geometry.Point3d]) -> Rhino.Geometry.Leader
Rhino.Geometry.Leader.CreateWithRichText(richText: str, plane: Rhino.Geometry.Plane, dimstyle: Rhino.DocObjects.DimensionStyle, points: List[Rhino.Geometry.Point3d]) -> Rhino.Geometry.Leader
Rhino.Geometry.Leader.Explode(self) -> List[GeometryBase]
Rhino.Geometry.Leader.__init__(self) -> None
Rhino.Geometry.Leader.__init__(self, info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext) -> None
Rhino.Geometry.LengthMassProperties.CentroidCoordinatesPrincipalMoments(self, x: System.Double@, xaxis: Rhino.Geometry.Vector3d@, y: System.Double@, yaxis: Rhino.Geometry.Vector3d@, z: System.Double@, zaxis: Rhino.Geometry.Vector3d@) -> bool
Rhino.Geometry.LengthMassProperties.CentroidCoordinatesPrincipalMomentsOfInertia(self, x: System.Double@, xaxis: Rhino.Geometry.Vector3d@, y: System.Double@, yaxis: Rhino.Geometry.Vector3d@, z: System.Double@, zaxis: Rhino.Geometry.Vector3d@) -> bool
Rhino.Geometry.LengthMassProperties.Compute(curve: Rhino.Geometry.Curve) -> Rhino.Geometry.LengthMassProperties
Rhino.Geometry.LengthMassProperties.Compute(curve: Rhino.Geometry.Curve, length: bool, firstMoments: bool, secondMoments: bool, productMoments: bool) -> Rhino.Geometry.LengthMassProperties
Rhino.Geometry.LengthMassProperties.Compute(curves: Iterable[Rhino.Geometry.Curve]) -> Rhino.Geometry.LengthMassProperties
Rhino.Geometry.LengthMassProperties.Compute(curves: Iterable[Rhino.Geometry.Curve], length: bool, firstMoments: bool, secondMoments: bool, productMoments: bool) -> Rhino.Geometry.LengthMassProperties
Rhino.Geometry.LengthMassProperties.Dispose(self) -> None
Rhino.Geometry.LengthMassProperties.Dispose(self, disposing: bool) -> None
Rhino.Geometry.LengthMassProperties.Finalize(self) -> None
Rhino.Geometry.LengthMassProperties.WorldCoordinatesPrincipalMoments(self, x: System.Double@, xaxis: Rhino.Geometry.Vector3d@, y: System.Double@, yaxis: Rhino.Geometry.Vector3d@, z: System.Double@, zaxis: Rhino.Geometry.Vector3d@) -> bool
Rhino.Geometry.LengthMassProperties.WorldCoordinatesPrincipalMomentsOfInertia(self, x: System.Double@, xaxis: Rhino.Geometry.Vector3d@, y: System.Double@, yaxis: Rhino.Geometry.Vector3d@, z: System.Double@, zaxis: Rhino.Geometry.Vector3d@) -> bool
Rhino.Geometry.Light.CreateSunLight(northAngleDegrees: float, azimuthDegrees: float, altitudeDegrees: float) -> Rhino.Geometry.Light
Rhino.Geometry.Light.CreateSunLight(northAngleDegrees: float, when: System.DateTime, latitudeDegrees: float, longitudeDegrees: float) -> Rhino.Geometry.Light
Rhino.Geometry.Light.CreateSunLight(sun: Rhino.Render.Sun) -> Rhino.Geometry.Light
Rhino.Geometry.Light.GetAttenuation(self, d: float) -> float
Rhino.Geometry.Light.GetSpotLightRadii(self, innerRadius: System.Double@, outerRadius: System.Double@) -> bool
Rhino.Geometry.Light.SetAttenuation(self, a0: float, a1: float, a2: float) -> None
Rhino.Geometry.Light.__init__(self) -> None
Rhino.Geometry.Light.__init__(self, info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext) -> None
Rhino.Geometry.Line.!=(a: Rhino.Geometry.Line, b: Rhino.Geometry.Line) -> operator
Rhino.Geometry.Line.==(a: Rhino.Geometry.Line, b: Rhino.Geometry.Line) -> operator
Rhino.Geometry.Line.ClosestParameter(self, testPoint: Rhino.Geometry.Point3d) -> float
Rhino.Geometry.Line.ClosestPoint(self, testPoint: Rhino.Geometry.Point3d, limitToFiniteSegment: bool) -> Point3d
Rhino.Geometry.Line.DistanceTo(self, testPoint: Rhino.Geometry.Point3d, limitToFiniteSegment: bool) -> float
Rhino.Geometry.Line.EpsilonEquals(self, other: Rhino.Geometry.Line, epsilon: float) -> bool
Rhino.Geometry.Line.Equals(self, obj: Any) -> bool
Rhino.Geometry.Line.Equals(self, other: Rhino.Geometry.Line) -> bool
Rhino.Geometry.Line.Extend(self, startLength: float, endLength: float) -> bool
Rhino.Geometry.Line.ExtendThroughBox(self, box: Rhino.Geometry.BoundingBox) -> bool
Rhino.Geometry.Line.ExtendThroughBox(self, box: Rhino.Geometry.BoundingBox, additionalLength: float) -> bool
Rhino.Geometry.Line.ExtendThroughBox(self, box: Rhino.Geometry.Box) -> bool
Rhino.Geometry.Line.ExtendThroughBox(self, box: Rhino.Geometry.Box, additionalLength: float) -> bool
Rhino.Geometry.Line.Flip(self) -> None
Rhino.Geometry.Line.GetHashCode(self) -> int
Rhino.Geometry.Line.MaximumDistanceTo(self, testLine: Rhino.Geometry.Line) -> float
Rhino.Geometry.Line.MaximumDistanceTo(self, testPoint: Rhino.Geometry.Point3d) -> float
Rhino.Geometry.Line.MinimumDistanceTo(self, testLine: Rhino.Geometry.Line) -> float
Rhino.Geometry.Line.MinimumDistanceTo(self, testPoint: Rhino.Geometry.Point3d) -> float
Rhino.Geometry.Line.PointAt(self, t: float) -> Point3d
Rhino.Geometry.Line.PointAtLength(self, distance: float) -> Point3d
Rhino.Geometry.Line.ToNurbsCurve(self) -> NurbsCurve
Rhino.Geometry.Line.ToString(self) -> str
Rhino.Geometry.Line.ToString(self, format: str, formatProvider: System.IFormatProvider) -> str
Rhino.Geometry.Line.Transform(self, xform: Rhino.Geometry.Transform) -> bool
Rhino.Geometry.Line.TryCreateBetweenCurves(curve0: Rhino.Geometry.Curve, curve1: Rhino.Geometry.Curve, t0: System.Double@, t1: System.Double@, perpendicular0: bool, perpendicular1: bool, line: Rhino.Geometry.Line@) -> bool
Rhino.Geometry.Line.TryFitLineToPoints(points: Iterable[Rhino.Geometry.Point3d], fitLine: Rhino.Geometry.Line@) -> bool
Rhino.Geometry.Line.TryGetPlane(self, plane: Rhino.Geometry.Plane@) -> bool
Rhino.Geometry.Line.__init__(self, from: Rhino.Geometry.Point3d, to: Rhino.Geometry.Point3d) -> None
Rhino.Geometry.Line.__init__(self, start: Rhino.Geometry.Point3d, direction: Rhino.Geometry.Vector3d, length: float) -> None
Rhino.Geometry.Line.__init__(self, start: Rhino.Geometry.Point3d, span: Rhino.Geometry.Vector3d) -> None
Rhino.Geometry.Line.__init__(self, x0: float, y0: float, z0: float, x1: float, y1: float, z1: float) -> None
Rhino.Geometry.LineCurve.__init__(self) -> None
Rhino.Geometry.LineCurve.__init__(self, from: Rhino.Geometry.Point2d, to: Rhino.Geometry.Point2d) -> None
Rhino.Geometry.LineCurve.__init__(self, from: Rhino.Geometry.Point3d, to: Rhino.Geometry.Point3d) -> None
Rhino.Geometry.LineCurve.__init__(self, info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext) -> None
Rhino.Geometry.LineCurve.__init__(self, line: Rhino.Geometry.Line) -> None
Rhino.Geometry.LineCurve.__init__(self, line: Rhino.Geometry.Line, t0: float, t1: float) -> None
Rhino.Geometry.LineCurve.__init__(self, other: Rhino.Geometry.LineCurve) -> None
Rhino.Geometry.LinearDimension.Create(dimtype: Rhino.Geometry.AnnotationType, dimStyle: Rhino.DocObjects.DimensionStyle, plane: Rhino.Geometry.Plane, horizontal: Rhino.Geometry.Vector3d, defpoint1: Rhino.Geometry.Point3d, defpoint2: Rhino.Geometry.Point3d, dimlinepoint: Rhino.Geometry.Point3d, rotationInPlane: float) -> Rhino.Geometry.LinearDimension
Rhino.Geometry.LinearDimension.FromPoints(extensionLine1End: Rhino.Geometry.Point3d, extensionLine2End: Rhino.Geometry.Point3d, pointOnDimensionLine: Rhino.Geometry.Point3d) -> Rhino.Geometry.LinearDimension
Rhino.Geometry.LinearDimension.Get3dPoints(self, extensionLine1End: Rhino.Geometry.Point3d@, extensionLine2End: Rhino.Geometry.Point3d@, arrowhead1End: Rhino.Geometry.Point3d@, arrowhead2End: Rhino.Geometry.Point3d@, dimlinepoint: Rhino.Geometry.Point3d@, textpoint: Rhino.Geometry.Point3d@) -> bool
Rhino.Geometry.LinearDimension.GetDisplayLines(self, style: Rhino.DocObjects.DimensionStyle, scale: float, lines: System.Collections.Generic.IEnumerable{Rhino.Geometry.Line}@) -> bool
Rhino.Geometry.LinearDimension.GetDistanceDisplayText(self, unitsystem: Rhino.UnitSystem, style: Rhino.DocObjects.DimensionStyle) -> str
Rhino.Geometry.LinearDimension.GetTextRectangle(self, corners: Rhino.Geometry.Point3d[]@) -> bool
Rhino.Geometry.LinearDimension.SetLocations(self, extensionLine1End: Rhino.Geometry.Point2d, extensionLine2End: Rhino.Geometry.Point2d, pointOnDimensionLine: Rhino.Geometry.Point2d) -> None
Rhino.Geometry.LinearDimension.__init__(self) -> None
Rhino.Geometry.LinearDimension.__init__(self, dimensionPlane: Rhino.Geometry.Plane, extensionLine1End: Rhino.Geometry.Point2d, extensionLine2End: Rhino.Geometry.Point2d, pointOnDimensionLine: Rhino.Geometry.Point2d) -> None
Rhino.Geometry.LinearDimension.__init__(self, info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext) -> None
Rhino.Geometry.MatchSrfSettings.EnableRefinement(self, enabled: bool, positionalTolerance: float, angleToleranceRadians: float, curvatureTolerance: float) -> None
Rhino.Geometry.MatchSrfSettings.__init__(self, match: Rhino.Geometry.Continuity, otherEnd: Rhino.Geometry.Continuity) -> None
Rhino.Geometry.Matrix.*(a: Rhino.Geometry.Matrix, b: Rhino.Geometry.Matrix) -> operator
Rhino.Geometry.Matrix.+(a: Rhino.Geometry.Matrix, b: Rhino.Geometry.Matrix) -> operator
Rhino.Geometry.Matrix.BackSolve(self, zeroTolerance: float, b: List[float]) -> List[float]
Rhino.Geometry.Matrix.BackSolvePoints(self, zeroTolerance: float, b: List[Rhino.Geometry.Point3d]) -> List[Point3d]
Rhino.Geometry.Matrix.Dispose(self) -> None
Rhino.Geometry.Matrix.Dispose(self, disposing: bool) -> None
Rhino.Geometry.Matrix.Duplicate(self) -> Rhino.Geometry.Matrix
Rhino.Geometry.Matrix.Finalize(self) -> None
Rhino.Geometry.Matrix.GetHashCode(self) -> int
Rhino.Geometry.Matrix.Invert(self, zeroTolerance: float) -> bool
Rhino.Geometry.Matrix.RowReduce(self, zeroTolerance: float, b: List[Rhino.Geometry.Point3d], pivot: System.Double@) -> int
Rhino.Geometry.Matrix.RowReduce(self, zeroTolerance: float, b: List[float], pivot: System.Double@) -> int
Rhino.Geometry.Matrix.RowReduce(self, zeroTolerance: float, determinant: System.Double@, pivot: System.Double@) -> int
Rhino.Geometry.Matrix.Scale(self, s: float) -> None
Rhino.Geometry.Matrix.SetDiagonal(self, d: float) -> None
Rhino.Geometry.Matrix.SwapColumns(self, columnA: int, columnB: int) -> bool
Rhino.Geometry.Matrix.SwapRows(self, rowA: int, rowB: int) -> bool
Rhino.Geometry.Matrix.Transpose(self) -> bool
Rhino.Geometry.Matrix.Zero(self) -> None
Rhino.Geometry.Matrix.__init__(self, rowCount: int, columnCount: int) -> None
Rhino.Geometry.Matrix.__init__(self, xform: Rhino.Geometry.Transform) -> None
Rhino.Geometry.Mesh.Append(self, meshes: Iterable[Rhino.Geometry.Mesh]) -> None
Rhino.Geometry.Mesh.Append(self, other: Rhino.Geometry.Mesh) -> None
Rhino.Geometry.Mesh.Check(self, textLog: Rhino.FileIO.TextLog, parameters: Rhino.Geometry.MeshCheckParameters@) -> bool
Rhino.Geometry.Mesh.ClearSurfaceData(self) -> None
Rhino.Geometry.Mesh.ClearTextureData(self) -> None
Rhino.Geometry.Mesh.ClosestMeshPoint(self, testPoint: Rhino.Geometry.Point3d, maximumDistance: float) -> MeshPoint
Rhino.Geometry.Mesh.ClosestPoint(self, testPoint: Rhino.Geometry.Point3d) -> Point3d
Rhino.Geometry.Mesh.ClosestPoint(self, testPoint: Rhino.Geometry.Point3d, pointOnMesh: Rhino.Geometry.Point3d@, maximumDistance: float) -> int
Rhino.Geometry.Mesh.ClosestPoint(self, testPoint: Rhino.Geometry.Point3d, pointOnMesh: Rhino.Geometry.Point3d@, normalAtPoint: Rhino.Geometry.Vector3d@, maximumDistance: float) -> int
Rhino.Geometry.Mesh.CollapseFacesByArea(self, lessThanArea: float, greaterThanArea: float) -> int
Rhino.Geometry.Mesh.CollapseFacesByByAspectRatio(self, aspectRatio: float) -> int
Rhino.Geometry.Mesh.CollapseFacesByEdgeLength(self, bGreaterThan: bool, edgeLength: float) -> int
Rhino.Geometry.Mesh.ColorAt(self, faceIndex: int, t0: float, t1: float, t2: float, t3: float) -> Color
Rhino.Geometry.Mesh.ColorAt(self, meshPoint: Rhino.Geometry.MeshPoint) -> Color
Rhino.Geometry.Mesh.Compact(self) -> bool
Rhino.Geometry.Mesh.ComputeCurvatureApproximation(self, type: int, perVertexCurvatures: System.Double[]@) -> bool
Rhino.Geometry.Mesh.ComputeThickness(meshes: Iterable[Rhino.Geometry.Mesh], maximumThickness: float) -> List[MeshThicknessMeasurement]
Rhino.Geometry.Mesh.ComputeThickness(meshes: Iterable[Rhino.Geometry.Mesh], maximumThickness: float, cancelToken: System.Threading.CancellationToken) -> List[MeshThicknessMeasurement]
Rhino.Geometry.Mesh.ComputeThickness(meshes: Iterable[Rhino.Geometry.Mesh], maximumThickness: float, sharpAngle: float, cancelToken: System.Threading.CancellationToken) -> List[MeshThicknessMeasurement]
Rhino.Geometry.Mesh.CopyFrom(self, other: Rhino.Geometry.Mesh) -> None
Rhino.Geometry.Mesh.CreateBooleanDifference(firstSet: Iterable[Rhino.Geometry.Mesh], secondSet: Iterable[Rhino.Geometry.Mesh]) -> List[Rhino.Geometry.Mesh]
Rhino.Geometry.Mesh.CreateBooleanDifference(firstSet: Iterable[Rhino.Geometry.Mesh], secondSet: Iterable[Rhino.Geometry.Mesh], options: Rhino.Geometry.MeshBooleanOptions, result: Rhino.Commands.Result@) -> List[Rhino.Geometry.Mesh]
Rhino.Geometry.Mesh.CreateBooleanIntersection(firstSet: Iterable[Rhino.Geometry.Mesh], secondSet: Iterable[Rhino.Geometry.Mesh]) -> List[Rhino.Geometry.Mesh]
Rhino.Geometry.Mesh.CreateBooleanIntersection(firstSet: Iterable[Rhino.Geometry.Mesh], secondSet: Iterable[Rhino.Geometry.Mesh], options: Rhino.Geometry.MeshBooleanOptions, result: Rhino.Commands.Result@) -> List[Rhino.Geometry.Mesh]
Rhino.Geometry.Mesh.CreateBooleanSplit(meshesToSplit: Iterable[Rhino.Geometry.Mesh], meshSplitters: Iterable[Rhino.Geometry.Mesh]) -> List[Rhino.Geometry.Mesh]
Rhino.Geometry.Mesh.CreateBooleanSplit(meshesToSplit: Iterable[Rhino.Geometry.Mesh], meshSplitters: Iterable[Rhino.Geometry.Mesh], options: Rhino.Geometry.MeshBooleanOptions, result: Rhino.Commands.Result@) -> List[Rhino.Geometry.Mesh]
Rhino.Geometry.Mesh.CreateBooleanUnion(meshes: Iterable[Rhino.Geometry.Mesh]) -> List[Rhino.Geometry.Mesh]
Rhino.Geometry.Mesh.CreateBooleanUnion(meshes: Iterable[Rhino.Geometry.Mesh], options: Rhino.Geometry.MeshBooleanOptions, commandResult: Rhino.Commands.Result@) -> List[Rhino.Geometry.Mesh]
Rhino.Geometry.Mesh.CreateBooleanUnion(meshes: Iterable[Rhino.Geometry.Mesh], tolerance: float) -> List[Rhino.Geometry.Mesh]
Rhino.Geometry.Mesh.CreateContourCurves(meshToContour: Rhino.Geometry.Mesh, contourStart: Rhino.Geometry.Point3d, contourEnd: Rhino.Geometry.Point3d, interval: float, tolerance: float) -> List[Curve]
Rhino.Geometry.Mesh.CreateContourCurves(meshToContour: Rhino.Geometry.Mesh, sectionPlane: Rhino.Geometry.Plane, tolerance: float) -> List[Curve]
Rhino.Geometry.Mesh.CreateConvexHull3D(points: Iterable[Rhino.Geometry.Point3d], hullFacets: System.Int32[][]@, tolerance: float, angleTolerance: float) -> Rhino.Geometry.Mesh
Rhino.Geometry.Mesh.CreateExtrusion(profile: Rhino.Geometry.Curve, direction: Rhino.Geometry.Vector3d) -> Rhino.Geometry.Mesh
Rhino.Geometry.Mesh.CreateExtrusion(profile: Rhino.Geometry.Curve, direction: Rhino.Geometry.Vector3d, parameters: Rhino.Geometry.MeshingParameters) -> Rhino.Geometry.Mesh
Rhino.Geometry.Mesh.CreateFromBox(box: Rhino.Geometry.BoundingBox, xCount: int, yCount: int, zCount: int) -> Rhino.Geometry.Mesh
Rhino.Geometry.Mesh.CreateFromBox(box: Rhino.Geometry.Box, xCount: int, yCount: int, zCount: int) -> Rhino.Geometry.Mesh
Rhino.Geometry.Mesh.CreateFromBox(corners: Iterable[Rhino.Geometry.Point3d], xCount: int, yCount: int, zCount: int) -> Rhino.Geometry.Mesh
Rhino.Geometry.Mesh.CreateFromBrep(brep: Rhino.Geometry.Brep, meshingParameters: Rhino.Geometry.MeshingParameters) -> List[Rhino.Geometry.Mesh]
Rhino.Geometry.Mesh.CreateFromClosedPolyline(polyline: Rhino.Geometry.Polyline) -> Rhino.Geometry.Mesh
Rhino.Geometry.Mesh.CreateFromCone(cone: Rhino.Geometry.Cone, vertical: int, around: int) -> Rhino.Geometry.Mesh
Rhino.Geometry.Mesh.CreateFromCone(cone: Rhino.Geometry.Cone, vertical: int, around: int, solid: bool) -> Rhino.Geometry.Mesh
Rhino.Geometry.Mesh.CreateFromCone(cone: Rhino.Geometry.Cone, vertical: int, around: int, solid: bool, quadCaps: bool) -> Rhino.Geometry.Mesh
Rhino.Geometry.Mesh.CreateFromCurveExtrusion(curve: Rhino.Geometry.Curve, direction: Rhino.Geometry.Vector3d, parameters: Rhino.Geometry.MeshingParameters, boundingBox: Rhino.Geometry.BoundingBox) -> Rhino.Geometry.Mesh
Rhino.Geometry.Mesh.CreateFromCurvePipe(curve: Rhino.Geometry.Curve, radius: float, segments: int, accuracy: int, capType: Rhino.Geometry.MeshPipeCapStyle, faceted: bool, intervals: Iterable[Rhino.Geometry.Interval]) -> Rhino.Geometry.Mesh
Rhino.Geometry.Mesh.CreateFromCylinder(cylinder: Rhino.Geometry.Cylinder, vertical: int, around: int) -> Rhino.Geometry.Mesh
Rhino.Geometry.Mesh.CreateFromCylinder(cylinder: Rhino.Geometry.Cylinder, vertical: int, around: int, capBottom: bool, capTop: bool) -> Rhino.Geometry.Mesh
Rhino.Geometry.Mesh.CreateFromCylinder(cylinder: Rhino.Geometry.Cylinder, vertical: int, around: int, capBottom: bool, capTop: bool, circumscribe: bool, quadCaps: bool) -> Rhino.Geometry.Mesh
Rhino.Geometry.Mesh.CreateFromCylinder(cylinder: Rhino.Geometry.Cylinder, vertical: int, around: int, capBottom: bool, capTop: bool, quadCaps: bool) -> Rhino.Geometry.Mesh
Rhino.Geometry.Mesh.CreateFromExtrusion(extrusion: Rhino.Geometry.Extrusion, meshingParameters: Rhino.Geometry.MeshingParameters) -> Rhino.Geometry.Mesh
Rhino.Geometry.Mesh.CreateFromFilteredFaceList(original: Rhino.Geometry.Mesh, inclusion: Iterable[bool]) -> Rhino.Geometry.Mesh
Rhino.Geometry.Mesh.CreateFromIterativeCleanup(meshes: Iterable[Rhino.Geometry.Mesh], tolerance: float) -> List[Rhino.Geometry.Mesh]
Rhino.Geometry.Mesh.CreateFromLines(lines: List[Rhino.Geometry.Curve], maxFaceValence: int, tolerance: float) -> Rhino.Geometry.Mesh
Rhino.Geometry.Mesh.CreateFromPatchSingleFace(mesh: Rhino.Geometry.Mesh, components: Iterable[Rhino.Geometry.ComponentIndex]) -> Rhino.Geometry.Mesh
Rhino.Geometry.Mesh.CreateFromPlanarBoundary(boundary: Rhino.Geometry.Curve, parameters: Rhino.Geometry.MeshingParameters, tolerance: float) -> Rhino.Geometry.Mesh
Rhino.Geometry.Mesh.CreateFromPlane(plane: Rhino.Geometry.Plane, xInterval: Rhino.Geometry.Interval, yInterval: Rhino.Geometry.Interval, xCount: int, yCount: int) -> Rhino.Geometry.Mesh
Rhino.Geometry.Mesh.CreateFromSphere(sphere: Rhino.Geometry.Sphere, xCount: int, yCount: int) -> Rhino.Geometry.Mesh
Rhino.Geometry.Mesh.CreateFromSubD(subd: Rhino.Geometry.SubD, displayDensity: int) -> Rhino.Geometry.Mesh
Rhino.Geometry.Mesh.CreateFromSubDControlNet(subd: Rhino.Geometry.SubD) -> Rhino.Geometry.Mesh
Rhino.Geometry.Mesh.CreateFromSubDControlNetWithTextureCoordinates(subd: Rhino.Geometry.SubD) -> Rhino.Geometry.Mesh
Rhino.Geometry.Mesh.CreateFromSurface(surface: Rhino.Geometry.Surface) -> Rhino.Geometry.Mesh
Rhino.Geometry.Mesh.CreateFromSurface(surface: Rhino.Geometry.Surface, meshingParameters: Rhino.Geometry.MeshingParameters) -> Rhino.Geometry.Mesh
Rhino.Geometry.Mesh.CreateFromSurfaceControlNet(surface: Rhino.Geometry.Surface) -> Rhino.Geometry.Mesh
Rhino.Geometry.Mesh.CreateFromTessellation(points: Iterable[Rhino.Geometry.Point3d], edges: Iterable[Iterable[Rhino.Geometry.Point3d]], plane: Rhino.Geometry.Plane, allowNewVertices: bool) -> Rhino.Geometry.Mesh
Rhino.Geometry.Mesh.CreateFromTorus(torus: Rhino.Geometry.Torus, vertical: int, around: int) -> Rhino.Geometry.Mesh
Rhino.Geometry.Mesh.CreateIcoSphere(sphere: Rhino.Geometry.Sphere, subdivisions: int) -> Rhino.Geometry.Mesh
Rhino.Geometry.Mesh.CreatePartitions(self, maximumVertexCount: int, maximumTriangleCount: int) -> bool
Rhino.Geometry.Mesh.CreatePatch(outerBoundary: Rhino.Geometry.Polyline, angleToleranceRadians: float, pullbackSurface: Rhino.Geometry.Surface, innerBoundaryCurves: Iterable[Rhino.Geometry.Curve], innerBothSideCurves: Iterable[Rhino.Geometry.Curve], innerPoints: Iterable[Rhino.Geometry.Point3d], trimback: bool, divisions: int) -> Rhino.Geometry.Mesh
Rhino.Geometry.Mesh.CreateQuadSphere(sphere: Rhino.Geometry.Sphere, subdivisions: int) -> Rhino.Geometry.Mesh
Rhino.Geometry.Mesh.CreateUnweldedMesh(mesh: Rhino.Geometry.Mesh) -> Rhino.Geometry.Mesh
Rhino.Geometry.Mesh.CreateVertexColorsFromBitmap(self, doc: Rhino.RhinoDoc, mapping: Rhino.Render.TextureMapping, xform: Rhino.Geometry.Transform, bitmap: System.Drawing.Bitmap) -> bool
Rhino.Geometry.Mesh.DestroyPartition(self) -> None
Rhino.Geometry.Mesh.DestroyTopology(self) -> None
Rhino.Geometry.Mesh.DestroyTree(self) -> None
Rhino.Geometry.Mesh.Duplicate(self) -> GeometryBase
Rhino.Geometry.Mesh.DuplicateMesh(self) -> Rhino.Geometry.Mesh
Rhino.Geometry.Mesh.EvaluateMeshGeometry(self, surface: Rhino.Geometry.Surface) -> bool
Rhino.Geometry.Mesh.ExplodeAtUnweldedEdges(self) -> List[Rhino.Geometry.Mesh]
Rhino.Geometry.Mesh.ExtendSelectionByEdgeRidge(self, preselectedEdges: List[int], newEdge: int, iterative: bool) -> List[int]
Rhino.Geometry.Mesh.ExtendSelectionByFaceLoop(self, preselectedFaces: List[int], newFace: int, iterative: bool) -> List[int]
Rhino.Geometry.Mesh.ExtractNonManifoldEdges(self, selective: bool) -> Rhino.Geometry.Mesh
Rhino.Geometry.Mesh.FileHole(self, topologyEdgeIndex: int) -> bool
Rhino.Geometry.Mesh.FillHoles(self) -> bool
Rhino.Geometry.Mesh.Flip(self, vertexNormals: bool, faceNormals: bool, faceOrientation: bool) -> None
Rhino.Geometry.Mesh.Flip(self, vertexNormals: bool, faceNormals: bool, faceOrientation: bool, ngonsBoundaryDirection: bool) -> None
Rhino.Geometry.Mesh.GetCachedTextureCoordinates(self, rhinoObject: Rhino.DocObjects.RhinoObject, texture: Rhino.DocObjects.Texture) -> CachedTextureCoordinates
Rhino.Geometry.Mesh.GetCachedTextureCoordinates(self, textureMappingId: System.Guid) -> CachedTextureCoordinates
Rhino.Geometry.Mesh.GetNakedEdgePointStatus(self) -> List[bool]
Rhino.Geometry.Mesh.GetNakedEdges(self) -> List[Polyline]
Rhino.Geometry.Mesh.GetNgonAndFacesCount(self) -> int
Rhino.Geometry.Mesh.GetNgonAndFacesEnumerable(self) -> IEnumerable<MeshNgon>
Rhino.Geometry.Mesh.GetOutlines(self, plane: Rhino.Geometry.Plane) -> List[Polyline]
Rhino.Geometry.Mesh.GetOutlines(self, viewport: Rhino.Display.RhinoViewport) -> List[Polyline]
Rhino.Geometry.Mesh.GetOutlines(self, viewportInfo: Rhino.DocObjects.ViewportInfo, plane: Rhino.Geometry.Plane) -> List[Polyline]
Rhino.Geometry.Mesh.GetPartition(self, which: int) -> MeshPart
Rhino.Geometry.Mesh.GetSelfIntersections(self, tolerance: float, perforations: Rhino.Geometry.Polyline[]@, overlapsPolylines: bool, overlapsPolylinesResult: Rhino.Geometry.Polyline[]@, overlapsMesh: bool, overlapsMeshResult: Rhino.Geometry.Mesh@, textLog: Rhino.FileIO.TextLog, cancel: System.Threading.CancellationToken, progress: IProgress[float]) -> bool
Rhino.Geometry.Mesh.GetUnsafeLock(self, writable: bool) -> MeshUnsafeLock
Rhino.Geometry.Mesh.HealNakedEdges(self, distance: float) -> bool
Rhino.Geometry.Mesh.InvalidateCachedTextureCoordinates(self, bOnlyInvalidateCachedSurfaceParameterMapping: bool) -> None
Rhino.Geometry.Mesh.IsManifold(self) -> bool
Rhino.Geometry.Mesh.IsManifold(self, topologicalTest: bool, isOriented: System.Boolean@, hasBoundary: System.Boolean@) -> bool
Rhino.Geometry.Mesh.IsPointInside(self, point: Rhino.Geometry.Point3d, tolerance: float, strictlyIn: bool) -> bool
Rhino.Geometry.Mesh.MatchEdges(self, distance: float, rachet: bool) -> bool
Rhino.Geometry.Mesh.MergeAllCoplanarFaces(self, tolerance: float) -> bool
Rhino.Geometry.Mesh.MergeAllCoplanarFaces(self, tolerance: float, angleTolerance: float) -> bool
Rhino.Geometry.Mesh.NonConstOperation(self) -> None
Rhino.Geometry.Mesh.NormalAt(self, faceIndex: int, t0: float, t1: float, t2: float, t3: float) -> Vector3d
Rhino.Geometry.Mesh.NormalAt(self, meshPoint: Rhino.Geometry.MeshPoint) -> Vector3d
Rhino.Geometry.Mesh.Offset(self, distance: float) -> Rhino.Geometry.Mesh
Rhino.Geometry.Mesh.Offset(self, distance: float, solidify: bool) -> Rhino.Geometry.Mesh
Rhino.Geometry.Mesh.Offset(self, distance: float, solidify: bool, direction: Rhino.Geometry.Vector3d) -> Rhino.Geometry.Mesh
Rhino.Geometry.Mesh.Offset(self, distance: float, solidify: bool, direction: Rhino.Geometry.Vector3d, wallFacesOut: System.Collections.Generic.List{System.Int32}@) -> Rhino.Geometry.Mesh
Rhino.Geometry.Mesh.OnSwitchToNonConst(self) -> None
Rhino.Geometry.Mesh.PatchSingleFace(self, components: Iterable[Rhino.Geometry.ComponentIndex]) -> bool
Rhino.Geometry.Mesh.PointAt(self, faceIndex: int, t0: float, t1: float, t2: float, t3: float) -> Point3d
Rhino.Geometry.Mesh.PointAt(self, meshPoint: Rhino.Geometry.MeshPoint) -> Point3d
Rhino.Geometry.Mesh.PullCurve(self, curve: Rhino.Geometry.Curve, tolerance: float) -> PolylineCurve
Rhino.Geometry.Mesh.PullPointsToMesh(self, points: Iterable[Rhino.Geometry.Point3d]) -> List[Point3d]
Rhino.Geometry.Mesh.QuadRemesh(self, parameters: Rhino.Geometry.QuadRemeshParameters) -> Rhino.Geometry.Mesh
Rhino.Geometry.Mesh.QuadRemesh(self, parameters: Rhino.Geometry.QuadRemeshParameters, guideCurves: Iterable[Rhino.Geometry.Curve]) -> Rhino.Geometry.Mesh
Rhino.Geometry.Mesh.QuadRemeshAsync(self, faceBlocks: Iterable[int], parameters: Rhino.Geometry.QuadRemeshParameters, guideCurves: Iterable[Rhino.Geometry.Curve], progress: IProgress[int], cancelToken: System.Threading.CancellationToken) -> Task<Mesh>
Rhino.Geometry.Mesh.QuadRemeshAsync(self, parameters: Rhino.Geometry.QuadRemeshParameters, guideCurves: Iterable[Rhino.Geometry.Curve], progress: IProgress[int], cancelToken: System.Threading.CancellationToken) -> Task<Mesh>
Rhino.Geometry.Mesh.QuadRemeshAsync(self, parameters: Rhino.Geometry.QuadRemeshParameters, progress: IProgress[int], cancelToken: System.Threading.CancellationToken) -> Task<Mesh>
Rhino.Geometry.Mesh.QuadRemeshBrep(brep: Rhino.Geometry.Brep, parameters: Rhino.Geometry.QuadRemeshParameters) -> Rhino.Geometry.Mesh
Rhino.Geometry.Mesh.QuadRemeshBrep(brep: Rhino.Geometry.Brep, parameters: Rhino.Geometry.QuadRemeshParameters, guideCurves: Iterable[Rhino.Geometry.Curve]) -> Rhino.Geometry.Mesh
Rhino.Geometry.Mesh.QuadRemeshBrepAsync(brep: Rhino.Geometry.Brep, parameters: Rhino.Geometry.QuadRemeshParameters, guideCurves: Iterable[Rhino.Geometry.Curve], progress: IProgress[int], cancelToken: System.Threading.CancellationToken) -> Task<Mesh>
Rhino.Geometry.Mesh.QuadRemeshBrepAsync(brep: Rhino.Geometry.Brep, parameters: Rhino.Geometry.QuadRemeshParameters, progress: IProgress[int], cancelToken: System.Threading.CancellationToken) -> Task<Mesh>
Rhino.Geometry.Mesh.RebuildNormals(self) -> None
Rhino.Geometry.Mesh.Reduce(self, desiredPolygonCount: int, allowDistortion: bool, accuracy: int, normalizeSize: bool) -> bool
Rhino.Geometry.Mesh.Reduce(self, desiredPolygonCount: int, allowDistortion: bool, accuracy: int, normalizeSize: bool, cancelToken: System.Threading.CancellationToken, progress: IProgress[float], problemDescription: System.String@) -> bool
Rhino.Geometry.Mesh.Reduce(self, desiredPolygonCount: int, allowDistortion: bool, accuracy: int, normalizeSize: bool, cancelToken: System.Threading.CancellationToken, progress: IProgress[float], problemDescription: System.String@, threaded: bool) -> bool
Rhino.Geometry.Mesh.Reduce(self, desiredPolygonCount: int, allowDistortion: bool, accuracy: int, normalizeSize: bool, threaded: bool) -> bool
Rhino.Geometry.Mesh.Reduce(self, parameters: Rhino.Geometry.ReduceMeshParameters) -> bool
Rhino.Geometry.Mesh.Reduce(self, parameters: Rhino.Geometry.ReduceMeshParameters, threaded: bool) -> bool
Rhino.Geometry.Mesh.ReleaseUnsafeLock(self, meshData: Rhino.Geometry.MeshUnsafeLock) -> None
Rhino.Geometry.Mesh.RequireIterativeCleanup(meshes: Iterable[Rhino.Geometry.Mesh], tolerance: float) -> bool
Rhino.Geometry.Mesh.SetCachedTextureCoordinates(self, tm: Rhino.Render.TextureMapping, xf: Rhino.Geometry.Transform@) -> None
Rhino.Geometry.Mesh.SetCachedTextureCoordinatesFromMaterial(self, rhinoObject: Rhino.DocObjects.RhinoObject, material: Rhino.DocObjects.Material) -> None
Rhino.Geometry.Mesh.SetSurfaceParametersFromTextureCoordinates(self) -> bool
Rhino.Geometry.Mesh.SetTextureCoordinates(self, tm: Rhino.Render.TextureMapping, xf: Rhino.Geometry.Transform, lazy: bool) -> None
Rhino.Geometry.Mesh.SetTextureCoordinates(self, tm: Rhino.Render.TextureMapping, xf: Rhino.Geometry.Transform, lazy: bool, seamCheck: bool) -> None
Rhino.Geometry.Mesh.ShrinkWrap(geometryBases: Iterable[Rhino.Geometry.GeometryBase], parameters: Rhino.Geometry.ShrinkWrapParameters, meshingParameters: Rhino.Geometry.MeshingParameters) -> Rhino.Geometry.Mesh
Rhino.Geometry.Mesh.ShrinkWrap(geometryBases: Iterable[Rhino.Geometry.GeometryBase], parameters: Rhino.Geometry.ShrinkWrapParameters, meshingParameters: Rhino.Geometry.MeshingParameters, token: System.Threading.CancellationToken) -> Rhino.Geometry.Mesh
Rhino.Geometry.Mesh.ShrinkWrap(meshes: Iterable[Rhino.Geometry.Mesh], parameters: Rhino.Geometry.ShrinkWrapParameters) -> Rhino.Geometry.Mesh
Rhino.Geometry.Mesh.ShrinkWrap(meshes: Iterable[Rhino.Geometry.Mesh], parameters: Rhino.Geometry.ShrinkWrapParameters, token: System.Threading.CancellationToken) -> Rhino.Geometry.Mesh
Rhino.Geometry.Mesh.ShrinkWrap(pointCloud: Rhino.Geometry.PointCloud, parameters: Rhino.Geometry.ShrinkWrapParameters) -> Rhino.Geometry.Mesh
Rhino.Geometry.Mesh.ShrinkWrap(pointCloud: Rhino.Geometry.PointCloud, parameters: Rhino.Geometry.ShrinkWrapParameters, token: System.Threading.CancellationToken) -> Rhino.Geometry.Mesh
Rhino.Geometry.Mesh.ShrinkWrap(self, parameters: Rhino.Geometry.ShrinkWrapParameters) -> Rhino.Geometry.Mesh
Rhino.Geometry.Mesh.ShrinkWrap(self, parameters: Rhino.Geometry.ShrinkWrapParameters, token: System.Threading.CancellationToken) -> Rhino.Geometry.Mesh
Rhino.Geometry.Mesh.Smooth(self, smoothFactor: float, bXSmooth: bool, bYSmooth: bool, bZSmooth: bool, bFixBoundaries: bool, coordinateSystem: Rhino.Geometry.SmoothingCoordinateSystem) -> bool
Rhino.Geometry.Mesh.Smooth(self, smoothFactor: float, bXSmooth: bool, bYSmooth: bool, bZSmooth: bool, bFixBoundaries: bool, coordinateSystem: Rhino.Geometry.SmoothingCoordinateSystem, plane: Rhino.Geometry.Plane) -> bool
Rhino.Geometry.Mesh.Smooth(self, smoothFactor: float, numSteps: int, bXSmooth: bool, bYSmooth: bool, bZSmooth: bool, bFixBoundaries: bool, coordinateSystem: Rhino.Geometry.SmoothingCoordinateSystem, plane: Rhino.Geometry.Plane) -> bool
Rhino.Geometry.Mesh.Smooth(self, vertexIndices: Iterable[int], smoothFactor: float, bXSmooth: bool, bYSmooth: bool, bZSmooth: bool, bFixBoundaries: bool, coordinateSystem: Rhino.Geometry.SmoothingCoordinateSystem, plane: Rhino.Geometry.Plane) -> bool
Rhino.Geometry.Mesh.Smooth(self, vertexIndices: Iterable[int], smoothFactor: float, numSteps: int, bXSmooth: bool, bYSmooth: bool, bZSmooth: bool, bFixBoundaries: bool, coordinateSystem: Rhino.Geometry.SmoothingCoordinateSystem, plane: Rhino.Geometry.Plane) -> bool
Rhino.Geometry.Mesh.SolidOrientation(self) -> int
Rhino.Geometry.Mesh.Split(self, mesh: Rhino.Geometry.Mesh) -> List[Rhino.Geometry.Mesh]
Rhino.Geometry.Mesh.Split(self, meshes: Iterable[Rhino.Geometry.Mesh]) -> List[Rhino.Geometry.Mesh]
Rhino.Geometry.Mesh.Split(self, meshes: Iterable[Rhino.Geometry.Mesh], tolerance: float, splitAtCoplanar: bool, createNgons: bool, textLog: Rhino.FileIO.TextLog, cancel: System.Threading.CancellationToken, progress: IProgress[float]) -> List[Rhino.Geometry.Mesh]
Rhino.Geometry.Mesh.Split(self, meshes: Iterable[Rhino.Geometry.Mesh], tolerance: float, splitAtCoplanar: bool, textLog: Rhino.FileIO.TextLog, cancel: System.Threading.CancellationToken, progress: IProgress[float]) -> List[Rhino.Geometry.Mesh]
Rhino.Geometry.Mesh.Split(self, plane: Rhino.Geometry.Plane) -> List[Rhino.Geometry.Mesh]
Rhino.Geometry.Mesh.SplitDisjointPieces(self) -> List[Rhino.Geometry.Mesh]
Rhino.Geometry.Mesh.SplitWithProjectedPolylines(self, curves: Iterable[Rhino.Geometry.PolylineCurve], tolerance: float) -> List[Rhino.Geometry.Mesh]
Rhino.Geometry.Mesh.SplitWithProjectedPolylines(self, curves: Iterable[Rhino.Geometry.PolylineCurve], tolerance: float, textLog: Rhino.FileIO.TextLog, cancel: System.Threading.CancellationToken, progress: IProgress[float]) -> List[Rhino.Geometry.Mesh]
Rhino.Geometry.Mesh.Subdivide(self) -> bool
Rhino.Geometry.Mesh.Subdivide(self, faceIndices: Iterable[int]) -> bool
Rhino.Geometry.Mesh.UnifyNormals(self) -> int
Rhino.Geometry.Mesh.UnifyNormals(self, countOnly: bool) -> int
Rhino.Geometry.Mesh.Unweld(self, angleToleranceRadians: float, modifyNormals: bool) -> None
Rhino.Geometry.Mesh.UnweldEdge(self, edgeIndices: Iterable[int], modifyNormals: bool) -> bool
Rhino.Geometry.Mesh.UnweldVertices(self, topologyVertexIndices: Iterable[int], modifyNormals: bool) -> bool
Rhino.Geometry.Mesh.Volume(self) -> float
Rhino.Geometry.Mesh.Weld(self, angleToleranceRadians: float) -> None
Rhino.Geometry.Mesh.WithDisplacement(self, displacement: Rhino.Geometry.MeshDisplacementInfo) -> Rhino.Geometry.Mesh
Rhino.Geometry.Mesh.WithEdgeSoftening(self, softeningRadius: float, chamfer: bool, faceted: bool, force: bool, angleThreshold: float) -> Rhino.Geometry.Mesh
Rhino.Geometry.Mesh.WithShutLining(self, faceted: bool, tolerance: float, curves: Iterable[Rhino.Geometry.ShutLiningCurveInfo]) -> Rhino.Geometry.Mesh
Rhino.Geometry.Mesh.[ObsoleteAttribute(self, arg1: Rhino.Geometry.Brep) -> None
Rhino.Geometry.Mesh.[ObsoleteAttribute(self, arg1: Rhino.Geometry.Curve, arg2: Rhino.Geometry.MeshingParameters) -> None
Rhino.Geometry.Mesh.[ObsoleteAttribute(self, arg1: Rhino.Geometry.Mesh, arg2: Rhino.Geometry.Plane) -> None
Rhino.Geometry.Mesh.[ObsoleteAttribute(self, arg1: Rhino.Geometry.Mesh, arg2: Rhino.Geometry.Point3d, arg3: Rhino.Geometry.Point3d, arg4: float) -> None
Rhino.Geometry.Mesh.__init__(self) -> None
Rhino.Geometry.Mesh.__init__(self, info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext) -> None
Rhino.Geometry.MeshBooleanOptions.__init__(self) -> None
Rhino.Geometry.MeshCheckParameters.Defaults() -> Rhino.Geometry.MeshCheckParameters
Rhino.Geometry.MeshDisplacementInfo.__init__(self, texture: Rhino.Render.RenderTexture, mapping: Rhino.Render.TextureMapping) -> None
Rhino.Geometry.MeshExtruder.Dispose(self) -> None
Rhino.Geometry.MeshExtruder.ExtrudedMesh(self, extrudedMeshOut: Rhino.Geometry.Mesh@) -> bool
Rhino.Geometry.MeshExtruder.ExtrudedMesh(self, extrudedMeshOut: Rhino.Geometry.Mesh@, componentIndicesOut: System.Collections.Generic.List{Rhino.Geometry.ComponentIndex}@) -> bool
Rhino.Geometry.MeshExtruder.Finalize(self) -> None
Rhino.Geometry.MeshExtruder.GetWallFaces(self) -> List<int>
Rhino.Geometry.MeshExtruder.__init__(self, inputMesh: Rhino.Geometry.Mesh, componentIndices: Iterable[Rhino.Geometry.ComponentIndex]) -> None
Rhino.Geometry.MeshFace.!=(a: Rhino.Geometry.MeshFace, b: Rhino.Geometry.MeshFace) -> operator
Rhino.Geometry.MeshFace.==(a: Rhino.Geometry.MeshFace, b: Rhino.Geometry.MeshFace) -> operator
Rhino.Geometry.MeshFace.CompareTo(self, other: Rhino.Geometry.MeshFace) -> int
Rhino.Geometry.MeshFace.Equals(self, obj: Any) -> bool
Rhino.Geometry.MeshFace.Equals(self, other: Rhino.Geometry.MeshFace) -> bool
Rhino.Geometry.MeshFace.Flip(self) -> Rhino.Geometry.MeshFace
Rhino.Geometry.MeshFace.GetHashCode(self) -> int
Rhino.Geometry.MeshFace.IsValid(self) -> bool
Rhino.Geometry.MeshFace.IsValid(self, points: List[Rhino.Geometry.Point3d]) -> bool
Rhino.Geometry.MeshFace.IsValid(self, vertexCount: int) -> bool
Rhino.Geometry.MeshFace.IsValidEx(self, points: Rhino.Geometry.Point3d[]@) -> bool
Rhino.Geometry.MeshFace.Repair(self, points: List[Rhino.Geometry.Point3d]) -> bool
Rhino.Geometry.MeshFace.RepairEx(self, points: Rhino.Geometry.Point3d[]@) -> bool
Rhino.Geometry.MeshFace.Set(self, a: int, b: int, c: int) -> None
Rhino.Geometry.MeshFace.Set(self, a: int, b: int, c: int, d: int) -> None
Rhino.Geometry.MeshFace.ToString(self) -> str
Rhino.Geometry.MeshFace.__init__(self, a: int, b: int, c: int) -> None
Rhino.Geometry.MeshFace.__init__(self, a: int, b: int, c: int, d: int) -> None
Rhino.Geometry.MeshNgon.!=(a: Rhino.Geometry.MeshNgon, b: Rhino.Geometry.MeshNgon) -> operator
Rhino.Geometry.MeshNgon.==(a: Rhino.Geometry.MeshNgon, b: Rhino.Geometry.MeshNgon) -> operator
Rhino.Geometry.MeshNgon.BoundaryVertexIndexList(self) -> List[uint]
Rhino.Geometry.MeshNgon.CompareTo(self, otherNgon: Rhino.Geometry.MeshNgon) -> int
Rhino.Geometry.MeshNgon.Create(meshVertexIndexList: List[int], meshFaceIndexList: List[int]) -> Rhino.Geometry.MeshNgon
Rhino.Geometry.MeshNgon.Equals(self, otherNgon: Rhino.Geometry.MeshNgon) -> bool
Rhino.Geometry.MeshNgon.Equals(self, otherObj: Any) -> bool
Rhino.Geometry.MeshNgon.FaceIndexList(self) -> List[uint]
Rhino.Geometry.MeshNgon.GetHashCode(self) -> int
Rhino.Geometry.MeshNgon.Set(self, meshVertexIndexList: List[int], meshFaceIndexList: List[int]) -> None
Rhino.Geometry.MeshNgon.ToString(self) -> str
Rhino.Geometry.MeshPoint.GetTriangle(self, a: System.Int32@, b: System.Int32@, c: System.Int32@) -> bool
Rhino.Geometry.MeshRefinements.RefinementSettings.__init__(self) -> None
Rhino.Geometry.MeshThicknessMeasurement.__init__(self, meshIndex: int, vertexIndex: int, thickness: float, point: Rhino.Geometry.Point3d, oppositePoint: Rhino.Geometry.Point3d) -> None
Rhino.Geometry.MeshUnsafeLock.FaceNormalsArray(self, length: System.Int32@) -> Vector3f*
Rhino.Geometry.MeshUnsafeLock.FacesArray(self, length: System.Int32@) -> MeshFace*
Rhino.Geometry.MeshUnsafeLock.NormalVector3fArray(self, length: System.Int32@) -> Vector3f*
Rhino.Geometry.MeshUnsafeLock.Release(self) -> None
Rhino.Geometry.MeshUnsafeLock.VertexColorsArray(self, length: System.Int32@) -> int*
Rhino.Geometry.MeshUnsafeLock.VertexPoint3dArray(self, length: System.Int32@) -> Point3d*
Rhino.Geometry.MeshUnsafeLock.VertexPoint3fArray(self, length: System.Int32@) -> Point3f*
Rhino.Geometry.MeshUnwrapper.Dispose(self) -> None
Rhino.Geometry.MeshUnwrapper.Finalize(self) -> None
Rhino.Geometry.MeshUnwrapper.Unwrap(self, method: Rhino.Geometry.MeshUnwrapMethod) -> bool
Rhino.Geometry.MeshUnwrapper.__init__(self, mesh: Rhino.Geometry.Mesh) -> None
Rhino.Geometry.MeshUnwrapper.__init__(self, meshes: Iterable[Rhino.Geometry.Mesh]) -> None
Rhino.Geometry.MeshingParameters.!=(mp1: Rhino.Geometry.MeshingParameters, mp2: Rhino.Geometry.MeshingParameters) -> operator
Rhino.Geometry.MeshingParameters.==(mp1: Rhino.Geometry.MeshingParameters, mp2: Rhino.Geometry.MeshingParameters) -> operator
Rhino.Geometry.MeshingParameters.CopyFrom(self, source: Rhino.Geometry.MeshingParameters) -> None
Rhino.Geometry.MeshingParameters.Dispose(self) -> None
Rhino.Geometry.MeshingParameters.Dispose(self, disposing: bool) -> None
Rhino.Geometry.MeshingParameters.DocumentCurrentSetting(doc: Rhino.RhinoDoc) -> Rhino.Geometry.MeshingParameters
Rhino.Geometry.MeshingParameters.Equals(self, obj: Any) -> bool
Rhino.Geometry.MeshingParameters.Equals(self, other: Rhino.Geometry.MeshingParameters) -> bool
Rhino.Geometry.MeshingParameters.Finalize(self) -> None
Rhino.Geometry.MeshingParameters.FromEncodedString(value: str) -> Rhino.Geometry.MeshingParameters
Rhino.Geometry.MeshingParameters.GetHashCode(self) -> int
Rhino.Geometry.MeshingParameters.GetObjectData(self, info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext) -> None
Rhino.Geometry.MeshingParameters.SetSubDDisplayParameters(self, subDDisplayParameters: Rhino.Geometry.SubDDisplayParameters) -> None
Rhino.Geometry.MeshingParameters.SubDDisplayParameters(self) -> SubDDisplayParameters
Rhino.Geometry.MeshingParameters.ToEncodedString(self) -> str
Rhino.Geometry.MeshingParameters.__init__(self) -> None
Rhino.Geometry.MeshingParameters.__init__(self, density: float) -> None
Rhino.Geometry.MeshingParameters.__init__(self, density: float, minimumEdgeLength: float) -> None
Rhino.Geometry.MeshingParameters.__init__(self, info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext) -> None
Rhino.Geometry.MeshingParameters.__init__(self, source: Rhino.Geometry.MeshingParameters) -> None
Rhino.Geometry.MorphControl.Morph(self, geometry: Rhino.Geometry.GeometryBase) -> bool
Rhino.Geometry.MorphControl.__init__(self, info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext) -> None
Rhino.Geometry.MorphControl.__init__(self, originCurve: Rhino.Geometry.NurbsCurve, targetCurve: Rhino.Geometry.NurbsCurve) -> None
Rhino.Geometry.Morphs.BendSpaceMorph.Dispose(self) -> None
Rhino.Geometry.Morphs.BendSpaceMorph.Dispose(self, disposing: bool) -> None
Rhino.Geometry.Morphs.BendSpaceMorph.Finalize(self) -> None
Rhino.Geometry.Morphs.BendSpaceMorph.MorphPoint(self, point: Rhino.Geometry.Point3d) -> Point3d
Rhino.Geometry.Morphs.BendSpaceMorph.__init__(self, start: Rhino.Geometry.Point3d, end: Rhino.Geometry.Point3d, point: Rhino.Geometry.Point3d, angle: float, straight: bool, symmetric: bool) -> None
Rhino.Geometry.Morphs.BendSpaceMorph.__init__(self, start: Rhino.Geometry.Point3d, end: Rhino.Geometry.Point3d, point: Rhino.Geometry.Point3d, straight: bool, symmetric: bool) -> None
Rhino.Geometry.Morphs.FlowSpaceMorph.Dispose(self) -> None
Rhino.Geometry.Morphs.FlowSpaceMorph.Dispose(self, disposing: bool) -> None
Rhino.Geometry.Morphs.FlowSpaceMorph.Finalize(self) -> None
Rhino.Geometry.Morphs.FlowSpaceMorph.MorphPoint(self, point: Rhino.Geometry.Point3d) -> Point3d
Rhino.Geometry.Morphs.FlowSpaceMorph.__init__(self, curve0: Rhino.Geometry.Curve, curve1: Rhino.Geometry.Curve, preventStretching: bool) -> None
Rhino.Geometry.Morphs.FlowSpaceMorph.__init__(self, curve0: Rhino.Geometry.Curve, curve1: Rhino.Geometry.Curve, reverseCurve0: bool, reverseCurve1: bool, preventStretching: bool) -> None
Rhino.Geometry.Morphs.MaelstromSpaceMorph.Dispose(self) -> None
Rhino.Geometry.Morphs.MaelstromSpaceMorph.Dispose(self, disposing: bool) -> None
Rhino.Geometry.Morphs.MaelstromSpaceMorph.Finalize(self) -> None
Rhino.Geometry.Morphs.MaelstromSpaceMorph.MorphPoint(self, point: Rhino.Geometry.Point3d) -> Point3d
Rhino.Geometry.Morphs.MaelstromSpaceMorph.__init__(self, plane: Rhino.Geometry.Plane, radius0: float, radius1: float, angle: float) -> None
Rhino.Geometry.Morphs.SplopSpaceMorph.Dispose(self) -> None
Rhino.Geometry.Morphs.SplopSpaceMorph.Dispose(self, disposing: bool) -> None
Rhino.Geometry.Morphs.SplopSpaceMorph.Finalize(self) -> None
Rhino.Geometry.Morphs.SplopSpaceMorph.MorphPoint(self, point: Rhino.Geometry.Point3d) -> Point3d
Rhino.Geometry.Morphs.SplopSpaceMorph.__init__(self, plane: Rhino.Geometry.Plane, surface: Rhino.Geometry.Surface, surfaceParam: Rhino.Geometry.Point2d) -> None
Rhino.Geometry.Morphs.SplopSpaceMorph.__init__(self, plane: Rhino.Geometry.Plane, surface: Rhino.Geometry.Surface, surfaceParam: Rhino.Geometry.Point2d, scale: float) -> None
Rhino.Geometry.Morphs.SplopSpaceMorph.__init__(self, plane: Rhino.Geometry.Plane, surface: Rhino.Geometry.Surface, surfaceParam: Rhino.Geometry.Point2d, scale: float, angle: float) -> None
Rhino.Geometry.Morphs.SporphSpaceMorph.Dispose(self) -> None
Rhino.Geometry.Morphs.SporphSpaceMorph.Dispose(self, disposing: bool) -> None
Rhino.Geometry.Morphs.SporphSpaceMorph.Finalize(self) -> None
Rhino.Geometry.Morphs.SporphSpaceMorph.MorphPoint(self, point: Rhino.Geometry.Point3d) -> Point3d
Rhino.Geometry.Morphs.SporphSpaceMorph.__init__(self, surface0: Rhino.Geometry.Surface, surface1: Rhino.Geometry.Surface) -> None
Rhino.Geometry.Morphs.SporphSpaceMorph.__init__(self, surface0: Rhino.Geometry.Surface, surface1: Rhino.Geometry.Surface, surface0Param: Rhino.Geometry.Point2d, surface1Param: Rhino.Geometry.Point2d) -> None
Rhino.Geometry.Morphs.StretchSpaceMorph.Dispose(self) -> None
Rhino.Geometry.Morphs.StretchSpaceMorph.Dispose(self, disposing: bool) -> None
Rhino.Geometry.Morphs.StretchSpaceMorph.Finalize(self) -> None
Rhino.Geometry.Morphs.StretchSpaceMorph.MorphPoint(self, point: Rhino.Geometry.Point3d) -> Point3d
Rhino.Geometry.Morphs.StretchSpaceMorph.__init__(self, start: Rhino.Geometry.Point3d, end: Rhino.Geometry.Point3d, length: float) -> None
Rhino.Geometry.Morphs.StretchSpaceMorph.__init__(self, start: Rhino.Geometry.Point3d, end: Rhino.Geometry.Point3d, point: Rhino.Geometry.Point3d) -> None
Rhino.Geometry.Morphs.TaperSpaceMorph.Dispose(self) -> None
Rhino.Geometry.Morphs.TaperSpaceMorph.Dispose(self, disposing: bool) -> None
Rhino.Geometry.Morphs.TaperSpaceMorph.Finalize(self) -> None
Rhino.Geometry.Morphs.TaperSpaceMorph.MorphPoint(self, point: Rhino.Geometry.Point3d) -> Point3d
Rhino.Geometry.Morphs.TaperSpaceMorph.__init__(self, start: Rhino.Geometry.Point3d, end: Rhino.Geometry.Point3d, startRadius: float, endRadius: float, bFlat: bool, infiniteTaper: bool) -> None
Rhino.Geometry.Morphs.TwistSpaceMorph.Dispose(self) -> None
Rhino.Geometry.Morphs.TwistSpaceMorph.Dispose(self, disposing: bool) -> None
Rhino.Geometry.Morphs.TwistSpaceMorph.Finalize(self) -> None
Rhino.Geometry.Morphs.TwistSpaceMorph.MorphPoint(self, point: Rhino.Geometry.Point3d) -> Point3d
Rhino.Geometry.Morphs.TwistSpaceMorph.__init__(self) -> None
Rhino.Geometry.NurbsCurve.Append(self, nurbsCurve: Rhino.Geometry.NurbsCurve) -> bool
Rhino.Geometry.NurbsCurve.ConvertSpanToBezier(self, spanIndex: int) -> BezierCurve
Rhino.Geometry.NurbsCurve.Create(periodic: bool, degree: int, points: Iterable[Rhino.Geometry.Point3d]) -> Rhino.Geometry.NurbsCurve
Rhino.Geometry.NurbsCurve.CreateFromArc(arc: Rhino.Geometry.Arc) -> Rhino.Geometry.NurbsCurve
Rhino.Geometry.NurbsCurve.CreateFromArc(arc: Rhino.Geometry.Arc, degree: int, cvCount: int) -> Rhino.Geometry.NurbsCurve
Rhino.Geometry.NurbsCurve.CreateFromCircle(circle: Rhino.Geometry.Circle) -> Rhino.Geometry.NurbsCurve
Rhino.Geometry.NurbsCurve.CreateFromCircle(circle: Rhino.Geometry.Circle, degree: int, cvCount: int) -> Rhino.Geometry.NurbsCurve
Rhino.Geometry.NurbsCurve.CreateFromEllipse(ellipse: Rhino.Geometry.Ellipse) -> Rhino.Geometry.NurbsCurve
Rhino.Geometry.NurbsCurve.CreateFromFitPoints(points: Iterable[Rhino.Geometry.Point3d], tolerance: float, degree: int, periodic: bool, startTangent: Rhino.Geometry.Vector3d, endTangent: Rhino.Geometry.Vector3d) -> Rhino.Geometry.NurbsCurve
Rhino.Geometry.NurbsCurve.CreateFromFitPoints(points: Iterable[Rhino.Geometry.Point3d], tolerance: float, periodic: bool) -> Rhino.Geometry.NurbsCurve
Rhino.Geometry.NurbsCurve.CreateFromLine(line: Rhino.Geometry.Line) -> Rhino.Geometry.NurbsCurve
Rhino.Geometry.NurbsCurve.CreateHSpline(points: Iterable[Rhino.Geometry.Point3d]) -> Rhino.Geometry.NurbsCurve
Rhino.Geometry.NurbsCurve.CreateHSpline(points: Iterable[Rhino.Geometry.Point3d], startTangent: Rhino.Geometry.Vector3d, endTangent: Rhino.Geometry.Vector3d) -> Rhino.Geometry.NurbsCurve
Rhino.Geometry.NurbsCurve.CreateNonRationalArcBezier(degree: int, center: Rhino.Geometry.Point3d, start: Rhino.Geometry.Point3d, end: Rhino.Geometry.Point3d, radius: float, tanSlider: float, midSlider: float) -> Rhino.Geometry.NurbsCurve
Rhino.Geometry.NurbsCurve.CreateParabolaFromFocus(focus: Rhino.Geometry.Point3d, startPoint: Rhino.Geometry.Point3d, endPoint: Rhino.Geometry.Point3d) -> Rhino.Geometry.NurbsCurve
Rhino.Geometry.NurbsCurve.CreateParabolaFromPoints(startPoint: Rhino.Geometry.Point3d, innerPoint: Rhino.Geometry.Point3d, endPoint: Rhino.Geometry.Point3d) -> Rhino.Geometry.NurbsCurve
Rhino.Geometry.NurbsCurve.CreateParabolaFromVertex(vertex: Rhino.Geometry.Point3d, startPoint: Rhino.Geometry.Point3d, endPoint: Rhino.Geometry.Point3d) -> Rhino.Geometry.NurbsCurve
Rhino.Geometry.NurbsCurve.CreatePlanarRailFrames(self, parameters: Iterable[float], normal: Rhino.Geometry.Vector3d) -> List[Plane]
Rhino.Geometry.NurbsCurve.CreateRailFrames(self, parameters: Iterable[float]) -> List[Plane]
Rhino.Geometry.NurbsCurve.CreateSpiral(axisStart: Rhino.Geometry.Point3d, axisDir: Rhino.Geometry.Vector3d, radiusPoint: Rhino.Geometry.Point3d, pitch: float, turnCount: float, radius0: float, radius1: float) -> Rhino.Geometry.NurbsCurve
Rhino.Geometry.NurbsCurve.CreateSpiral(railCurve: Rhino.Geometry.Curve, t0: float, t1: float, radiusPoint: Rhino.Geometry.Point3d, pitch: float, turnCount: float, radius0: float, radius1: float, pointsPerTurn: int) -> Rhino.Geometry.NurbsCurve
Rhino.Geometry.NurbsCurve.CreateSubDFriendly(curve: Rhino.Geometry.Curve) -> Rhino.Geometry.NurbsCurve
Rhino.Geometry.NurbsCurve.CreateSubDFriendly(curve: Rhino.Geometry.Curve, pointCount: int, periodicClosedCurve: bool) -> Rhino.Geometry.NurbsCurve
Rhino.Geometry.NurbsCurve.CreateSubDFriendly(points: Iterable[Rhino.Geometry.Point3d], interpolatePoints: bool, periodicClosedCurve: bool) -> Rhino.Geometry.NurbsCurve
Rhino.Geometry.NurbsCurve.EpsilonEquals(self, other: Rhino.Geometry.NurbsCurve, epsilon: float) -> bool
Rhino.Geometry.NurbsCurve.GrevilleParameter(self, index: int) -> float
Rhino.Geometry.NurbsCurve.GrevilleParameters(self) -> List[float]
Rhino.Geometry.NurbsCurve.GrevillePoint(self, index: int) -> Point3d
Rhino.Geometry.NurbsCurve.GrevillePoints(self) -> Point3dList
Rhino.Geometry.NurbsCurve.GrevillePoints(self, all: bool) -> Point3dList
Rhino.Geometry.NurbsCurve.IncreaseDegree(self, desiredDegree: int) -> bool
Rhino.Geometry.NurbsCurve.IsDuplicate(curveA: Rhino.Geometry.NurbsCurve, curveB: Rhino.Geometry.NurbsCurve, ignoreParameterization: bool, tolerance: float) -> bool
Rhino.Geometry.NurbsCurve.MakeCompatible(curves: Iterable[Rhino.Geometry.Curve], startPt: Rhino.Geometry.Point3d, endPt: Rhino.Geometry.Point3d, simplifyMethod: int, numPoints: int, refitTolerance: float, angleTolerance: float) -> List[Rhino.Geometry.NurbsCurve]
Rhino.Geometry.NurbsCurve.MakePiecewiseBezier(self, setEndWeightsToOne: bool) -> bool
Rhino.Geometry.NurbsCurve.MatchToCurve(self, targetCurve: Rhino.Geometry.Curve, maxEndDistance: float, maxInteriorDistance: float, matchTolerance: float, maxLevel: int) -> Rhino.Geometry.NurbsCurve
Rhino.Geometry.NurbsCurve.Reparameterize(self, c: float) -> bool
Rhino.Geometry.NurbsCurve.SetEndCondition(self, arg1: bool, arg2: Rhino.Geometry.NurbsCurve.NurbsCurveEndConditionType, arg3: Rhino.Geometry.Point3d, arg4: Rhino.Geometry.Vector3d) -> bool
Rhino.Geometry.NurbsCurve.SetEndCondition(self, arg1: bool, arg2: Rhino.Geometry.NurbsCurve.NurbsCurveEndConditionType, arg3: Rhino.Geometry.Point3d, arg4: Rhino.Geometry.Vector3d, arg5: Rhino.Geometry.Vector3d) -> bool
Rhino.Geometry.NurbsCurve.SetGrevillePoints(self, points: Iterable[Rhino.Geometry.Point3d]) -> bool
Rhino.Geometry.NurbsCurve.UVNDirectionsAt(self, t: float, uDir: Rhino.Geometry.Vector3d@, vDir: Rhino.Geometry.Vector3d@, nDir: Rhino.Geometry.Vector3d@) -> bool
Rhino.Geometry.NurbsCurve.__init__(self, degree: int, pointCount: int) -> None
Rhino.Geometry.NurbsCurve.__init__(self, dimension: int, rational: bool, order: int, pointCount: int) -> None
Rhino.Geometry.NurbsCurve.__init__(self, info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext) -> None
Rhino.Geometry.NurbsCurve.__init__(self, other: Rhino.Geometry.NurbsCurve) -> None
Rhino.Geometry.NurbsSurface.ConvertSpanToBezier(self, spanIndex0: int, spanIndex1: int) -> BezierSurface
Rhino.Geometry.NurbsSurface.CopyFrom(self, other: Rhino.Geometry.NurbsSurface) -> None
Rhino.Geometry.NurbsSurface.Create(dimension: int, isRational: bool, order0: int, order1: int, controlPointCount0: int, controlPointCount1: int) -> Rhino.Geometry.NurbsSurface
Rhino.Geometry.NurbsSurface.CreateCurveOnSurface(surface: Rhino.Geometry.Surface, points: Iterable[Rhino.Geometry.Point2d], tolerance: float, periodic: bool) -> NurbsCurve
Rhino.Geometry.NurbsSurface.CreateCurveOnSurfacePoints(surface: Rhino.Geometry.Surface, fixedPoints: Iterable[Rhino.Geometry.Point2d], tolerance: float, periodic: bool, initCount: int, levels: int) -> List[Point2d]
Rhino.Geometry.NurbsSurface.CreateFromCone(cone: Rhino.Geometry.Cone) -> Rhino.Geometry.NurbsSurface
Rhino.Geometry.NurbsSurface.CreateFromCorners(corner1: Rhino.Geometry.Point3d, corner2: Rhino.Geometry.Point3d, corner3: Rhino.Geometry.Point3d) -> Rhino.Geometry.NurbsSurface
Rhino.Geometry.NurbsSurface.CreateFromCorners(corner1: Rhino.Geometry.Point3d, corner2: Rhino.Geometry.Point3d, corner3: Rhino.Geometry.Point3d, corner4: Rhino.Geometry.Point3d) -> Rhino.Geometry.NurbsSurface
Rhino.Geometry.NurbsSurface.CreateFromCorners(corner1: Rhino.Geometry.Point3d, corner2: Rhino.Geometry.Point3d, corner3: Rhino.Geometry.Point3d, corner4: Rhino.Geometry.Point3d, tolerance: float) -> Rhino.Geometry.NurbsSurface
Rhino.Geometry.NurbsSurface.CreateFromCylinder(cylinder: Rhino.Geometry.Cylinder) -> Rhino.Geometry.NurbsSurface
Rhino.Geometry.NurbsSurface.CreateFromPlane(plane: Rhino.Geometry.Plane, uInterval: Rhino.Geometry.Interval, vInterval: Rhino.Geometry.Interval, uDegree: int, vDegree: int, uPointCount: int, vPointCount: int) -> Rhino.Geometry.NurbsSurface
Rhino.Geometry.NurbsSurface.CreateFromPoints(points: Iterable[Rhino.Geometry.Point3d], uCount: int, vCount: int, uDegree: int, vDegree: int) -> Rhino.Geometry.NurbsSurface
Rhino.Geometry.NurbsSurface.CreateFromSphere(sphere: Rhino.Geometry.Sphere) -> Rhino.Geometry.NurbsSurface
Rhino.Geometry.NurbsSurface.CreateFromTorus(torus: Rhino.Geometry.Torus) -> Rhino.Geometry.NurbsSurface
Rhino.Geometry.NurbsSurface.CreateNetworkSurface(curves: Iterable[Rhino.Geometry.Curve], continuity: int, edgeTolerance: float, interiorTolerance: float, angleTolerance: float, error: System.Int32@) -> Rhino.Geometry.NurbsSurface
Rhino.Geometry.NurbsSurface.CreateNetworkSurface(uCurves: Iterable[Rhino.Geometry.Curve], uContinuityStart: int, uContinuityEnd: int, vCurves: Iterable[Rhino.Geometry.Curve], vContinuityStart: int, vContinuityEnd: int, edgeTolerance: float, interiorTolerance: float, angleTolerance: float, error: System.Int32@) -> Rhino.Geometry.NurbsSurface
Rhino.Geometry.NurbsSurface.CreateRailRevolvedSurface(profile: Rhino.Geometry.Curve, rail: Rhino.Geometry.Curve, axis: Rhino.Geometry.Line, scaleHeight: bool) -> Rhino.Geometry.NurbsSurface
Rhino.Geometry.NurbsSurface.CreateRuledSurface(curveA: Rhino.Geometry.Curve, curveB: Rhino.Geometry.Curve) -> Rhino.Geometry.NurbsSurface
Rhino.Geometry.NurbsSurface.CreateSubDFriendly(surface: Rhino.Geometry.Surface) -> Rhino.Geometry.NurbsSurface
Rhino.Geometry.NurbsSurface.CreateThroughPoints(points: Iterable[Rhino.Geometry.Point3d], uCount: int, vCount: int, uDegree: int, vDegree: int, uClosed: bool, vClosed: bool) -> Rhino.Geometry.NurbsSurface
Rhino.Geometry.NurbsSurface.EpsilonEquals(self, other: Rhino.Geometry.NurbsSurface, epsilon: float) -> bool
Rhino.Geometry.NurbsSurface.FindClosestIsoCurve(self, testPoint: Rhino.Geometry.Point3d) -> IsoStatus
Rhino.Geometry.NurbsSurface.IncreaseDegreeU(self, desiredDegree: int) -> bool
Rhino.Geometry.NurbsSurface.IncreaseDegreeV(self, desiredDegree: int) -> bool
Rhino.Geometry.NurbsSurface.MakeCompatible(surface0: Rhino.Geometry.Surface, surface1: Rhino.Geometry.Surface, nurb0: Rhino.Geometry.NurbsSurface@, nurb1: Rhino.Geometry.NurbsSurface@) -> bool
Rhino.Geometry.NurbsSurface.MakeNonRational(self) -> bool
Rhino.Geometry.NurbsSurface.MakeRational(self) -> bool
Rhino.Geometry.NurbsSurface.MatchToCurve(self, side: Rhino.Geometry.IsoStatus, targetCurve: Rhino.Geometry.Curve, maxEndDistance: float, maxInteriorDistance: float, matchTolerance: float, maxLevel: int) -> Rhino.Geometry.NurbsSurface
Rhino.Geometry.NurbsSurface.UVNDirectionsAt(self, u: float, v: float, uDir: Rhino.Geometry.Vector3d@, vDir: Rhino.Geometry.Vector3d@, nDir: Rhino.Geometry.Vector3d@) -> bool
Rhino.Geometry.NurbsSurface.__init__(self, info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext) -> None
Rhino.Geometry.NurbsSurface.__init__(self, other: Rhino.Geometry.NurbsSurface) -> None
Rhino.Geometry.OrdinateDimension.AdjustFromPoints(self, arg1: Rhino.Geometry.Plane, arg2: Rhino.Geometry.OrdinateDimension.MeasuredDirection, arg3: Rhino.Geometry.Point3d, arg4: Rhino.Geometry.Point3d, arg5: Rhino.Geometry.Point3d, arg6: float, arg7: float) -> bool
Rhino.Geometry.OrdinateDimension.Create(arg1: Rhino.DocObjects.DimensionStyle, arg2: Rhino.Geometry.Plane, arg3: Rhino.Geometry.OrdinateDimension.MeasuredDirection, arg4: Rhino.Geometry.Point3d, arg5: Rhino.Geometry.Point3d, arg6: Rhino.Geometry.Point3d, arg7: float, arg8: float) -> Rhino.Geometry.OrdinateDimension
Rhino.Geometry.OrdinateDimension.Get3dPoints(self, basepoint: Rhino.Geometry.Point3d@, defpoint: Rhino.Geometry.Point3d@, leaderpoint: Rhino.Geometry.Point3d@, kinkpoint1: Rhino.Geometry.Point3d@, kinkpoint2: Rhino.Geometry.Point3d@) -> bool
Rhino.Geometry.OrdinateDimension.GetDisplayLines(self, style: Rhino.DocObjects.DimensionStyle, scale: float, lines: System.Collections.Generic.IEnumerable{Rhino.Geometry.Line}@) -> bool
Rhino.Geometry.OrdinateDimension.GetDistanceDisplayText(self, unitsystem: Rhino.UnitSystem, style: Rhino.DocObjects.DimensionStyle) -> str
Rhino.Geometry.OrdinateDimension.GetTextRectangle(self, corners: Rhino.Geometry.Point3d[]@) -> bool
Rhino.Geometry.OrdinateDimension.__init__(self) -> None
Rhino.Geometry.OrdinateDimension.__init__(self, arg1: Rhino.Geometry.Plane, arg2: Rhino.Geometry.OrdinateDimension.MeasuredDirection, arg3: Rhino.Geometry.Point3d, arg4: Rhino.Geometry.Point3d, arg5: Rhino.Geometry.Point3d, arg6: float, arg7: float) -> None
Rhino.Geometry.OrdinateDimension.__init__(self, info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext) -> None
Rhino.Geometry.Particle.Update(self) -> None
Rhino.Geometry.Particle.__init__(self) -> None
Rhino.Geometry.ParticleSystem.Add(self, particle: Rhino.Geometry.Particle) -> bool
Rhino.Geometry.ParticleSystem.Clear(self) -> None
Rhino.Geometry.ParticleSystem.GetEnumerator(self) -> IEnumerator<Particle>
Rhino.Geometry.ParticleSystem.Remove(self, particle: Rhino.Geometry.Particle) -> None
Rhino.Geometry.ParticleSystem.Update(self) -> None
Rhino.Geometry.ParticleSystem.__init__(self) -> None
Rhino.Geometry.Plane.!=(a: Rhino.Geometry.Plane, b: Rhino.Geometry.Plane) -> operator
Rhino.Geometry.Plane.==(a: Rhino.Geometry.Plane, b: Rhino.Geometry.Plane) -> operator
Rhino.Geometry.Plane.Clone(self) -> Rhino.Geometry.Plane
Rhino.Geometry.Plane.ClosestParameter(self, testPoint: Rhino.Geometry.Point3d, s: System.Double@, t: System.Double@) -> bool
Rhino.Geometry.Plane.ClosestPoint(self, testPoint: Rhino.Geometry.Point3d) -> Point3d
Rhino.Geometry.Plane.CreateFromFrame(origin: Rhino.Geometry.Point3d, xDirection: Rhino.Geometry.Vector3d, yDirection: Rhino.Geometry.Vector3d) -> Rhino.Geometry.Plane
Rhino.Geometry.Plane.CreateFromNormal(origin: Rhino.Geometry.Point3d, normal: Rhino.Geometry.Vector3d) -> Rhino.Geometry.Plane
Rhino.Geometry.Plane.CreateFromNormalYup(origin: Rhino.Geometry.Point3d, normal: Rhino.Geometry.Vector3d, yDirection: Rhino.Geometry.Vector3d) -> Rhino.Geometry.Plane
Rhino.Geometry.Plane.CreateFromPoints(origin: Rhino.Geometry.Point3d, xPoint: Rhino.Geometry.Point3d, yPoint: Rhino.Geometry.Point3d) -> Rhino.Geometry.Plane
Rhino.Geometry.Plane.DistanceTo(self, bbox: Rhino.Geometry.BoundingBox, min: System.Double@, max: System.Double@) -> bool
Rhino.Geometry.Plane.DistanceTo(self, testPoint: Rhino.Geometry.Point3d) -> float
Rhino.Geometry.Plane.EpsilonEquals(self, other: Rhino.Geometry.Plane, epsilon: float) -> bool
Rhino.Geometry.Plane.Equals(self, obj: Any) -> bool
Rhino.Geometry.Plane.Equals(self, plane: Rhino.Geometry.Plane) -> bool
Rhino.Geometry.Plane.ExtendThroughBox(self, box: Rhino.Geometry.BoundingBox, s: Rhino.Geometry.Interval@, t: Rhino.Geometry.Interval@) -> bool
Rhino.Geometry.Plane.ExtendThroughBox(self, box: Rhino.Geometry.Box, s: Rhino.Geometry.Interval@, t: Rhino.Geometry.Interval@) -> bool
Rhino.Geometry.Plane.FitPlaneToPoints(points: Iterable[Rhino.Geometry.Point3d], plane: Rhino.Geometry.Plane@) -> PlaneFitResult
Rhino.Geometry.Plane.FitPlaneToPoints(points: Iterable[Rhino.Geometry.Point3d], plane: Rhino.Geometry.Plane@, maximumDeviation: System.Double@) -> PlaneFitResult
Rhino.Geometry.Plane.Flip(self) -> None
Rhino.Geometry.Plane.GetHashCode(self) -> int
Rhino.Geometry.Plane.GetPlaneEquation(self) -> List[float]
Rhino.Geometry.Plane.IsCoplanar(self, plane: Rhino.Geometry.Plane) -> bool
Rhino.Geometry.Plane.IsCoplanar(self, plane: Rhino.Geometry.Plane, tolerance: float) -> bool
Rhino.Geometry.Plane.PointAt(self, u: float, v: float) -> Point3d
Rhino.Geometry.Plane.PointAt(self, u: float, v: float, w: float) -> Point3d
Rhino.Geometry.Plane.RemapToPlaneSpace(self, ptSample: Rhino.Geometry.Point3d, ptPlane: Rhino.Geometry.Point3d@) -> bool
Rhino.Geometry.Plane.Rotate(self, angle: float, axis: Rhino.Geometry.Vector3d) -> bool
Rhino.Geometry.Plane.Rotate(self, angle: float, axis: Rhino.Geometry.Vector3d, centerOfRotation: Rhino.Geometry.Point3d) -> bool
Rhino.Geometry.Plane.Rotate(self, sinAngle: float, cosAngle: float, axis: Rhino.Geometry.Vector3d) -> bool
Rhino.Geometry.Plane.Rotate(self, sinAngle: float, cosAngle: float, axis: Rhino.Geometry.Vector3d, centerOfRotation: Rhino.Geometry.Point3d) -> bool
Rhino.Geometry.Plane.ToString(self) -> str
Rhino.Geometry.Plane.ToString(self, format: str, formatProvider: System.IFormatProvider) -> str
Rhino.Geometry.Plane.Transform(self, xform: Rhino.Geometry.Transform) -> bool
Rhino.Geometry.Plane.Translate(self, delta: Rhino.Geometry.Vector3d) -> bool
Rhino.Geometry.Plane.UpdateEquation(self) -> bool
Rhino.Geometry.Plane.ValueAt(self, p: Rhino.Geometry.Point3d) -> float
Rhino.Geometry.Plane.__init__(self, a: float, b: float, c: float, d: float) -> None
Rhino.Geometry.Plane.__init__(self, origin: Rhino.Geometry.Point3d, normal: Rhino.Geometry.Vector3d) -> None
Rhino.Geometry.Plane.__init__(self, origin: Rhino.Geometry.Point3d, xDirection: Rhino.Geometry.Vector3d, yDirection: Rhino.Geometry.Vector3d) -> None
Rhino.Geometry.Plane.__init__(self, origin: Rhino.Geometry.Point3d, xPoint: Rhino.Geometry.Point3d, yPoint: Rhino.Geometry.Point3d) -> None
Rhino.Geometry.Plane.__init__(self, other: Rhino.Geometry.Plane) -> None
Rhino.Geometry.PlaneSurface.CreateThroughBox(lineInPlane: Rhino.Geometry.Line, vectorInPlane: Rhino.Geometry.Vector3d, box: Rhino.Geometry.BoundingBox) -> Rhino.Geometry.PlaneSurface
Rhino.Geometry.PlaneSurface.CreateThroughBox(plane: Rhino.Geometry.Plane, box: Rhino.Geometry.BoundingBox) -> Rhino.Geometry.PlaneSurface
Rhino.Geometry.PlaneSurface.GetExtents(self, direction: int) -> Interval
Rhino.Geometry.PlaneSurface.SetExtents(self, direction: int, extents: Rhino.Geometry.Interval, syncDomain: bool) -> None
Rhino.Geometry.PlaneSurface.ToMesh(self) -> Mesh
Rhino.Geometry.PlaneSurface.__init__(self) -> None
Rhino.Geometry.PlaneSurface.__init__(self, info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext) -> None
Rhino.Geometry.PlaneSurface.__init__(self, plane: Rhino.Geometry.Plane) -> None
Rhino.Geometry.PlaneSurface.__init__(self, plane: Rhino.Geometry.Plane, xExtents: Rhino.Geometry.Interval, yExtents: Rhino.Geometry.Interval) -> None
Rhino.Geometry.Point.__init__(self, info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext) -> None
Rhino.Geometry.Point.__init__(self, location: Rhino.Geometry.Point3d) -> None
Rhino.Geometry.Point2d.!=(a: Rhino.Geometry.Point2d, b: Rhino.Geometry.Point2d) -> operator
Rhino.Geometry.Point2d.*(point: Rhino.Geometry.Point2d, t: float) -> operator
Rhino.Geometry.Point2d.*(t: float, point: Rhino.Geometry.Point2d) -> operator
Rhino.Geometry.Point2d.+(point1: Rhino.Geometry.Point2d, point2: Rhino.Geometry.Point2d) -> operator
Rhino.Geometry.Point2d.+(point: Rhino.Geometry.Point2d, vector: Rhino.Geometry.Vector2d) -> operator
Rhino.Geometry.Point2d.+(vector: Rhino.Geometry.Vector2d, point: Rhino.Geometry.Point2d) -> operator
Rhino.Geometry.Point2d.-(point1: Rhino.Geometry.Point2d, point2: Rhino.Geometry.Point2d) -> operator
Rhino.Geometry.Point2d.-(point: Rhino.Geometry.Point2d, vector: Rhino.Geometry.Vector2d) -> operator
Rhino.Geometry.Point2d./(point: Rhino.Geometry.Point2d, t: float) -> operator
Rhino.Geometry.Point2d.<(a: Rhino.Geometry.Point2d, b: Rhino.Geometry.Point2d) -> operator
Rhino.Geometry.Point2d.<=(a: Rhino.Geometry.Point2d, b: Rhino.Geometry.Point2d) -> operator
Rhino.Geometry.Point2d.==(a: Rhino.Geometry.Point2d, b: Rhino.Geometry.Point2d) -> operator
Rhino.Geometry.Point2d.>(a: Rhino.Geometry.Point2d, b: Rhino.Geometry.Point2d) -> operator
Rhino.Geometry.Point2d.>=(a: Rhino.Geometry.Point2d, b: Rhino.Geometry.Point2d) -> operator
Rhino.Geometry.Point2d.Add(point1: Rhino.Geometry.Point2d, point2: Rhino.Geometry.Point2d) -> Rhino.Geometry.Point2d
Rhino.Geometry.Point2d.Add(point: Rhino.Geometry.Point2d, vector: Rhino.Geometry.Vector2d) -> Rhino.Geometry.Point2d
Rhino.Geometry.Point2d.Add(vector: Rhino.Geometry.Vector2d, point: Rhino.Geometry.Point2d) -> Rhino.Geometry.Point2d
Rhino.Geometry.Point2d.CompareTo(self, other: Rhino.Geometry.Point2d) -> int
Rhino.Geometry.Point2d.DistanceTo(self, other: Rhino.Geometry.Point2d) -> float
Rhino.Geometry.Point2d.DistanceToSquared(self, other: Rhino.Geometry.Point2d) -> float
Rhino.Geometry.Point2d.Divide(point: Rhino.Geometry.Point2d, t: float) -> Rhino.Geometry.Point2d
Rhino.Geometry.Point2d.EpsilonEquals(self, other: Rhino.Geometry.Point2d, epsilon: float) -> bool
Rhino.Geometry.Point2d.Equals(self, obj: Any) -> bool
Rhino.Geometry.Point2d.Equals(self, point: Rhino.Geometry.Point2d) -> bool
Rhino.Geometry.Point2d.GetHashCode(self) -> int
Rhino.Geometry.Point2d.Multiply(point: Rhino.Geometry.Point2d, t: float) -> Rhino.Geometry.Point2d
Rhino.Geometry.Point2d.Multiply(t: float, point: Rhino.Geometry.Point2d) -> Rhino.Geometry.Point2d
Rhino.Geometry.Point2d.Subtract(point1: Rhino.Geometry.Point2d, point2: Rhino.Geometry.Point2d) -> Vector2d
Rhino.Geometry.Point2d.Subtract(point: Rhino.Geometry.Point2d, vector: Rhino.Geometry.Vector2d) -> Rhino.Geometry.Point2d
Rhino.Geometry.Point2d.ToString(self) -> str
Rhino.Geometry.Point2d.ToString(self, format: str, formatProvider: System.IFormatProvider) -> str
Rhino.Geometry.Point2d.Transform(self, xform: Rhino.Geometry.Transform) -> None
Rhino.Geometry.Point2d.__init__(self, point: Rhino.Geometry.Point2d) -> None
Rhino.Geometry.Point2d.__init__(self, point: Rhino.Geometry.Point3d) -> None
Rhino.Geometry.Point2d.__init__(self, vector: Rhino.Geometry.Vector2d) -> None
Rhino.Geometry.Point2d.__init__(self, x: float, y: float) -> None
Rhino.Geometry.Point2f.!=(a: Rhino.Geometry.Point2f, b: Rhino.Geometry.Point2f) -> operator
Rhino.Geometry.Point2f.*(a: Rhino.Geometry.Point2f, b: float) -> operator
Rhino.Geometry.Point2f.+(a: Rhino.Geometry.Point2f, b: Rhino.Geometry.Point2f) -> operator
Rhino.Geometry.Point2f.-(a: Rhino.Geometry.Point2f, b: Rhino.Geometry.Point2f) -> operator
Rhino.Geometry.Point2f./(a: Rhino.Geometry.Point2f, b: float) -> operator
Rhino.Geometry.Point2f.<(a: Rhino.Geometry.Point2f, b: Rhino.Geometry.Point2f) -> operator
Rhino.Geometry.Point2f.<=(a: Rhino.Geometry.Point2f, b: Rhino.Geometry.Point2f) -> operator
Rhino.Geometry.Point2f.==(a: Rhino.Geometry.Point2f, b: Rhino.Geometry.Point2f) -> operator
Rhino.Geometry.Point2f.>(a: Rhino.Geometry.Point2f, b: Rhino.Geometry.Point2f) -> operator
Rhino.Geometry.Point2f.>=(a: Rhino.Geometry.Point2f, b: Rhino.Geometry.Point2f) -> operator
Rhino.Geometry.Point2f.CompareTo(self, other: Rhino.Geometry.Point2f) -> int
Rhino.Geometry.Point2f.DistanceTo(self, other: Rhino.Geometry.Point2f) -> float
Rhino.Geometry.Point2f.DistanceToSquared(self, other: Rhino.Geometry.Point2f) -> float
Rhino.Geometry.Point2f.EpsilonEquals(self, other: Rhino.Geometry.Point2f, epsilon: float) -> bool
Rhino.Geometry.Point2f.Equals(self, obj: Any) -> bool
Rhino.Geometry.Point2f.Equals(self, point: Rhino.Geometry.Point2f) -> bool
Rhino.Geometry.Point2f.GetHashCode(self) -> int
Rhino.Geometry.Point2f.ToString(self) -> str
Rhino.Geometry.Point2f.ToString(self, format: str, formatProvider: System.IFormatProvider) -> str
Rhino.Geometry.Point2f.__init__(self, point: Rhino.Geometry.Point2d) -> None
Rhino.Geometry.Point2f.__init__(self, x: float, y: float) -> None
Rhino.Geometry.Point2f.__init__(self, x: float, y: float) -> None
Rhino.Geometry.Point3d.!=(a: Rhino.Geometry.Point3d, b: Rhino.Geometry.Point3d) -> operator
Rhino.Geometry.Point3d.*(point: Rhino.Geometry.Point3d, t: float) -> operator
Rhino.Geometry.Point3d.*(t: float, point: Rhino.Geometry.Point3d) -> operator
Rhino.Geometry.Point3d.+(point1: Rhino.Geometry.Point3d, point2: Rhino.Geometry.Point3d) -> operator
Rhino.Geometry.Point3d.+(point: Rhino.Geometry.Point3d, vector: Rhino.Geometry.Vector3d) -> operator
Rhino.Geometry.Point3d.+(point: Rhino.Geometry.Point3d, vector: Rhino.Geometry.Vector3f) -> operator
Rhino.Geometry.Point3d.+(vector: Rhino.Geometry.Vector3d, point: Rhino.Geometry.Point3d) -> operator
Rhino.Geometry.Point3d.-(point1: Rhino.Geometry.Point3d, point2: Rhino.Geometry.Point3d) -> operator
Rhino.Geometry.Point3d.-(point: Rhino.Geometry.Point3d) -> operator
Rhino.Geometry.Point3d.-(point: Rhino.Geometry.Point3d, vector: Rhino.Geometry.Vector3d) -> operator
Rhino.Geometry.Point3d./(point: Rhino.Geometry.Point3d, t: float) -> operator
Rhino.Geometry.Point3d.<(a: Rhino.Geometry.Point3d, b: Rhino.Geometry.Point3d) -> operator
Rhino.Geometry.Point3d.<=(a: Rhino.Geometry.Point3d, b: Rhino.Geometry.Point3d) -> operator
Rhino.Geometry.Point3d.==(a: Rhino.Geometry.Point3d, b: Rhino.Geometry.Point3d) -> operator
Rhino.Geometry.Point3d.>(a: Rhino.Geometry.Point3d, b: Rhino.Geometry.Point3d) -> operator
Rhino.Geometry.Point3d.>=(a: Rhino.Geometry.Point3d, b: Rhino.Geometry.Point3d) -> operator
Rhino.Geometry.Point3d.Add(point1: Rhino.Geometry.Point3d, point2: Rhino.Geometry.Point3d) -> Rhino.Geometry.Point3d
Rhino.Geometry.Point3d.Add(point: Rhino.Geometry.Point3d, vector: Rhino.Geometry.Vector3d) -> Rhino.Geometry.Point3d
Rhino.Geometry.Point3d.Add(point: Rhino.Geometry.Point3d, vector: Rhino.Geometry.Vector3f) -> Rhino.Geometry.Point3d
Rhino.Geometry.Point3d.Add(vector: Rhino.Geometry.Vector3d, point: Rhino.Geometry.Point3d) -> Rhino.Geometry.Point3d
Rhino.Geometry.Point3d.ArePointsCoplanar(points: Iterable[Rhino.Geometry.Point3d], tolerance: float) -> bool
Rhino.Geometry.Point3d.CompareTo(self, other: Rhino.Geometry.Point3d) -> int
Rhino.Geometry.Point3d.ControlPoint(pt: Rhino.Geometry.Point3d) -> operator
Rhino.Geometry.Point3d.CullDuplicates(points: Iterable[Rhino.Geometry.Point3d], tolerance: float) -> List[Rhino.Geometry.Point3d]
Rhino.Geometry.Point3d.DistanceTo(self, other: Rhino.Geometry.Point3d) -> float
Rhino.Geometry.Point3d.DistanceToSquared(self, other: Rhino.Geometry.Point3d) -> float
Rhino.Geometry.Point3d.Divide(point: Rhino.Geometry.Point3d, t: float) -> Rhino.Geometry.Point3d
Rhino.Geometry.Point3d.EpsilonEquals(self, other: Rhino.Geometry.Point3d, epsilon: float) -> bool
Rhino.Geometry.Point3d.Equals(self, obj: Any) -> bool
Rhino.Geometry.Point3d.Equals(self, point: Rhino.Geometry.Point3d) -> bool
Rhino.Geometry.Point3d.FromPoint3f(point: Rhino.Geometry.Point3f) -> Rhino.Geometry.Point3d
Rhino.Geometry.Point3d.GetHashCode(self) -> int
Rhino.Geometry.Point3d.Interpolate(self, pA: Rhino.Geometry.Point3d, pB: Rhino.Geometry.Point3d, t: float) -> None
Rhino.Geometry.Point3d.Multiply(point: Rhino.Geometry.Point3d, t: float) -> Rhino.Geometry.Point3d
Rhino.Geometry.Point3d.Multiply(t: float, point: Rhino.Geometry.Point3d) -> Rhino.Geometry.Point3d
Rhino.Geometry.Point3d.SortAndCullPointList(points: Iterable[Rhino.Geometry.Point3d], minimumDistance: float) -> List[Rhino.Geometry.Point3d]
Rhino.Geometry.Point3d.Subtract(point1: Rhino.Geometry.Point3d, point2: Rhino.Geometry.Point3d) -> Vector3d
Rhino.Geometry.Point3d.Subtract(point: Rhino.Geometry.Point3d, vector: Rhino.Geometry.Vector3d) -> Rhino.Geometry.Point3d
Rhino.Geometry.Point3d.ToString(self) -> str
Rhino.Geometry.Point3d.ToString(self, format: str, formatProvider: System.IFormatProvider) -> str
Rhino.Geometry.Point3d.Transform(self, xform: Rhino.Geometry.Transform) -> None
Rhino.Geometry.Point3d.TryParse(input: str, result: Rhino.Geometry.Point3d@) -> bool
Rhino.Geometry.Point3d.Vector3d(point: Rhino.Geometry.Point3d) -> operator
Rhino.Geometry.Point3d.__init__(self, point: Rhino.Geometry.Point3d) -> None
Rhino.Geometry.Point3d.__init__(self, point: Rhino.Geometry.Point3f) -> None
Rhino.Geometry.Point3d.__init__(self, point: Rhino.Geometry.Point3f) -> None
Rhino.Geometry.Point3d.__init__(self, point: Rhino.Geometry.Point4d) -> None
Rhino.Geometry.Point3d.__init__(self, vector: Rhino.Geometry.Vector3d) -> None
Rhino.Geometry.Point3d.__init__(self, vector: Rhino.Geometry.Vector3d) -> None
Rhino.Geometry.Point3d.__init__(self, x: float, y: float, z: float) -> None
Rhino.Geometry.Point3dGrid.__init__(self) -> None
Rhino.Geometry.Point3dGrid.__init__(self, info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext) -> None
Rhino.Geometry.Point3dGrid.__init__(self, rows: int, columns: int) -> None
Rhino.Geometry.Point3f.!=(a: Rhino.Geometry.Point3f, b: Rhino.Geometry.Point3f) -> operator
Rhino.Geometry.Point3f.*(point: Rhino.Geometry.Point3f, value: float) -> operator
Rhino.Geometry.Point3f.*(value: float, point: Rhino.Geometry.Point3f) -> operator
Rhino.Geometry.Point3f.+(point1: Rhino.Geometry.Point3f, point2: Rhino.Geometry.Point3f) -> operator
Rhino.Geometry.Point3f.-(point1: Rhino.Geometry.Point3f, point2: Rhino.Geometry.Point3f) -> operator
Rhino.Geometry.Point3f.<(a: Rhino.Geometry.Point3f, b: Rhino.Geometry.Point3f) -> operator
Rhino.Geometry.Point3f.<=(a: Rhino.Geometry.Point3f, b: Rhino.Geometry.Point3f) -> operator
Rhino.Geometry.Point3f.==(a: Rhino.Geometry.Point3f, b: Rhino.Geometry.Point3f) -> operator
Rhino.Geometry.Point3f.>(a: Rhino.Geometry.Point3f, b: Rhino.Geometry.Point3f) -> operator
Rhino.Geometry.Point3f.>=(a: Rhino.Geometry.Point3f, b: Rhino.Geometry.Point3f) -> operator
Rhino.Geometry.Point3f.CompareTo(self, other: Rhino.Geometry.Point3f) -> int
Rhino.Geometry.Point3f.DistanceTo(self, other: Rhino.Geometry.Point3f) -> float
Rhino.Geometry.Point3f.DistanceToSquared(self, other: Rhino.Geometry.Point3f) -> float
Rhino.Geometry.Point3f.EpsilonEquals(self, other: Rhino.Geometry.Point3f, epsilon: float) -> bool
Rhino.Geometry.Point3f.Equals(self, obj: Any) -> bool
Rhino.Geometry.Point3f.Equals(self, point: Rhino.Geometry.Point3f) -> bool
Rhino.Geometry.Point3f.GetHashCode(self) -> int
Rhino.Geometry.Point3f.Subtract(point1: Rhino.Geometry.Point3f, point2: Rhino.Geometry.Point3f) -> Vector3f
Rhino.Geometry.Point3f.ToString(self) -> str
Rhino.Geometry.Point3f.ToString(self, format: str, formatProvider: System.IFormatProvider) -> str
Rhino.Geometry.Point3f.Transform(self, xform: Rhino.Geometry.Transform) -> None
Rhino.Geometry.Point3f.Vector3f(point: Rhino.Geometry.Point3f) -> operator
Rhino.Geometry.Point3f.__init__(self, point: Rhino.Geometry.Point3d) -> None
Rhino.Geometry.Point3f.__init__(self, x: float, y: float, z: float) -> None
Rhino.Geometry.Point4d.!=(a: Rhino.Geometry.Point4d, b: Rhino.Geometry.Point4d) -> operator
Rhino.Geometry.Point4d.*(point1: Rhino.Geometry.Point4d, point2: Rhino.Geometry.Point4d) -> operator
Rhino.Geometry.Point4d.*(point: Rhino.Geometry.Point4d, d: float) -> operator
Rhino.Geometry.Point4d.+(point1: Rhino.Geometry.Point4d, point2: Rhino.Geometry.Point4d) -> operator
Rhino.Geometry.Point4d.-(point1: Rhino.Geometry.Point4d, point2: Rhino.Geometry.Point4d) -> operator
Rhino.Geometry.Point4d.==(a: Rhino.Geometry.Point4d, b: Rhino.Geometry.Point4d) -> operator
Rhino.Geometry.Point4d.Add(point1: Rhino.Geometry.Point4d, point2: Rhino.Geometry.Point4d) -> Rhino.Geometry.Point4d
Rhino.Geometry.Point4d.EpsilonEquals(self, other: Rhino.Geometry.Point4d, epsilon: float) -> bool
Rhino.Geometry.Point4d.Equals(self, obj: Any) -> bool
Rhino.Geometry.Point4d.Equals(self, point: Rhino.Geometry.Point4d) -> bool
Rhino.Geometry.Point4d.GetHashCode(self) -> int
Rhino.Geometry.Point4d.Multiply(point: Rhino.Geometry.Point4d, d: float) -> Rhino.Geometry.Point4d
Rhino.Geometry.Point4d.Subtract(point1: Rhino.Geometry.Point4d, point2: Rhino.Geometry.Point4d) -> Rhino.Geometry.Point4d
Rhino.Geometry.Point4d.ToString(self) -> str
Rhino.Geometry.Point4d.ToString(self, format: str, formatProvider: System.IFormatProvider) -> str
Rhino.Geometry.Point4d.Transform(self, xform: Rhino.Geometry.Transform) -> None
Rhino.Geometry.Point4d.__init__(self, point: Rhino.Geometry.Point3d) -> None
Rhino.Geometry.Point4d.__init__(self, point: Rhino.Geometry.Point4d) -> None
Rhino.Geometry.Point4d.__init__(self, x: float, y: float, z: float, w: float) -> None
Rhino.Geometry.PointCloud.Add(self, point: Rhino.Geometry.Point3d) -> None
Rhino.Geometry.PointCloud.Add(self, point: Rhino.Geometry.Point3d, color: System.Drawing.Color) -> None
Rhino.Geometry.PointCloud.Add(self, point: Rhino.Geometry.Point3d, normal: Rhino.Geometry.Vector3d) -> None
Rhino.Geometry.PointCloud.Add(self, point: Rhino.Geometry.Point3d, normal: Rhino.Geometry.Vector3d, color: System.Drawing.Color) -> None
Rhino.Geometry.PointCloud.Add(self, point: Rhino.Geometry.Point3d, normal: Rhino.Geometry.Vector3d, color: System.Drawing.Color, value: float) -> None
Rhino.Geometry.PointCloud.AddRange(self, points: Iterable[Rhino.Geometry.Point3d]) -> None
Rhino.Geometry.PointCloud.AddRange(self, points: Iterable[Rhino.Geometry.Point3d], colors: Iterable[System.Drawing.Color]) -> None
Rhino.Geometry.PointCloud.AddRange(self, points: Iterable[Rhino.Geometry.Point3d], normals: Iterable[Rhino.Geometry.Vector3d]) -> None
Rhino.Geometry.PointCloud.AddRange(self, points: Iterable[Rhino.Geometry.Point3d], normals: Iterable[Rhino.Geometry.Vector3d], colors: Iterable[System.Drawing.Color]) -> None
Rhino.Geometry.PointCloud.AddRange(self, points: Iterable[Rhino.Geometry.Point3d], normals: Iterable[Rhino.Geometry.Vector3d], colors: Iterable[System.Drawing.Color], values: Iterable[float]) -> None
Rhino.Geometry.PointCloud.AppendNew(self) -> PointCloudItem
Rhino.Geometry.PointCloud.AsReadOnlyListOfPoints(self) -> IReadOnlyList<Point3d>
Rhino.Geometry.PointCloud.ClearColors(self) -> None
Rhino.Geometry.PointCloud.ClearHiddenFlags(self) -> None
Rhino.Geometry.PointCloud.ClearNormals(self) -> None
Rhino.Geometry.PointCloud.ClearPointValues(self) -> None
Rhino.Geometry.PointCloud.ClosestPoint(self, testPoint: Rhino.Geometry.Point3d) -> int
Rhino.Geometry.PointCloud.CreateContourCurves(self, contourStart: Rhino.Geometry.Point3d, contourEnd: Rhino.Geometry.Point3d, interval: float, absoluteTolerance: float) -> List[Curve]
Rhino.Geometry.PointCloud.CreateContourCurves(self, startPoint: Rhino.Geometry.Point3d, endPoint: Rhino.Geometry.Point3d, interval: float, absoluteTolerance: float, maxDistance: float, minDistance: float, openCurves: bool, createSpline: bool, createPolyline: bool, fitTolerance: float) -> List[Curve]
Rhino.Geometry.PointCloud.CreateSectionCurve(self, plane: Rhino.Geometry.Plane, absoluteTolerance: float) -> List[Curve]
Rhino.Geometry.PointCloud.CreateSectionCurve(self, plane: Rhino.Geometry.Plane, absoluteTolerance: float, maxDistance: float, minDistance: float, openCurves: bool, createSpline: bool, createPolyline: bool, fitTolerance: float) -> List[Curve]
Rhino.Geometry.PointCloud.GetColors(self) -> List[Color]
Rhino.Geometry.PointCloud.GetEnumerator(self) -> IEnumerator<PointCloudItem>
Rhino.Geometry.PointCloud.GetNormals(self) -> List[Vector3d]
Rhino.Geometry.PointCloud.GetPointValues(self) -> List[float]
Rhino.Geometry.PointCloud.GetPoints(self) -> List[Point3d]
Rhino.Geometry.PointCloud.GetRandomSubsample(self, numberOfPoints: System.UInt32) -> Rhino.Geometry.PointCloud
Rhino.Geometry.PointCloud.GetRandomSubsample(self, numberOfPoints: System.UInt32, cancelToken: System.Threading.CancellationToken, progress: IProgress[float]) -> Rhino.Geometry.PointCloud
Rhino.Geometry.PointCloud.GetUnsafeLock(self, writable: bool) -> PointCloudUnsafeLock
Rhino.Geometry.PointCloud.Insert(self, index: int, point: Rhino.Geometry.Point3d) -> None
Rhino.Geometry.PointCloud.Insert(self, index: int, point: Rhino.Geometry.Point3d, color: System.Drawing.Color) -> None
Rhino.Geometry.PointCloud.Insert(self, index: int, point: Rhino.Geometry.Point3d, normal: Rhino.Geometry.Vector3d) -> None
Rhino.Geometry.PointCloud.Insert(self, index: int, point: Rhino.Geometry.Point3d, normal: Rhino.Geometry.Vector3d, color: System.Drawing.Color) -> None
Rhino.Geometry.PointCloud.Insert(self, index: int, point: Rhino.Geometry.Point3d, normal: Rhino.Geometry.Vector3d, color: System.Drawing.Color, value: float) -> None
Rhino.Geometry.PointCloud.InsertNew(self, index: int) -> PointCloudItem
Rhino.Geometry.PointCloud.InsertRange(self, index: int, points: Iterable[Rhino.Geometry.Point3d]) -> None
Rhino.Geometry.PointCloud.Merge(self, other: Rhino.Geometry.PointCloud) -> None
Rhino.Geometry.PointCloud.PointAt(self, index: int) -> Point3d
Rhino.Geometry.PointCloud.ReleaseUnsafeLock(self, pointCloudData: Rhino.Geometry.PointCloudUnsafeLock) -> None
Rhino.Geometry.PointCloud.RemoveAt(self, index: int) -> None
Rhino.Geometry.PointCloud.RemoveRange(self, indices: Iterable[int]) -> int
Rhino.Geometry.PointCloud.ShrinkWrap(self, parameters: Rhino.Geometry.ShrinkWrapParameters) -> Mesh
Rhino.Geometry.PointCloud.__init__(self) -> None
Rhino.Geometry.PointCloud.__init__(self, info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext) -> None
Rhino.Geometry.PointCloud.__init__(self, other: Rhino.Geometry.PointCloud) -> None
Rhino.Geometry.PointCloud.__init__(self, points: Iterable[Rhino.Geometry.Point3d]) -> None
Rhino.Geometry.PointCloudUnsafeLock.ColorArray(self, length: System.Int32@) -> int*
Rhino.Geometry.PointCloudUnsafeLock.NormalArray(self, length: System.Int32@) -> Vector3d*
Rhino.Geometry.PointCloudUnsafeLock.PointArray(self, length: System.Int32@) -> Point3d*
Rhino.Geometry.PointCloudUnsafeLock.Release(self) -> None
Rhino.Geometry.PointCloudUnsafeLock.ValueArray(self, length: System.Int32@) -> double*
Rhino.Geometry.PolyCurve.Append(self, arc: Rhino.Geometry.Arc) -> bool
Rhino.Geometry.PolyCurve.Append(self, curve: Rhino.Geometry.Curve) -> bool
Rhino.Geometry.PolyCurve.Append(self, line: Rhino.Geometry.Line) -> bool
Rhino.Geometry.PolyCurve.AppendSegment(self, curve: Rhino.Geometry.Curve) -> bool
Rhino.Geometry.PolyCurve.CleanUp(self) -> Curve
Rhino.Geometry.PolyCurve.Duplicate(self) -> GeometryBase
Rhino.Geometry.PolyCurve.DuplicatePolyCurve(self) -> Rhino.Geometry.PolyCurve
Rhino.Geometry.PolyCurve.Explode(self) -> List[Curve]
Rhino.Geometry.PolyCurve.PolyCurveParameter(self, segmentIndex: int, segmentCurveParameter: float) -> float
Rhino.Geometry.PolyCurve.RemoveNesting(self) -> bool
Rhino.Geometry.PolyCurve.SegmentCurve(self, index: int) -> Curve
Rhino.Geometry.PolyCurve.SegmentCurveParameter(self, polycurveParameter: float) -> float
Rhino.Geometry.PolyCurve.SegmentDomain(self, segmentIndex: int) -> Interval
Rhino.Geometry.PolyCurve.SegmentIndex(self, polycurveParameter: float) -> int
Rhino.Geometry.PolyCurve.SegmentIndexes(self, subdomain: Rhino.Geometry.Interval, segmentIndex0: System.Int32@, segmentIndex1: System.Int32@) -> int
Rhino.Geometry.PolyCurve.__init__(self) -> None
Rhino.Geometry.PolyCurve.__init__(self, info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext) -> None
Rhino.Geometry.Polyline.BreakAtAngles(self, angle: float) -> List[Rhino.Geometry.Polyline]
Rhino.Geometry.Polyline.CenterPoint(self) -> Point3d
Rhino.Geometry.Polyline.ClosestParameter(self, testPoint: Rhino.Geometry.Point3d) -> float
Rhino.Geometry.Polyline.ClosestPoint(self, testPoint: Rhino.Geometry.Point3d) -> Point3d
Rhino.Geometry.Polyline.CollapseShortSegments(self, tolerance: float) -> int
Rhino.Geometry.Polyline.CreateByJoiningLines(lines: Iterable[Rhino.Geometry.Line], tolerance: float, splitAtIntersections: bool) -> List[Rhino.Geometry.Polyline]
Rhino.Geometry.Polyline.CreateCircumscribedPolygon(circle: Rhino.Geometry.Circle, sideCount: int) -> Rhino.Geometry.Polyline
Rhino.Geometry.Polyline.CreateInscribedPolygon(circle: Rhino.Geometry.Circle, sideCount: int) -> Rhino.Geometry.Polyline
Rhino.Geometry.Polyline.CreateStarPolygon(circle: Rhino.Geometry.Circle, radius: float, cornerCount: int) -> Rhino.Geometry.Polyline
Rhino.Geometry.Polyline.DeleteShortSegments(self, tolerance: float) -> int
Rhino.Geometry.Polyline.Duplicate(self) -> Rhino.Geometry.Polyline
Rhino.Geometry.Polyline.GetSegments(self) -> List[Line]
Rhino.Geometry.Polyline.IsClosedWithinTolerance(self, tolerance: float) -> bool
Rhino.Geometry.Polyline.MergeColinearSegments(self, angleTolerance: float, includeSeam: bool) -> int
Rhino.Geometry.Polyline.PointAt(self, t: float) -> Point3d
Rhino.Geometry.Polyline.ReduceSegments(self, tolerance: float) -> int
Rhino.Geometry.Polyline.RemoveNearlyEqualSubsequentPoints(self, tolerance: float) -> None
Rhino.Geometry.Polyline.SegmentAt(self, index: int) -> Line
Rhino.Geometry.Polyline.Smooth(self, amount: float) -> bool
Rhino.Geometry.Polyline.TangentAt(self, t: float) -> Vector3d
Rhino.Geometry.Polyline.ToNurbsCurve(self) -> NurbsCurve
Rhino.Geometry.Polyline.ToPolylineCurve(self) -> PolylineCurve
Rhino.Geometry.Polyline.TriangulateClosedPolyline(self) -> List[MeshFace]
Rhino.Geometry.Polyline.Trim(self, domain: Rhino.Geometry.Interval) -> Rhino.Geometry.Polyline
Rhino.Geometry.Polyline.__init__(self) -> None
Rhino.Geometry.Polyline.__init__(self, collection: Iterable[Rhino.Geometry.Point3d]) -> None
Rhino.Geometry.Polyline.__init__(self, initialCapacity: int) -> None
Rhino.Geometry.PolylineCurve.CreateConvexHull2d(points: List[Rhino.Geometry.Point2d], hullIndices: System.Int32[]@) -> Rhino.Geometry.PolylineCurve
Rhino.Geometry.PolylineCurve.Parameter(self, index: int) -> float
Rhino.Geometry.PolylineCurve.Point(self, index: int) -> Point3d
Rhino.Geometry.PolylineCurve.SetArcLengthParameterization(self, tolerance: float) -> None
Rhino.Geometry.PolylineCurve.SetParameter(self, index: int, parameter: float) -> None
Rhino.Geometry.PolylineCurve.SetPoint(self, index: int, point: Rhino.Geometry.Point3d) -> None
Rhino.Geometry.PolylineCurve.ToArray(self) -> List[Point3d]
Rhino.Geometry.PolylineCurve.ToPolyline(self) -> Polyline
Rhino.Geometry.PolylineCurve.__init__(self) -> None
Rhino.Geometry.PolylineCurve.__init__(self, info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext) -> None
Rhino.Geometry.PolylineCurve.__init__(self, other: Rhino.Geometry.PolylineCurve) -> None
Rhino.Geometry.PolylineCurve.__init__(self, points: Iterable[Rhino.Geometry.Point3d]) -> None
Rhino.Geometry.QuadRemeshParameters.__init__(self) -> None
Rhino.Geometry.Quaternion.!=(a: Rhino.Geometry.Quaternion, b: Rhino.Geometry.Quaternion) -> operator
Rhino.Geometry.Quaternion.*(a: Rhino.Geometry.Quaternion, b: Rhino.Geometry.Quaternion) -> operator
Rhino.Geometry.Quaternion.*(q: Rhino.Geometry.Quaternion, x: float) -> operator
Rhino.Geometry.Quaternion.*(q: Rhino.Geometry.Quaternion, x: float) -> operator
Rhino.Geometry.Quaternion.*(q: Rhino.Geometry.Quaternion, x: int) -> operator
Rhino.Geometry.Quaternion.+(a: Rhino.Geometry.Quaternion, b: Rhino.Geometry.Quaternion) -> operator
Rhino.Geometry.Quaternion.-(a: Rhino.Geometry.Quaternion, b: Rhino.Geometry.Quaternion) -> operator
Rhino.Geometry.Quaternion./(q: Rhino.Geometry.Quaternion, y: float) -> operator
Rhino.Geometry.Quaternion.==(a: Rhino.Geometry.Quaternion, b: Rhino.Geometry.Quaternion) -> operator
Rhino.Geometry.Quaternion.CreateFromRotationZYX(yaw: float, pitch: float, roll: float) -> Rhino.Geometry.Quaternion
Rhino.Geometry.Quaternion.CreateFromRotationZYZ(alpha: float, beta: float, gamma: float) -> Rhino.Geometry.Quaternion
Rhino.Geometry.Quaternion.CrossProduct(p: Rhino.Geometry.Quaternion, q: Rhino.Geometry.Quaternion) -> Rhino.Geometry.Quaternion
Rhino.Geometry.Quaternion.Distance(p: Rhino.Geometry.Quaternion, q: Rhino.Geometry.Quaternion) -> float
Rhino.Geometry.Quaternion.DistanceTo(self, q: Rhino.Geometry.Quaternion) -> float
Rhino.Geometry.Quaternion.EpsilonEquals(self, other: Rhino.Geometry.Quaternion, epsilon: float) -> bool
Rhino.Geometry.Quaternion.Equals(self, obj: Any) -> bool
Rhino.Geometry.Quaternion.Equals(self, other: Rhino.Geometry.Quaternion) -> bool
Rhino.Geometry.Quaternion.GetEulerZYZ(self, alpha: System.Double@, beta: System.Double@, gamma: System.Double@) -> bool
Rhino.Geometry.Quaternion.GetHashCode(self) -> int
Rhino.Geometry.Quaternion.GetRotation(self, angle: System.Double@, axis: Rhino.Geometry.Vector3d@) -> bool
Rhino.Geometry.Quaternion.GetRotation(self, plane: Rhino.Geometry.Plane@) -> bool
Rhino.Geometry.Quaternion.GetRotation(self, xform: Rhino.Geometry.Transform@) -> bool
Rhino.Geometry.Quaternion.GetYawPitchRoll(self, yaw: System.Double@, pitch: System.Double@, roll: System.Double@) -> bool
Rhino.Geometry.Quaternion.Invert(self) -> bool
Rhino.Geometry.Quaternion.Lerp(a: Rhino.Geometry.Quaternion, b: Rhino.Geometry.Quaternion, t: float) -> Rhino.Geometry.Quaternion
Rhino.Geometry.Quaternion.MatrixForm(self) -> Transform
Rhino.Geometry.Quaternion.Product(p: Rhino.Geometry.Quaternion, q: Rhino.Geometry.Quaternion) -> Rhino.Geometry.Quaternion
Rhino.Geometry.Quaternion.Rotate(self, v: Rhino.Geometry.Vector3d) -> Vector3d
Rhino.Geometry.Quaternion.RotateTowards(a: Rhino.Geometry.Quaternion, b: Rhino.Geometry.Quaternion, maxRadians: float) -> Rhino.Geometry.Quaternion
Rhino.Geometry.Quaternion.Rotation(angle: float, axisOfRotation: Rhino.Geometry.Vector3d) -> Rhino.Geometry.Quaternion
Rhino.Geometry.Quaternion.Rotation(plane0: Rhino.Geometry.Plane, plane1: Rhino.Geometry.Plane) -> Rhino.Geometry.Quaternion
Rhino.Geometry.Quaternion.Set(self, a: float, b: float, c: float, d: float) -> None
Rhino.Geometry.Quaternion.SetRotation(self, angle: float, axisOfRotation: Rhino.Geometry.Vector3d) -> None
Rhino.Geometry.Quaternion.SetRotation(self, plane0: Rhino.Geometry.Plane, plane1: Rhino.Geometry.Plane) -> None
Rhino.Geometry.Quaternion.Slerp(a: Rhino.Geometry.Quaternion, b: Rhino.Geometry.Quaternion, t: float) -> Rhino.Geometry.Quaternion
Rhino.Geometry.Quaternion.ToString(self) -> str
Rhino.Geometry.Quaternion.Unitize(self) -> bool
Rhino.Geometry.Quaternion.__init__(self, a: float, b: float, c: float, d: float) -> None
Rhino.Geometry.RTree.Clear(self) -> None
Rhino.Geometry.RTree.CreateFromPointArray(points: Iterable[Rhino.Geometry.Point3d]) -> Rhino.Geometry.RTree
Rhino.Geometry.RTree.CreateMeshFaceTree(mesh: Rhino.Geometry.Mesh) -> Rhino.Geometry.RTree
Rhino.Geometry.RTree.CreatePointCloudTree(cloud: Rhino.Geometry.PointCloud) -> Rhino.Geometry.RTree
Rhino.Geometry.RTree.Dispose(self) -> None
Rhino.Geometry.RTree.Dispose(self, disposing: bool) -> None
Rhino.Geometry.RTree.Finalize(self) -> None
Rhino.Geometry.RTree.Insert(self, box: Rhino.Geometry.BoundingBox, elementId: System.IntPtr) -> bool
Rhino.Geometry.RTree.Insert(self, box: Rhino.Geometry.BoundingBox, elementId: int) -> bool
Rhino.Geometry.RTree.Insert(self, point: Rhino.Geometry.Point2d, elementId: System.IntPtr) -> bool
Rhino.Geometry.RTree.Insert(self, point: Rhino.Geometry.Point2d, elementId: int) -> bool
Rhino.Geometry.RTree.Insert(self, point: Rhino.Geometry.Point3d, elementId: System.IntPtr) -> bool
Rhino.Geometry.RTree.Insert(self, point: Rhino.Geometry.Point3d, elementId: int) -> bool
Rhino.Geometry.RTree.Point3dClosestPoints(hayPoints: Iterable[Rhino.Geometry.Point3d], needlePts: Iterable[Rhino.Geometry.Point3d], limitDistance: float) -> IEnumerable<int[]>
Rhino.Geometry.RTree.Point3dKNeighbors(hayPoints: Iterable[Rhino.Geometry.Point3d], needlePts: Iterable[Rhino.Geometry.Point3d], amount: int) -> IEnumerable<int[]>
Rhino.Geometry.RTree.PointCloudClosestPoints(pointcloud: Rhino.Geometry.PointCloud, needlePts: Iterable[Rhino.Geometry.Point3d], limitDistance: float) -> IEnumerable<int[]>
Rhino.Geometry.RTree.PointCloudKNeighbors(pointcloud: Rhino.Geometry.PointCloud, needlePts: Iterable[Rhino.Geometry.Point3d], amount: int) -> IEnumerable<int[]>
Rhino.Geometry.RTree.Remove(self, box: Rhino.Geometry.BoundingBox, elementId: System.IntPtr) -> bool
Rhino.Geometry.RTree.Remove(self, box: Rhino.Geometry.BoundingBox, elementId: int) -> bool
Rhino.Geometry.RTree.Remove(self, point: Rhino.Geometry.Point2d, elementId: int) -> bool
Rhino.Geometry.RTree.Remove(self, point: Rhino.Geometry.Point3d, elementId: System.IntPtr) -> bool
Rhino.Geometry.RTree.Remove(self, point: Rhino.Geometry.Point3d, elementId: int) -> bool
Rhino.Geometry.RTree.Search(self, box: Rhino.Geometry.BoundingBox, callback: EventHandler[Rhino.Geometry.RTreeEventArgs]) -> bool
Rhino.Geometry.RTree.Search(self, box: Rhino.Geometry.BoundingBox, callback: EventHandler[Rhino.Geometry.RTreeEventArgs], tag: Any) -> bool
Rhino.Geometry.RTree.Search(self, sphere: Rhino.Geometry.Sphere, callback: EventHandler[Rhino.Geometry.RTreeEventArgs]) -> bool
Rhino.Geometry.RTree.Search(self, sphere: Rhino.Geometry.Sphere, callback: EventHandler[Rhino.Geometry.RTreeEventArgs], tag: Any) -> bool
Rhino.Geometry.RTree.SearchOverlaps(treeA: Rhino.Geometry.RTree, treeB: Rhino.Geometry.RTree, tolerance: float, callback: EventHandler[Rhino.Geometry.RTreeEventArgs]) -> bool
Rhino.Geometry.RTree.__init__(self) -> None
Rhino.Geometry.RadialDimension.AdjustFromPoints(self, plane: Rhino.Geometry.Plane, centerpoint: Rhino.Geometry.Point3d, radiuspoint: Rhino.Geometry.Point3d, dimlinepoint: Rhino.Geometry.Point3d, rotationInPlane: float) -> bool
Rhino.Geometry.RadialDimension.Create(dimStyle: Rhino.DocObjects.DimensionStyle, dimtype: Rhino.Geometry.AnnotationType, plane: Rhino.Geometry.Plane, centerpoint: Rhino.Geometry.Point3d, radiuspoint: Rhino.Geometry.Point3d, dimlinepoint: Rhino.Geometry.Point3d) -> Rhino.Geometry.RadialDimension
Rhino.Geometry.RadialDimension.Get3dPoints(self, centerpoint: Rhino.Geometry.Point3d@, radiuspoint: Rhino.Geometry.Point3d@, dimlinepoint: Rhino.Geometry.Point3d@, kneepoint: Rhino.Geometry.Point3d@) -> bool
Rhino.Geometry.RadialDimension.GetDisplayLines(self, style: Rhino.DocObjects.DimensionStyle, scale: float, lines: System.Collections.Generic.IEnumerable{Rhino.Geometry.Line}@) -> bool
Rhino.Geometry.RadialDimension.GetDistanceDisplayText(self, unitsystem: Rhino.UnitSystem, style: Rhino.DocObjects.DimensionStyle) -> str
Rhino.Geometry.RadialDimension.GetTextRectangle(self, corners: Rhino.Geometry.Point3d[]@) -> bool
Rhino.Geometry.RadialDimension.__init__(self) -> None
Rhino.Geometry.RadialDimension.__init__(self, dimtype: Rhino.Geometry.AnnotationType, plane: Rhino.Geometry.Plane, centerpoint: Rhino.Geometry.Point3d, radiuspoint: Rhino.Geometry.Point3d, dimlinepoint: Rhino.Geometry.Point3d) -> None
Rhino.Geometry.RadialDimension.__init__(self, info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext) -> None
Rhino.Geometry.Ray3d.!=(a: Rhino.Geometry.Ray3d, b: Rhino.Geometry.Ray3d) -> operator
Rhino.Geometry.Ray3d.==(a: Rhino.Geometry.Ray3d, b: Rhino.Geometry.Ray3d) -> operator
Rhino.Geometry.Ray3d.EpsilonEquals(self, other: Rhino.Geometry.Ray3d, epsilon: float) -> bool
Rhino.Geometry.Ray3d.Equals(self, obj: Any) -> bool
Rhino.Geometry.Ray3d.Equals(self, ray: Rhino.Geometry.Ray3d) -> bool
Rhino.Geometry.Ray3d.GetHashCode(self) -> int
Rhino.Geometry.Ray3d.PointAt(self, t: float) -> Point3d
Rhino.Geometry.Ray3d.__init__(self, position: Rhino.Geometry.Point3d, direction: Rhino.Geometry.Vector3d) -> None
Rhino.Geometry.Rectangle3d.ClosestPoint(self, point: Rhino.Geometry.Point3d) -> Point3d
Rhino.Geometry.Rectangle3d.ClosestPoint(self, point: Rhino.Geometry.Point3d, includeInterior: bool) -> Point3d
Rhino.Geometry.Rectangle3d.Contains(self, pt: Rhino.Geometry.Point3d) -> PointContainment
Rhino.Geometry.Rectangle3d.Contains(self, x: float, y: float) -> PointContainment
Rhino.Geometry.Rectangle3d.Corner(self, index: int) -> Point3d
Rhino.Geometry.Rectangle3d.CreateFromPolyline(polyline: Iterable[Rhino.Geometry.Point3d]) -> Rhino.Geometry.Rectangle3d
Rhino.Geometry.Rectangle3d.CreateFromPolyline(polyline: Iterable[Rhino.Geometry.Point3d], deviation: System.Double@, angleDeviation: System.Double@) -> Rhino.Geometry.Rectangle3d
Rhino.Geometry.Rectangle3d.EpsilonEquals(self, other: Rhino.Geometry.Rectangle3d, epsilon: float) -> bool
Rhino.Geometry.Rectangle3d.MakeIncreasing(self) -> None
Rhino.Geometry.Rectangle3d.PointAt(self, t: float) -> Point3d
Rhino.Geometry.Rectangle3d.PointAt(self, x: float, y: float) -> Point3d
Rhino.Geometry.Rectangle3d.RecenterPlane(self, index: int) -> None
Rhino.Geometry.Rectangle3d.RecenterPlane(self, origin: Rhino.Geometry.Point3d) -> None
Rhino.Geometry.Rectangle3d.ToNurbsCurve(self) -> NurbsCurve
Rhino.Geometry.Rectangle3d.ToPolyline(self) -> Polyline
Rhino.Geometry.Rectangle3d.Transform(self, xform: Rhino.Geometry.Transform) -> bool
Rhino.Geometry.Rectangle3d.__init__(self, plane: Rhino.Geometry.Plane, cornerA: Rhino.Geometry.Point3d, cornerB: Rhino.Geometry.Point3d) -> None
Rhino.Geometry.Rectangle3d.__init__(self, plane: Rhino.Geometry.Plane, width: Rhino.Geometry.Interval, height: Rhino.Geometry.Interval) -> None
Rhino.Geometry.Rectangle3d.__init__(self, plane: Rhino.Geometry.Plane, width: float, height: float) -> None
Rhino.Geometry.ReduceMeshParameters.__init__(self) -> None
Rhino.Geometry.RevSurface.Create(revoluteCurve: Rhino.Geometry.Curve, axisOfRevolution: Rhino.Geometry.Line) -> Rhino.Geometry.RevSurface
Rhino.Geometry.RevSurface.Create(revoluteCurve: Rhino.Geometry.Curve, axisOfRevolution: Rhino.Geometry.Line, startAngleRadians: float, endAngleRadians: float) -> Rhino.Geometry.RevSurface
Rhino.Geometry.RevSurface.Create(revoluteLine: Rhino.Geometry.Line, axisOfRevolution: Rhino.Geometry.Line) -> Rhino.Geometry.RevSurface
Rhino.Geometry.RevSurface.Create(revoluteLine: Rhino.Geometry.Line, axisOfRevolution: Rhino.Geometry.Line, startAngleRadians: float, endAngleRadians: float) -> Rhino.Geometry.RevSurface
Rhino.Geometry.RevSurface.Create(revolutePolyline: Rhino.Geometry.Polyline, axisOfRevolution: Rhino.Geometry.Line) -> Rhino.Geometry.RevSurface
Rhino.Geometry.RevSurface.Create(revolutePolyline: Rhino.Geometry.Polyline, axisOfRevolution: Rhino.Geometry.Line, startAngleRadians: float, endAngleRadians: float) -> Rhino.Geometry.RevSurface
Rhino.Geometry.RevSurface.CreateFromCone(cone: Rhino.Geometry.Cone) -> Rhino.Geometry.RevSurface
Rhino.Geometry.RevSurface.CreateFromCylinder(cylinder: Rhino.Geometry.Cylinder) -> Rhino.Geometry.RevSurface
Rhino.Geometry.RevSurface.CreateFromSphere(sphere: Rhino.Geometry.Sphere) -> Rhino.Geometry.RevSurface
Rhino.Geometry.RevSurface.CreateFromTorus(torus: Rhino.Geometry.Torus) -> Rhino.Geometry.RevSurface
Rhino.Geometry.RevSurface.__init__(self, info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext) -> None
Rhino.Geometry.RibbonOffsetParameters.__init__(self) -> None
Rhino.Geometry.ShrinkWrapParameters.__init__(self) -> None
Rhino.Geometry.ShutLiningCurveInfo.__init__(self, curve: Rhino.Geometry.Curve, radius: float, profile: int, pull: bool, isBump: bool, curveIntervals: Iterable[Rhino.Geometry.Interval], enabled: bool) -> None
Rhino.Geometry.Silhouette.Compute(geometry: Rhino.Geometry.GeometryBase, silhouetteType: Rhino.Geometry.SilhouetteType, parallelCameraDirection: Rhino.Geometry.Vector3d, tolerance: float, angleToleranceRadians: float) -> List[Rhino.Geometry.Silhouette]
Rhino.Geometry.Silhouette.Compute(geometry: Rhino.Geometry.GeometryBase, silhouetteType: Rhino.Geometry.SilhouetteType, parallelCameraDirection: Rhino.Geometry.Vector3d, tolerance: float, angleToleranceRadians: float, clippingPlanes: Iterable[Rhino.Geometry.Plane], cancelToken: System.Threading.CancellationToken) -> List[Rhino.Geometry.Silhouette]
Rhino.Geometry.Silhouette.Compute(geometry: Rhino.Geometry.GeometryBase, silhouetteType: Rhino.Geometry.SilhouetteType, perspectiveCameraLocation: Rhino.Geometry.Point3d, tolerance: float, angleToleranceRadians: float) -> List[Rhino.Geometry.Silhouette]
Rhino.Geometry.Silhouette.Compute(geometry: Rhino.Geometry.GeometryBase, silhouetteType: Rhino.Geometry.SilhouetteType, perspectiveCameraLocation: Rhino.Geometry.Point3d, tolerance: float, angleToleranceRadians: float, clippingPlanes: Iterable[Rhino.Geometry.Plane], cancelToken: System.Threading.CancellationToken) -> List[Rhino.Geometry.Silhouette]
Rhino.Geometry.Silhouette.Compute(geometry: Rhino.Geometry.GeometryBase, silhouetteType: Rhino.Geometry.SilhouetteType, viewport: Rhino.DocObjects.ViewportInfo, tolerance: float, angleToleranceRadians: float) -> List[Rhino.Geometry.Silhouette]
Rhino.Geometry.Silhouette.Compute(geometry: Rhino.Geometry.GeometryBase, silhouetteType: Rhino.Geometry.SilhouetteType, viewport: Rhino.DocObjects.ViewportInfo, tolerance: float, angleToleranceRadians: float, clippingPlanes: Iterable[Rhino.Geometry.Plane], cancelToken: System.Threading.CancellationToken) -> List[Rhino.Geometry.Silhouette]
Rhino.Geometry.Silhouette.ComputeDraftCurve(geometry: Rhino.Geometry.GeometryBase, draftAngle: float, pullDirection: Rhino.Geometry.Vector3d, tolerance: float, angleToleranceRadians: float) -> List[Rhino.Geometry.Silhouette]
Rhino.Geometry.Silhouette.ComputeDraftCurve(geometry: Rhino.Geometry.GeometryBase, draftAngle: float, pullDirection: Rhino.Geometry.Vector3d, tolerance: float, angleToleranceRadians: float, cancelToken: System.Threading.CancellationToken) -> List[Rhino.Geometry.Silhouette]
Rhino.Geometry.SpaceMorph.IsMorphable(geometry: Rhino.Geometry.GeometryBase) -> bool
Rhino.Geometry.SpaceMorph.Morph(self, geometry: Rhino.Geometry.GeometryBase) -> bool
Rhino.Geometry.SpaceMorph.Morph(self, plane: Rhino.Geometry.Plane@) -> bool
Rhino.Geometry.SpaceMorph.MorphPoint(self, point: Rhino.Geometry.Point3d) -> Point3d
Rhino.Geometry.SpaceMorph.__init__(self) -> None
Rhino.Geometry.Sphere.ClosestParameter(self, testPoint: Rhino.Geometry.Point3d, longitudeRadians: System.Double@, latitudeRadians: System.Double@) -> bool
Rhino.Geometry.Sphere.ClosestPoint(self, testPoint: Rhino.Geometry.Point3d) -> Point3d
Rhino.Geometry.Sphere.EpsilonEquals(self, other: Rhino.Geometry.Sphere, epsilon: float) -> bool
Rhino.Geometry.Sphere.FitSphereToPoints(points: Iterable[Rhino.Geometry.Point3d]) -> Rhino.Geometry.Sphere
Rhino.Geometry.Sphere.LatitudeDegrees(self, degrees: float) -> Circle
Rhino.Geometry.Sphere.LatitudeRadians(self, radians: float) -> Circle
Rhino.Geometry.Sphere.LongitudeDegrees(self, degrees: float) -> Circle
Rhino.Geometry.Sphere.LongitudeRadians(self, radians: float) -> Circle
Rhino.Geometry.Sphere.NormalAt(self, longitudeRadians: float, latitudeRadians: float) -> Vector3d
Rhino.Geometry.Sphere.PointAt(self, longitudeRadians: float, latitudeRadians: float) -> Point3d
Rhino.Geometry.Sphere.Rotate(self, angleRadians: float, axisOfRotation: Rhino.Geometry.Vector3d) -> bool
Rhino.Geometry.Sphere.Rotate(self, angleRadians: float, axisOfRotation: Rhino.Geometry.Vector3d, centerOfRotation: Rhino.Geometry.Point3d) -> bool
Rhino.Geometry.Sphere.Rotate(self, sinAngle: float, cosAngle: float, axisOfRotation: Rhino.Geometry.Vector3d) -> bool
Rhino.Geometry.Sphere.Rotate(self, sinAngle: float, cosAngle: float, axisOfRotation: Rhino.Geometry.Vector3d, centerOfRotation: Rhino.Geometry.Point3d) -> bool
Rhino.Geometry.Sphere.ToBrep(self) -> Brep
Rhino.Geometry.Sphere.ToNurbsSurface(self) -> NurbsSurface
Rhino.Geometry.Sphere.ToRevSurface(self) -> RevSurface
Rhino.Geometry.Sphere.Transform(self, xform: Rhino.Geometry.Transform) -> bool
Rhino.Geometry.Sphere.Translate(self, delta: Rhino.Geometry.Vector3d) -> bool
Rhino.Geometry.Sphere.__init__(self, center: Rhino.Geometry.Point3d, radius: float) -> None
Rhino.Geometry.Sphere.__init__(self, equatorialPlane: Rhino.Geometry.Plane, radius: float) -> None
Rhino.Geometry.SquishParameters.Dispose(self) -> None
Rhino.Geometry.SquishParameters.Dispose(self, disposing: bool) -> None
Rhino.Geometry.SquishParameters.Finalize(self) -> None
Rhino.Geometry.SquishParameters.GetSpringConstants(self, boundaryBias: System.Double@, deformationBias: System.Double@) -> bool
Rhino.Geometry.SquishParameters.SetDeformation(self, deformation: Rhino.Geometry.SquishDeformation, bPreserveBoundary: bool, boundaryStretchConstant: float, boundaryCompressConstant: float, interiorStretchConstant: float, interiorCompressConstant: float) -> None
Rhino.Geometry.SquishParameters.SetSpringConstants(self, boundaryBias: float, deformationBias: float) -> None
Rhino.Geometry.SquishParameters.__init__(self) -> None
Rhino.Geometry.Squisher.Dispose(self) -> None
Rhino.Geometry.Squisher.Dispose(self, disposing: bool) -> None
Rhino.Geometry.Squisher.Finalize(self) -> None
Rhino.Geometry.Squisher.Get2dMesh(self) -> Mesh
Rhino.Geometry.Squisher.Get3dMesh(self) -> Mesh
Rhino.Geometry.Squisher.GetAreaConstrainedTrianglesIndices(self) -> List[MeshFace]
Rhino.Geometry.Squisher.GetLengthConstrained2dLines(self) -> List[Line]
Rhino.Geometry.Squisher.GetLengthConstrained3dLines(self) -> List[Line]
Rhino.Geometry.Squisher.GetMesh2dEdges(self) -> List[Line]
Rhino.Geometry.Squisher.GetMesh3dEdges(self) -> List[Line]
Rhino.Geometry.Squisher.Is2dPatternSquished(geometry: Rhino.Geometry.GeometryBase) -> bool
Rhino.Geometry.Squisher.SquishBack2dMarks(squishedGeometry: Rhino.Geometry.GeometryBase, marks: Iterable[Rhino.Geometry.GeometryBase]) -> IEnumerable<GeometryBase>
Rhino.Geometry.Squisher.SquishCurve(self, curve: Rhino.Geometry.Curve) -> PolylineCurve
Rhino.Geometry.Squisher.SquishMesh(self, sp: Rhino.Geometry.SquishParameters, mesh3d: Rhino.Geometry.Mesh) -> Mesh
Rhino.Geometry.Squisher.SquishMesh(self, sp: Rhino.Geometry.SquishParameters, mesh3d: Rhino.Geometry.Mesh, marks: Iterable[Rhino.Geometry.GeometryBase], squished_marks_out: List[Rhino.Geometry.GeometryBase]) -> Mesh
Rhino.Geometry.Squisher.SquishPoint(self, point: Rhino.Geometry.Point3d, squishedPoint: Rhino.Geometry.Point3d@) -> bool
Rhino.Geometry.Squisher.SquishSurface(self, sp: Rhino.Geometry.SquishParameters, surface: Rhino.Geometry.Surface) -> Brep
Rhino.Geometry.Squisher.SquishSurface(self, sp: Rhino.Geometry.SquishParameters, surface: Rhino.Geometry.Surface, marks: Iterable[Rhino.Geometry.GeometryBase], squished_marks_out: List[Rhino.Geometry.GeometryBase]) -> Brep
Rhino.Geometry.Squisher.SquishTextDot(self, textDot: Rhino.Geometry.TextDot) -> TextDot
Rhino.Geometry.Squisher.__init__(self) -> None
Rhino.Geometry.SubD.ClearEvaluationCache(self) -> None
Rhino.Geometry.SubD.ComponentFromComponentIndex(self, componentIndex: Rhino.Geometry.ComponentIndex) -> SubDComponent
Rhino.Geometry.SubD.CopyEvaluationCache(self, src: Rhino.Geometry.SubD@) -> bool
Rhino.Geometry.SubD.CreateFromCylinder(cylinder: Rhino.Geometry.Cylinder, circumferenceFaceCount: System.UInt32, heightFaceCount: System.UInt32, endCapStyle: Rhino.Geometry.SubDEndCapStyle, endCapEdgeTag: Rhino.Geometry.SubDEdgeTag, radiusLocation: Rhino.Geometry.SubDComponentLocation) -> Rhino.Geometry.SubD
Rhino.Geometry.SubD.CreateFromLoft(curves: Iterable[Rhino.Geometry.NurbsCurve], closed: bool, addCorners: bool, addCreases: bool, divisions: int) -> Rhino.Geometry.SubD
Rhino.Geometry.SubD.CreateFromMesh(mesh: Rhino.Geometry.Mesh) -> Rhino.Geometry.SubD
Rhino.Geometry.SubD.CreateFromMesh(mesh: Rhino.Geometry.Mesh, options: Rhino.Geometry.SubDCreationOptions) -> Rhino.Geometry.SubD
Rhino.Geometry.SubD.CreateFromSurface(surface: Rhino.Geometry.Surface, method: Rhino.Geometry.SubDFromSurfaceMethods, corners: bool) -> Rhino.Geometry.SubD
Rhino.Geometry.SubD.CreateFromSweep(rail1: Rhino.Geometry.NurbsCurve, rail2: Rhino.Geometry.NurbsCurve, shapes: Iterable[Rhino.Geometry.NurbsCurve], closed: bool, addCorners: bool) -> Rhino.Geometry.SubD
Rhino.Geometry.SubD.CreateFromSweep(rail1: Rhino.Geometry.NurbsCurve, shapes: Iterable[Rhino.Geometry.NurbsCurve], closed: bool, addCorners: bool, roadlikeFrame: bool, roadlikeNormal: Rhino.Geometry.Vector3d) -> Rhino.Geometry.SubD
Rhino.Geometry.SubD.CreateGlobeSphere(sphere: Rhino.Geometry.Sphere, vertexLocation: Rhino.Geometry.SubDComponentLocation, axialFaceCount: System.UInt32, equatorialFaceCount: System.UInt32) -> Rhino.Geometry.SubD
Rhino.Geometry.SubD.CreateIcosahedron(sphere: Rhino.Geometry.Sphere, vertexLocation: Rhino.Geometry.SubDComponentLocation) -> Rhino.Geometry.SubD
Rhino.Geometry.SubD.CreateQuadSphere(sphere: Rhino.Geometry.Sphere, vertexLocation: Rhino.Geometry.SubDComponentLocation, quadSubdivisionLevel: System.UInt32) -> Rhino.Geometry.SubD
Rhino.Geometry.SubD.CreateTriSphere(sphere: Rhino.Geometry.Sphere, vertexLocation: Rhino.Geometry.SubDComponentLocation, triSubdivisionLevel: System.UInt32) -> Rhino.Geometry.SubD
Rhino.Geometry.SubD.Dispose(self, disposing: bool) -> None
Rhino.Geometry.SubD.DuplicateEdgeCurves(self) -> List[Curve]
Rhino.Geometry.SubD.DuplicateEdgeCurves(self, boundaryOnly: bool, interiorOnly: bool, smoothOnly: bool, sharpOnly: bool, creaseOnly: bool, clampEnds: bool) -> List[Curve]
Rhino.Geometry.SubD.Flip(self) -> bool
Rhino.Geometry.SubD.InterpolateSurfacePoints(self, surfacePoints: List[Rhino.Geometry.Point3d]) -> bool
Rhino.Geometry.SubD.InterpolateSurfacePoints(self, vertexIndices: List[System.UInt32], surfacePoints: List[Rhino.Geometry.Point3d]) -> bool
Rhino.Geometry.SubD.JoinSubDs(subdsToJoin: Iterable[Rhino.Geometry.SubD], tolerance: float, joinedEdgesAreCreases: bool) -> List[Rhino.Geometry.SubD]
Rhino.Geometry.SubD.JoinSubDs(subdsToJoin: Iterable[Rhino.Geometry.SubD], tolerance: float, joinedEdgesAreCreases: bool, preserveSymmetry: bool) -> List[Rhino.Geometry.SubD]
Rhino.Geometry.SubD.MergeAllCoplanarFaces(self, tolerance: float) -> bool
Rhino.Geometry.SubD.MergeAllCoplanarFaces(self, tolerance: float, angleTolerance: float) -> bool
Rhino.Geometry.SubD.NonConstOperation(self) -> None
Rhino.Geometry.SubD.Offset(self, distance: float, solidify: bool) -> Rhino.Geometry.SubD
Rhino.Geometry.SubD.OnSwitchToNonConst(self) -> None
Rhino.Geometry.SubD.PackFaces(self) -> uint
Rhino.Geometry.SubD.SetVertexSurfacePoint(self, vertexIndex: System.UInt32, surfacePoint: Rhino.Geometry.Point3d) -> bool
Rhino.Geometry.SubD.Subdivide(self) -> bool
Rhino.Geometry.SubD.Subdivide(self, count: int) -> bool
Rhino.Geometry.SubD.Subdivide(self, faceIndices: Iterable[int]) -> bool
Rhino.Geometry.SubD.SurfaceMeshCacheExists(self, bTextureCoordinatesExist: bool, bCurvaturesExist: bool, bColorsExist: bool) -> bool
Rhino.Geometry.SubD.ToBrep(self) -> Brep
Rhino.Geometry.SubD.ToBrep(self, options: Rhino.Geometry.SubDToBrepOptions) -> Brep
Rhino.Geometry.SubD.TransformComponents(self, components: Iterable[Rhino.Geometry.ComponentIndex], xform: Rhino.Geometry.Transform, componentLocation: Rhino.Geometry.SubDComponentLocation) -> uint
Rhino.Geometry.SubD.UpdateAllTagsAndSectorCoefficients(self) -> uint
Rhino.Geometry.SubD.UpdateSurfaceMeshCache(self, lazyUpdate: bool) -> uint
Rhino.Geometry.SubD.__init__(self) -> None
Rhino.Geometry.SubD.__init__(self, info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext) -> None
Rhino.Geometry.SubDCreationOptions.Dispose(self) -> None
Rhino.Geometry.SubDCreationOptions.Finalize(self) -> None
Rhino.Geometry.SubDCreationOptions.__init__(self) -> None
Rhino.Geometry.SubDDisplayParameters.AbsoluteDisplayDensityFromSubD(adaptiveSubDDisplayDensity: System.UInt32, subd: Rhino.Geometry.SubD) -> uint
Rhino.Geometry.SubDDisplayParameters.AbsoluteDisplayDensityFromSubDFaceCount(adaptiveSubDDisplayDensity: System.UInt32, subDFaceCount: System.UInt32) -> uint
Rhino.Geometry.SubDDisplayParameters.ClampDisplayDensity(displayDensity: System.UInt32) -> uint
Rhino.Geometry.SubDDisplayParameters.Coarse() -> Rhino.Geometry.SubDDisplayParameters
Rhino.Geometry.SubDDisplayParameters.CreateFromAbsoluteDisplayDensity(absoluteSubDDisplayDensity: System.UInt32) -> Rhino.Geometry.SubDDisplayParameters
Rhino.Geometry.SubDDisplayParameters.CreateFromDisplayDensity(adaptiveSubDDisplayDensity: System.UInt32) -> Rhino.Geometry.SubDDisplayParameters
Rhino.Geometry.SubDDisplayParameters.CreateFromMeshDensity(normalizedMeshDensity: float) -> Rhino.Geometry.SubDDisplayParameters
Rhino.Geometry.SubDDisplayParameters.Default() -> Rhino.Geometry.SubDDisplayParameters
Rhino.Geometry.SubDDisplayParameters.DisplayDensity(self, subd: Rhino.Geometry.SubD) -> uint
Rhino.Geometry.SubDDisplayParameters.Dispose(self) -> None
Rhino.Geometry.SubDDisplayParameters.Dispose(self, disposing: bool) -> None
Rhino.Geometry.SubDDisplayParameters.Empty() -> Rhino.Geometry.SubDDisplayParameters
Rhino.Geometry.SubDDisplayParameters.ExtraCoarse() -> Rhino.Geometry.SubDDisplayParameters
Rhino.Geometry.SubDDisplayParameters.ExtraFine() -> Rhino.Geometry.SubDDisplayParameters
Rhino.Geometry.SubDDisplayParameters.Finalize(self) -> None
Rhino.Geometry.SubDDisplayParameters.Fine() -> Rhino.Geometry.SubDDisplayParameters
Rhino.Geometry.SubDDisplayParameters.FromEncodedString(value: str) -> Rhino.Geometry.SubDDisplayParameters
Rhino.Geometry.SubDDisplayParameters.GetObjectData(self, info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext) -> None
Rhino.Geometry.SubDDisplayParameters.Medium() -> Rhino.Geometry.SubDDisplayParameters
Rhino.Geometry.SubDDisplayParameters.SetAbsoluteDisplayDensity(self, absoluteDisplayDensity: System.UInt32) -> None
Rhino.Geometry.SubDDisplayParameters.SetAdaptiveDisplayDensity(self, adaptiveDisplayDensity: System.UInt32) -> None
Rhino.Geometry.SubDDisplayParameters.ToEncodedString(self) -> str
Rhino.Geometry.SubDDisplayParameters.__init__(self) -> None
Rhino.Geometry.SubDDisplayParameters.__init__(self, info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext) -> None
Rhino.Geometry.SubDEdge.ComponentIndex(self) -> ComponentIndex
Rhino.Geometry.SubDEdge.FaceAt(self, index: int) -> SubDFace
Rhino.Geometry.SubDEdge.ToNurbsCurve(self, clampEnds: bool) -> NurbsCurve
Rhino.Geometry.SubDFace.ComponentIndex(self) -> ComponentIndex
Rhino.Geometry.SubDFace.EdgeAt(self, index: int) -> SubDEdge
Rhino.Geometry.SubDFace.EdgeDirectionMatchesFaceOrientation(self, index: int) -> bool
Rhino.Geometry.SubDFace.VertexAt(self, index: int) -> SubDVertex
Rhino.Geometry.SubDSurfaceInterpolator.Clear(self) -> None
Rhino.Geometry.SubDSurfaceInterpolator.CreateFromMarkedVertices(subd: Rhino.Geometry.SubD, interpolatedVerticesMark: bool, freeVertexCount: System.UInt32@) -> Rhino.Geometry.SubDSurfaceInterpolator
Rhino.Geometry.SubDSurfaceInterpolator.CreateFromSelectedVertices(subd: Rhino.Geometry.SubD, freeVertexCount: System.UInt32@) -> Rhino.Geometry.SubDSurfaceInterpolator
Rhino.Geometry.SubDSurfaceInterpolator.CreateFromSubD(subd: Rhino.Geometry.SubD, freeVertexCount: System.UInt32@) -> Rhino.Geometry.SubDSurfaceInterpolator
Rhino.Geometry.SubDSurfaceInterpolator.CreateFromVertexIdList(subd: Rhino.Geometry.SubD, vertexIndices: Iterable[System.UInt32], freeVertexCount: System.UInt32@) -> Rhino.Geometry.SubDSurfaceInterpolator
Rhino.Geometry.SubDSurfaceInterpolator.Dispose(self) -> None
Rhino.Geometry.SubDSurfaceInterpolator.Dispose(self, disposing: bool) -> None
Rhino.Geometry.SubDSurfaceInterpolator.Finalize(self) -> None
Rhino.Geometry.SubDSurfaceInterpolator.FixedVertexCount(self) -> uint
Rhino.Geometry.SubDSurfaceInterpolator.InterpolatedVertexCount(self) -> uint
Rhino.Geometry.SubDSurfaceInterpolator.InterpolatedVertexIndex(self, vertexId: System.UInt32) -> uint
Rhino.Geometry.SubDSurfaceInterpolator.IsInterpolatedVertex(self, vertex: Rhino.Geometry.SubDVertex) -> bool
Rhino.Geometry.SubDSurfaceInterpolator.IsInterpolatedVertex(self, vertexId: System.UInt32) -> bool
Rhino.Geometry.SubDSurfaceInterpolator.Solve(self, surfacePoints: List[Rhino.Geometry.Point3d]) -> bool
Rhino.Geometry.SubDSurfaceInterpolator.Transform(self, transform: Rhino.Geometry.Transform) -> None
Rhino.Geometry.SubDSurfaceInterpolator.VertexIdList(self) -> List[uint]
Rhino.Geometry.SubDSurfaceInterpolator.__init__(self) -> None
Rhino.Geometry.SubDToBrepOptions.Dispose(self) -> None
Rhino.Geometry.SubDToBrepOptions.Dispose(self, disposing: bool) -> None
Rhino.Geometry.SubDToBrepOptions.Finalize(self) -> None
Rhino.Geometry.SubDToBrepOptions.__init__(self) -> None
Rhino.Geometry.SubDToBrepOptions.__init__(self, packFaces: bool, arg2: Rhino.Geometry.SubDToBrepOptions.ExtraordinaryVertexProcessOption) -> None
Rhino.Geometry.SubDVertex.EdgeAt(self, index: int) -> SubDEdge
Rhino.Geometry.SubDVertex.FaceAt(self, index: int) -> SubDFace
Rhino.Geometry.SubDVertex.SetControlNetPoint(self, position: Rhino.Geometry.Point3d, bClearNeighborhoodCache: bool) -> bool
Rhino.Geometry.SubDVertex.SurfacePoint(self) -> Point3d
Rhino.Geometry.SumSurface.Create(curve: Rhino.Geometry.Curve, extrusionDirection: Rhino.Geometry.Vector3d) -> Rhino.Geometry.SumSurface
Rhino.Geometry.SumSurface.Create(curveA: Rhino.Geometry.Curve, curveB: Rhino.Geometry.Curve) -> Rhino.Geometry.SumSurface
Rhino.Geometry.SumSurface.__init__(self, info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext) -> None
Rhino.Geometry.Surface.ClosestPoint(self, testPoint: Rhino.Geometry.Point3d, u: System.Double@, v: System.Double@) -> bool
Rhino.Geometry.Surface.ClosestSide(self, u: float, v: float) -> IsoStatus
Rhino.Geometry.Surface.CreateExtrusion(profile: Rhino.Geometry.Curve, direction: Rhino.Geometry.Vector3d) -> Rhino.Geometry.Surface
Rhino.Geometry.Surface.CreateExtrusionToPoint(profile: Rhino.Geometry.Curve, apexPoint: Rhino.Geometry.Point3d) -> Rhino.Geometry.Surface
Rhino.Geometry.Surface.CreatePeriodicSurface(surface: Rhino.Geometry.Surface, direction: int) -> Rhino.Geometry.Surface
Rhino.Geometry.Surface.CreatePeriodicSurface(surface: Rhino.Geometry.Surface, direction: int, bSmooth: bool) -> Rhino.Geometry.Surface
Rhino.Geometry.Surface.CreateRollingBallFillet(surfaceA: Rhino.Geometry.Surface, flipA: bool, surfaceB: Rhino.Geometry.Surface, flipB: bool, radius: float, tolerance: float) -> List[Rhino.Geometry.Surface]
Rhino.Geometry.Surface.CreateRollingBallFillet(surfaceA: Rhino.Geometry.Surface, surfaceB: Rhino.Geometry.Surface, radius: float, tolerance: float) -> List[Rhino.Geometry.Surface]
Rhino.Geometry.Surface.CreateRollingBallFillet(surfaceA: Rhino.Geometry.Surface, uvA: Rhino.Geometry.Point2d, surfaceB: Rhino.Geometry.Surface, uvB: Rhino.Geometry.Point2d, radius: float, tolerance: float) -> List[Rhino.Geometry.Surface]
Rhino.Geometry.Surface.CreateSoftEditSurface(surface: Rhino.Geometry.Surface, uv: Rhino.Geometry.Point2d, delta: Rhino.Geometry.Vector3d, uLength: float, vLength: float, tolerance: float, fixEnds: bool) -> Rhino.Geometry.Surface
Rhino.Geometry.Surface.CreateTweenSurfacesWithSampling(surface0: Rhino.Geometry.Surface, surface1: Rhino.Geometry.Surface, numSurfaces: int, numSamples: int, tolerance: float) -> List[Rhino.Geometry.Surface]
Rhino.Geometry.Surface.CurvatureAt(self, u: float, v: float) -> SurfaceCurvature
Rhino.Geometry.Surface.Degree(self, direction: int) -> int
Rhino.Geometry.Surface.Domain(self, direction: int) -> Interval
Rhino.Geometry.Surface.Evaluate(self, u: float, v: float, numberDerivatives: int, point: Rhino.Geometry.Point3d@, derivatives: Rhino.Geometry.Vector3d[]@) -> bool
Rhino.Geometry.Surface.Extend(self, direction: int, interval: Rhino.Geometry.Interval) -> bool
Rhino.Geometry.Surface.Extend(self, edge: Rhino.Geometry.IsoStatus, extensionLength: float, smooth: bool) -> Rhino.Geometry.Surface
Rhino.Geometry.Surface.Fit(self, uDegree: int, vDegree: int, fitTolerance: float) -> Rhino.Geometry.Surface
Rhino.Geometry.Surface.FitCurveToSurface(self, trimCurve3d: Rhino.Geometry.Curve, trimProjectionDir: Rhino.Geometry.Vector3d, tolerance: float, Knots: Iterable[float], divideIntoSections: bool, trimCurveOnSurface: Rhino.Geometry.Curve@, splitCurve: Rhino.Geometry.Curve@) -> List[Curve]
Rhino.Geometry.Surface.FrameAt(self, u: float, v: float, frame: Rhino.Geometry.Plane@) -> bool
Rhino.Geometry.Surface.GetNextDiscontinuity(self, direction: int, continuityType: Rhino.Geometry.Continuity, t0: float, t1: float, cosAngleTolerance: float, curvatureTolerance: float, t: System.Double@) -> bool
Rhino.Geometry.Surface.GetNextDiscontinuity(self, direction: int, continuityType: Rhino.Geometry.Continuity, t0: float, t1: float, t: System.Double@) -> bool
Rhino.Geometry.Surface.GetNurbsFormParameterFromSurfaceParameter(self, surfaceS: float, surfaceT: float, nurbsS: System.Double@, nurbsT: System.Double@) -> bool
Rhino.Geometry.Surface.GetSpanVector(self, direction: int) -> List[float]
Rhino.Geometry.Surface.GetSurfaceParameterFromNurbsFormParameter(self, nurbsS: float, nurbsT: float, surfaceS: System.Double@, surfaceT: System.Double@) -> bool
Rhino.Geometry.Surface.GetSurfaceSize(self, width: System.Double@, height: System.Double@) -> bool
Rhino.Geometry.Surface.HasNurbsForm(self) -> int
Rhino.Geometry.Surface.InterpolatedCurveOnSurface(self, points: Iterable[Rhino.Geometry.Point3d], tolerance: float) -> NurbsCurve
Rhino.Geometry.Surface.InterpolatedCurveOnSurfaceUV(self, points: Iterable[Rhino.Geometry.Point2d], tolerance: float) -> NurbsCurve
Rhino.Geometry.Surface.InterpolatedCurveOnSurfaceUV(self, points: Iterable[Rhino.Geometry.Point2d], tolerance: float, closed: bool, closedSurfaceHandling: int) -> NurbsCurve
Rhino.Geometry.Surface.IsAtSeam(self, u: float, v: float) -> int
Rhino.Geometry.Surface.IsAtSingularity(self, u: float, v: float, exact: bool) -> bool
Rhino.Geometry.Surface.IsClosed(self, direction: int) -> bool
Rhino.Geometry.Surface.IsCone(self) -> bool
Rhino.Geometry.Surface.IsCone(self, tolerance: float) -> bool
Rhino.Geometry.Surface.IsContinuous(self, continuityType: Rhino.Geometry.Continuity, u: float, v: float) -> bool
Rhino.Geometry.Surface.IsCylinder(self) -> bool
Rhino.Geometry.Surface.IsCylinder(self, tolerance: float) -> bool
Rhino.Geometry.Surface.IsIsoparametric(self, bbox: Rhino.Geometry.BoundingBox) -> IsoStatus
Rhino.Geometry.Surface.IsIsoparametric(self, curve: Rhino.Geometry.Curve) -> IsoStatus
Rhino.Geometry.Surface.IsIsoparametric(self, curve: Rhino.Geometry.Curve, curveDomain: Rhino.Geometry.Interval) -> IsoStatus
Rhino.Geometry.Surface.IsPeriodic(self, direction: int) -> bool
Rhino.Geometry.Surface.IsPlanar(self) -> bool
Rhino.Geometry.Surface.IsPlanar(self, tolerance: float) -> bool
Rhino.Geometry.Surface.IsSingular(self, side: int) -> bool
Rhino.Geometry.Surface.IsSphere(self) -> bool
Rhino.Geometry.Surface.IsSphere(self, tolerance: float) -> bool
Rhino.Geometry.Surface.IsTorus(self) -> bool
Rhino.Geometry.Surface.IsTorus(self, tolerance: float) -> bool
Rhino.Geometry.Surface.IsoCurve(self, direction: int, constantParameter: float) -> Curve
Rhino.Geometry.Surface.LocalClosestPoint(self, testPoint: Rhino.Geometry.Point3d, seedU: float, seedV: float, u: System.Double@, v: System.Double@) -> bool
Rhino.Geometry.Surface.NormalAt(self, u: float, v: float) -> Vector3d
Rhino.Geometry.Surface.Offset(self, distance: float, tolerance: float) -> Rhino.Geometry.Surface
Rhino.Geometry.Surface.PointAt(self, u: float, v: float) -> Point3d
Rhino.Geometry.Surface.Pullback(self, curve3d: Rhino.Geometry.Curve, tolerance: float) -> Curve
Rhino.Geometry.Surface.Pullback(self, curve3d: Rhino.Geometry.Curve, tolerance: float, curve3dSubdomain: Rhino.Geometry.Interval) -> Curve
Rhino.Geometry.Surface.Pushup(self, curve2d: Rhino.Geometry.Curve, tolerance: float) -> Curve
Rhino.Geometry.Surface.Pushup(self, curve2d: Rhino.Geometry.Curve, tolerance: float, curve2dSubdomain: Rhino.Geometry.Interval) -> Curve
Rhino.Geometry.Surface.Rebuild(self, uDegree: int, vDegree: int, uPointCount: int, vPointCount: int) -> NurbsSurface
Rhino.Geometry.Surface.RebuildOneDirection(self, direction: int, pointCount: int, loftType: Rhino.Geometry.LoftType, refitTolerance: float) -> NurbsSurface
Rhino.Geometry.Surface.RefitSimplySplitSurface(self, trimCurve3d: Rhino.Geometry.Curve, trimProjectionDir: Rhino.Geometry.Vector3d, tolerance: float, knotAdditionMode: Rhino.Geometry.RefitTrimKnotMode, numInsertKnots: int, Knots: Iterable[float], sectionMode: Rhino.Geometry.RefitTrimSectionMode, numNonTrimSpans: int, meetCurve: bool, oneSided: bool, PtActive: Rhino.Geometry.Point3d, outputSurface: bool, outputCurve: bool, numSections: System.Int32@, lowerSurface: List[Rhino.Geometry.Surface], upperSurface: List[Rhino.Geometry.Surface], edgeCurve: List[Rhino.Geometry.Curve], FitMeasurement: System.Double@, trimCurveOnSurface: Rhino.Geometry.Curve@, splitCurve: Rhino.Geometry.Curve@) -> bool
Rhino.Geometry.Surface.RefitSplit(self, curve: Rhino.Geometry.Curve, trimProjectionDir: Rhino.Geometry.Vector3d, tolerance: float, Knots: Iterable[float], bMeetCurve: bool, divideIntoSections: bool, srfLower: List[Rhino.Geometry.Surface], srfUpper: List[Rhino.Geometry.Surface], edgeCurve: List[Rhino.Geometry.Curve], trimCurveOnSurface: Rhino.Geometry.Curve@, splitCurve: Rhino.Geometry.Curve@) -> int
Rhino.Geometry.Surface.Reverse(self, direction: int) -> Rhino.Geometry.Surface
Rhino.Geometry.Surface.Reverse(self, direction: int, inPlace: bool) -> Rhino.Geometry.Surface
Rhino.Geometry.Surface.SetDomain(self, direction: int, domain: Rhino.Geometry.Interval) -> bool
Rhino.Geometry.Surface.ShortPath(self, start: Rhino.Geometry.Point2d, end: Rhino.Geometry.Point2d, tolerance: float) -> Curve
Rhino.Geometry.Surface.Smooth(self, smoothFactor: float, bXSmooth: bool, bYSmooth: bool, bZSmooth: bool, bFixBoundaries: bool, coordinateSystem: Rhino.Geometry.SmoothingCoordinateSystem) -> Rhino.Geometry.Surface
Rhino.Geometry.Surface.Smooth(self, smoothFactor: float, bXSmooth: bool, bYSmooth: bool, bZSmooth: bool, bFixBoundaries: bool, coordinateSystem: Rhino.Geometry.SmoothingCoordinateSystem, plane: Rhino.Geometry.Plane) -> Rhino.Geometry.Surface
Rhino.Geometry.Surface.SpanCount(self, direction: int) -> int
Rhino.Geometry.Surface.Split(self, direction: int, parameter: float) -> List[Rhino.Geometry.Surface]
Rhino.Geometry.Surface.ToBrep(self) -> Brep
Rhino.Geometry.Surface.ToNurbsSurface(self) -> NurbsSurface
Rhino.Geometry.Surface.ToNurbsSurface(self, tolerance: float, accuracy: System.Int32@) -> NurbsSurface
Rhino.Geometry.Surface.Transpose(self) -> Rhino.Geometry.Surface
Rhino.Geometry.Surface.Transpose(self, inPlace: bool) -> Rhino.Geometry.Surface
Rhino.Geometry.Surface.Trim(self, u: Rhino.Geometry.Interval, v: Rhino.Geometry.Interval) -> Rhino.Geometry.Surface
Rhino.Geometry.Surface.TryGetCone(self, cone: Rhino.Geometry.Cone@) -> bool
Rhino.Geometry.Surface.TryGetCone(self, cone: Rhino.Geometry.Cone@, tolerance: float) -> bool
Rhino.Geometry.Surface.TryGetCylinder(self, cylinder: Rhino.Geometry.Cylinder@) -> bool
Rhino.Geometry.Surface.TryGetCylinder(self, cylinder: Rhino.Geometry.Cylinder@, tolerance: float) -> bool
Rhino.Geometry.Surface.TryGetFiniteCylinder(self, cylinder: Rhino.Geometry.Cylinder@, tolerance: float) -> bool
Rhino.Geometry.Surface.TryGetPlane(self, plane: Rhino.Geometry.Plane@) -> bool
Rhino.Geometry.Surface.TryGetPlane(self, plane: Rhino.Geometry.Plane@, tolerance: float) -> bool
Rhino.Geometry.Surface.TryGetSphere(self, sphere: Rhino.Geometry.Sphere@) -> bool
Rhino.Geometry.Surface.TryGetSphere(self, sphere: Rhino.Geometry.Sphere@, tolerance: float) -> bool
Rhino.Geometry.Surface.TryGetTorus(self, torus: Rhino.Geometry.Torus@) -> bool
Rhino.Geometry.Surface.TryGetTorus(self, torus: Rhino.Geometry.Torus@, tolerance: float) -> bool
Rhino.Geometry.Surface.VariableOffset(self, uMinvMin: float, uMinvMax: float, uMaxvMin: float, uMaxvMax: float, interiorParameters: Iterable[Rhino.Geometry.Point2d], interiorDistances: Iterable[float], tolerance: float) -> Rhino.Geometry.Surface
Rhino.Geometry.Surface.VariableOffset(self, uMinvMin: float, uMinvMax: float, uMaxvMin: float, uMaxvMax: float, tolerance: float) -> Rhino.Geometry.Surface
Rhino.Geometry.Surface.__init__(self) -> None
Rhino.Geometry.Surface.__init__(self, info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext) -> None
Rhino.Geometry.SurfaceCurvature.Direction(self, direction: int) -> Vector3d
Rhino.Geometry.SurfaceCurvature.Kappa(self, direction: int) -> float
Rhino.Geometry.SurfaceCurvature.OsculatingCircle(self, direction: int) -> Circle
Rhino.Geometry.SurfaceFilletBase.ChangeFilletRadius(self, radius: float) -> bool
Rhino.Geometry.SurfaceFilletBase.CreateG2ChordalQuinticFilletSrf(faceA: Rhino.Geometry.BrepFace, uvA: Rhino.Geometry.Point2d, faceB: Rhino.Geometry.BrepFace, uvB: Rhino.Geometry.Point2d, radius: float, tolerance: float, trimmedBrepsA: List[Rhino.Geometry.Brep], trimmedBrepsB: List[Rhino.Geometry.Brep], rail_degree: int, bTrim: bool, bExtend: bool, Fillets: List[Rhino.Geometry.Brep]) -> bool
Rhino.Geometry.SurfaceFilletBase.CreateNonRationalCubicArcsFilletSrf(faceA: Rhino.Geometry.BrepFace, uvA: Rhino.Geometry.Point2d, faceB: Rhino.Geometry.BrepFace, uvB: Rhino.Geometry.Point2d, radius: float, tolerance: float, trimmedBrepsA: List[Rhino.Geometry.Brep], trimmedBrepsB: List[Rhino.Geometry.Brep], rail_degree: int, bTrim: bool, bExtend: bool, Fillets: List[Rhino.Geometry.Brep]) -> bool
Rhino.Geometry.SurfaceFilletBase.CreateNonRationalCubicFilletSrf(faceA: Rhino.Geometry.BrepFace, uvA: Rhino.Geometry.Point2d, faceB: Rhino.Geometry.BrepFace, uvB: Rhino.Geometry.Point2d, radius: float, tolerance: float, trimmedBrepsA: List[Rhino.Geometry.Brep], trimmedBrepsB: List[Rhino.Geometry.Brep], rail_degree: int, TanSlider: float, bTrim: bool, bExtend: bool, Fillets: List[Rhino.Geometry.Brep]) -> bool
Rhino.Geometry.SurfaceFilletBase.CreateNonRationalQuarticArcsFilletSrf(faceA: Rhino.Geometry.BrepFace, uvA: Rhino.Geometry.Point2d, faceB: Rhino.Geometry.BrepFace, uvB: Rhino.Geometry.Point2d, radius: float, tolerance: float, trimmedBrepsA: List[Rhino.Geometry.Brep], trimmedBrepsB: List[Rhino.Geometry.Brep], rail_degree: int, bTrim: bool, bExtend: bool, Fillets: List[Rhino.Geometry.Brep]) -> bool
Rhino.Geometry.SurfaceFilletBase.CreateNonRationalQuarticFilletSrf(faceA: Rhino.Geometry.BrepFace, uvA: Rhino.Geometry.Point2d, faceB: Rhino.Geometry.BrepFace, uvB: Rhino.Geometry.Point2d, radius: float, tolerance: float, trimmedBrepsA: List[Rhino.Geometry.Brep], trimmedBrepsB: List[Rhino.Geometry.Brep], rail_degree: int, TanSlider: float, InnerSlider: float, bTrim: bool, bExtend: bool, Fillets: List[Rhino.Geometry.Brep]) -> bool
Rhino.Geometry.SurfaceFilletBase.CreateNonRationalQuinticArcsFilletSrf(faceA: Rhino.Geometry.BrepFace, uvA: Rhino.Geometry.Point2d, faceB: Rhino.Geometry.BrepFace, uvB: Rhino.Geometry.Point2d, radius: float, tolerance: float, trimmedBrepsA: List[Rhino.Geometry.Brep], trimmedBrepsB: List[Rhino.Geometry.Brep], rail_degree: int, bTrim: bool, bExtend: bool, Fillets: List[Rhino.Geometry.Brep]) -> bool
Rhino.Geometry.SurfaceFilletBase.CreateNonRationalQuinticFilletSrf(faceA: Rhino.Geometry.BrepFace, uvA: Rhino.Geometry.Point2d, faceB: Rhino.Geometry.BrepFace, uvB: Rhino.Geometry.Point2d, radius: float, tolerance: float, trimmedBrepsA: List[Rhino.Geometry.Brep], trimmedBrepsB: List[Rhino.Geometry.Brep], rail_degree: int, TanSlider: float, InnerSlider: float, bTrim: bool, bExtend: bool, Fillets: List[Rhino.Geometry.Brep]) -> bool
Rhino.Geometry.SurfaceFilletBase.CreateRationalArcsFilletSrf(faceA: Rhino.Geometry.BrepFace, uvA: Rhino.Geometry.Point2d, faceB: Rhino.Geometry.BrepFace, uvB: Rhino.Geometry.Point2d, radius: float, tolerance: float, trimmedBrepsA: List[Rhino.Geometry.Brep], trimmedBrepsB: List[Rhino.Geometry.Brep], rail_degree: int, bTrim: bool, bExtend: bool, Fillets: List[Rhino.Geometry.Brep]) -> bool
Rhino.Geometry.SurfaceFilletBase.Dispose(self) -> None
Rhino.Geometry.SurfaceFilletBase.Dispose(self, disposing: bool) -> None
Rhino.Geometry.SurfaceFilletBase.Finalize(self) -> None
Rhino.Geometry.SurfaceFilletBase.G2ChordalQuintic(self, railDegree: int, bExtend: bool, Fillets: List[Rhino.Geometry.Brep]) -> bool
Rhino.Geometry.SurfaceFilletBase.IsInitialized(self) -> bool
Rhino.Geometry.SurfaceFilletBase.NonRationalCubic(self, railDegree: int, TanSlider: float, bExtend: bool, Fillets: List[Rhino.Geometry.Brep]) -> bool
Rhino.Geometry.SurfaceFilletBase.NonRationalCubicArcs(self, railDegree: int, bExtend: bool, Fillets: List[Rhino.Geometry.Brep]) -> bool
Rhino.Geometry.SurfaceFilletBase.NonRationalQuartic(self, railDegree: int, TanSlider: float, InnerSlider: float, bExtend: bool, Fillets: List[Rhino.Geometry.Brep]) -> bool
Rhino.Geometry.SurfaceFilletBase.NonRationalQuarticArcs(self, railDegree: int, bExtend: bool, Fillets: List[Rhino.Geometry.Brep]) -> bool
Rhino.Geometry.SurfaceFilletBase.NonRationalQuintic(self, railDegree: int, TanSlider: float, InnerSlider: float, bExtend: bool, Fillets: List[Rhino.Geometry.Brep]) -> bool
Rhino.Geometry.SurfaceFilletBase.NonRationalQuinticArcs(self, railDegree: int, bExtend: bool, Fillets: List[Rhino.Geometry.Brep]) -> bool
Rhino.Geometry.SurfaceFilletBase.RationalArcs(self, railDegree: int, bExtend: bool, Fillets: List[Rhino.Geometry.Brep]) -> bool
Rhino.Geometry.SurfaceFilletBase.TrimBreps(self, bExtend: bool, TrimmedBreps0: List[Rhino.Geometry.Brep], TrimmedBreps1: List[Rhino.Geometry.Brep]) -> bool
Rhino.Geometry.SurfaceFilletBase.__init__(self, FaceA: Rhino.Geometry.BrepFace, uvA: Rhino.Geometry.Point2d, FaceB: Rhino.Geometry.BrepFace, uvB: Rhino.Geometry.Point2d, radius: float, allowExtend: bool, tolerance: float) -> None
Rhino.Geometry.SurfaceFilletBase.__init__(self, FaceA: Rhino.Geometry.BrepFace, uvA: Rhino.Geometry.Point2d, FaceB: Rhino.Geometry.BrepFace, uvB: Rhino.Geometry.Point2d, radius: float, tolerance: float) -> None
Rhino.Geometry.SurfaceFilletBase.__init__(self, RailFace: Rhino.Geometry.BrepFace, Rail3d: Rhino.Geometry.Curve, Face: Rhino.Geometry.BrepFace, uv: Rhino.Geometry.Point2d, tolerance: float) -> None
Rhino.Geometry.SurfaceFilletBase.__init__(self, face: Rhino.Geometry.BrepFace, uv: Rhino.Geometry.Point2d, rail3d: Rhino.Geometry.Curve, u: float, radius: float, tolerance: float) -> None
Rhino.Geometry.SurfaceProxy.__init__(self) -> None
Rhino.Geometry.SweepOneRail.PerformSweep(self, rail: Rhino.Geometry.Curve, crossSection: Rhino.Geometry.Curve) -> List[Brep]
Rhino.Geometry.SweepOneRail.PerformSweep(self, rail: Rhino.Geometry.Curve, crossSection: Rhino.Geometry.Curve, crossSectionParameter: float) -> List[Brep]
Rhino.Geometry.SweepOneRail.PerformSweep(self, rail: Rhino.Geometry.Curve, crossSections: Iterable[Rhino.Geometry.Curve]) -> List[Brep]
Rhino.Geometry.SweepOneRail.PerformSweep(self, rail: Rhino.Geometry.Curve, crossSections: Iterable[Rhino.Geometry.Curve], crossSectionParameters: Iterable[float]) -> List[Brep]
Rhino.Geometry.SweepOneRail.PerformSweepRebuild(self, rail: Rhino.Geometry.Curve, crossSection: Rhino.Geometry.Curve, crossSectionParameter: float, rebuildCount: int) -> List[Brep]
Rhino.Geometry.SweepOneRail.PerformSweepRebuild(self, rail: Rhino.Geometry.Curve, crossSection: Rhino.Geometry.Curve, rebuildCount: int) -> List[Brep]
Rhino.Geometry.SweepOneRail.PerformSweepRebuild(self, rail: Rhino.Geometry.Curve, crossSections: Iterable[Rhino.Geometry.Curve], crossSectionParameters: Iterable[float], rebuildCount: int) -> List[Brep]
Rhino.Geometry.SweepOneRail.PerformSweepRebuild(self, rail: Rhino.Geometry.Curve, crossSections: Iterable[Rhino.Geometry.Curve], rebuildCount: int) -> List[Brep]
Rhino.Geometry.SweepOneRail.PerformSweepRefit(self, rail: Rhino.Geometry.Curve, crossSection: Rhino.Geometry.Curve, crossSectionParameter: float, refitTolerance: float) -> List[Brep]
Rhino.Geometry.SweepOneRail.PerformSweepRefit(self, rail: Rhino.Geometry.Curve, crossSection: Rhino.Geometry.Curve, refitTolerance: float) -> List[Brep]
Rhino.Geometry.SweepOneRail.PerformSweepRefit(self, rail: Rhino.Geometry.Curve, crossSections: Iterable[Rhino.Geometry.Curve], crossSectionParameters: Iterable[float], refitTolerance: float) -> List[Brep]
Rhino.Geometry.SweepOneRail.PerformSweepRefit(self, rail: Rhino.Geometry.Curve, crossSections: Iterable[Rhino.Geometry.Curve], refitTolerance: float) -> List[Brep]
Rhino.Geometry.SweepOneRail.SetRoadlikeUpDirection(self, up: Rhino.Geometry.Vector3d) -> None
Rhino.Geometry.SweepOneRail.SetToRoadlikeFront(self) -> None
Rhino.Geometry.SweepOneRail.SetToRoadlikeRight(self) -> None
Rhino.Geometry.SweepOneRail.SetToRoadlikeTop(self) -> None
Rhino.Geometry.SweepOneRail.__init__(self) -> None
Rhino.Geometry.SweepTwoRail.PerformSweep(self, rail1: Rhino.Geometry.Curve, rail2: Rhino.Geometry.Curve, crossSection: Rhino.Geometry.Curve) -> List[Brep]
Rhino.Geometry.SweepTwoRail.PerformSweep(self, rail1: Rhino.Geometry.Curve, rail2: Rhino.Geometry.Curve, crossSection: Rhino.Geometry.Curve, crossSectionParameterRail1: float, crossSectionParameterRail2: float) -> List[Brep]
Rhino.Geometry.SweepTwoRail.PerformSweep(self, rail1: Rhino.Geometry.Curve, rail2: Rhino.Geometry.Curve, crossSections: Iterable[Rhino.Geometry.Curve]) -> List[Brep]
Rhino.Geometry.SweepTwoRail.PerformSweep(self, rail1: Rhino.Geometry.Curve, rail2: Rhino.Geometry.Curve, crossSections: Iterable[Rhino.Geometry.Curve], crossSectionParameters1: Iterable[float], crossSectionParameters2: Iterable[float]) -> List[Brep]
Rhino.Geometry.SweepTwoRail.PerformSweepRebuild(self, rail1: Rhino.Geometry.Curve, rail2: Rhino.Geometry.Curve, crossSection: Rhino.Geometry.Curve, crossSectionParameterRail1: float, crossSectionParameterRail2: float, rebuildCount: int) -> List[Brep]
Rhino.Geometry.SweepTwoRail.PerformSweepRebuild(self, rail1: Rhino.Geometry.Curve, rail2: Rhino.Geometry.Curve, crossSection: Rhino.Geometry.Curve, rebuildCount: int) -> List[Brep]
Rhino.Geometry.SweepTwoRail.PerformSweepRebuild(self, rail1: Rhino.Geometry.Curve, rail2: Rhino.Geometry.Curve, crossSections: Iterable[Rhino.Geometry.Curve], crossSectionParametersRail1: Iterable[float], crossSectionParametersRail2: Iterable[float], rebuildCount: int) -> List[Brep]
Rhino.Geometry.SweepTwoRail.PerformSweepRebuild(self, rail1: Rhino.Geometry.Curve, rail2: Rhino.Geometry.Curve, crossSections: Iterable[Rhino.Geometry.Curve], rebuildCount: int) -> List[Brep]
Rhino.Geometry.SweepTwoRail.PerformSweepRefit(self, rail1: Rhino.Geometry.Curve, rail2: Rhino.Geometry.Curve, crossSection: Rhino.Geometry.Curve, crossSectionParameterRail1: float, crossSectionParameterRail2: float, refitTolerance: float) -> List[Brep]
Rhino.Geometry.SweepTwoRail.PerformSweepRefit(self, rail1: Rhino.Geometry.Curve, rail2: Rhino.Geometry.Curve, crossSection: Rhino.Geometry.Curve, refitTolerance: float) -> List[Brep]
Rhino.Geometry.SweepTwoRail.PerformSweepRefit(self, rail1: Rhino.Geometry.Curve, rail2: Rhino.Geometry.Curve, crossSections: Iterable[Rhino.Geometry.Curve], crossSectionParametersRail1: Iterable[float], crossSectionParametersRail2: Iterable[float], refitTolerance: float) -> List[Brep]
Rhino.Geometry.SweepTwoRail.PerformSweepRefit(self, rail1: Rhino.Geometry.Curve, rail2: Rhino.Geometry.Curve, crossSections: Iterable[Rhino.Geometry.Curve], refitTolerance: float) -> List[Brep]
Rhino.Geometry.SweepTwoRail.__init__(self) -> None
Rhino.Geometry.TextDot.__init__(self, info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext) -> None
Rhino.Geometry.TextDot.__init__(self, text: str, location: Rhino.Geometry.Point3d) -> None
Rhino.Geometry.TextEntity.Create(text: str, plane: Rhino.Geometry.Plane, style: Rhino.DocObjects.DimensionStyle, wrapped: bool, rectWidth: float, rotationRadians: float) -> Rhino.Geometry.TextEntity
Rhino.Geometry.TextEntity.CreateCurves(self, dimstyle: Rhino.DocObjects.DimensionStyle, allowOpen: bool, smallCapsScale: float, spacing: float) -> List[Curve]
Rhino.Geometry.TextEntity.CreateCurvesGrouped(self, dimstyle: Rhino.DocObjects.DimensionStyle, allowOpen: bool, smallCapsScale: float, spacing: float) -> List<Curve[]>
Rhino.Geometry.TextEntity.CreateExtrusions(self, dimstyle: Rhino.DocObjects.DimensionStyle, height: float, smallCapsScale: float, spacing: float) -> List[Extrusion]
Rhino.Geometry.TextEntity.CreateExtrusionsGrouped(self, dimstyle: Rhino.DocObjects.DimensionStyle, smallCapsScale: float, height: float, spacing: float) -> List<Extrusion[]>
Rhino.Geometry.TextEntity.CreatePolySurfaces(self, dimstyle: Rhino.DocObjects.DimensionStyle, height: float, smallCapsScale: float, spacing: float) -> List[Brep]
Rhino.Geometry.TextEntity.CreatePolysurfacesGrouped(self, dimstyle: Rhino.DocObjects.DimensionStyle, smallCapsScale: float, height: float, spacing: float) -> List<Brep[]>
Rhino.Geometry.TextEntity.CreateSurfaces(self, dimstyle: Rhino.DocObjects.DimensionStyle, smallCapsScale: float, spacing: float) -> List[Brep]
Rhino.Geometry.TextEntity.CreateSurfacesGrouped(self, dimstyle: Rhino.DocObjects.DimensionStyle, smallCapsScale: float, spacing: float) -> List<Brep[]>
Rhino.Geometry.TextEntity.CreateWithRichText(richTextString: str, plane: Rhino.Geometry.Plane, style: Rhino.DocObjects.DimensionStyle, wrapped: bool, rectWidth: float, rotationRadians: float) -> Rhino.Geometry.TextEntity
Rhino.Geometry.TextEntity.Explode(self) -> List[Curve]
Rhino.Geometry.TextEntity.GetTextTransform(self, textscale: float, dimstyle: Rhino.DocObjects.DimensionStyle) -> Transform
Rhino.Geometry.TextEntity.Transform(self, transform: Rhino.Geometry.Transform, style: Rhino.DocObjects.DimensionStyle) -> bool
Rhino.Geometry.TextEntity.__init__(self) -> None
Rhino.Geometry.TextEntity.__init__(self, info: System.Runtime.Serialization.SerializationInfo, context: System.Runtime.Serialization.StreamingContext) -> None
Rhino.Geometry.Torus.EpsilonEquals(self, other: Rhino.Geometry.Torus, epsilon: float) -> bool
Rhino.Geometry.Torus.ToBrep(self) -> Brep
Rhino.Geometry.Torus.ToNurbsSurface(self) -> NurbsSurface
Rhino.Geometry.Torus.ToRevSurface(self) -> RevSurface
Rhino.Geometry.Torus.__init__(self, basePlane: Rhino.Geometry.Plane, majorRadius: float, minorRadius: float) -> None
Rhino.Geometry.Transform.!=(a: Rhino.Geometry.Transform, b: Rhino.Geometry.Transform) -> operator
Rhino.Geometry.Transform.*(a: Rhino.Geometry.Transform, b: Rhino.Geometry.Transform) -> operator
Rhino.Geometry.Transform.*(m: Rhino.Geometry.Transform, p: Rhino.Geometry.Point3d) -> operator
Rhino.Geometry.Transform.*(m: Rhino.Geometry.Transform, v: Rhino.Geometry.Vector3d) -> operator
Rhino.Geometry.Transform.==(a: Rhino.Geometry.Transform, b: Rhino.Geometry.Transform) -> operator
Rhino.Geometry.Transform.Affineize(self) -> None
Rhino.Geometry.Transform.ChangeBasis(P0: Rhino.Geometry.Point3d, X0: Rhino.Geometry.Vector3d, Y0: Rhino.Geometry.Vector3d, Z0: Rhino.Geometry.Vector3d, P1: Rhino.Geometry.Point3d, X1: Rhino.Geometry.Vector3d, Y1: Rhino.Geometry.Vector3d, Z1: Rhino.Geometry.Vector3d) -> Rhino.Geometry.Transform
Rhino.Geometry.Transform.ChangeBasis(X0: Rhino.Geometry.Vector3d, Y0: Rhino.Geometry.Vector3d, Z0: Rhino.Geometry.Vector3d, X1: Rhino.Geometry.Vector3d, Y1: Rhino.Geometry.Vector3d, Z1: Rhino.Geometry.Vector3d) -> Rhino.Geometry.Transform
Rhino.Geometry.Transform.ChangeBasis(plane0: Rhino.Geometry.Plane, plane1: Rhino.Geometry.Plane) -> Rhino.Geometry.Transform
Rhino.Geometry.Transform.Clone(self) -> Rhino.Geometry.Transform
Rhino.Geometry.Transform.CompareTo(self, other: Rhino.Geometry.Transform) -> int
Rhino.Geometry.Transform.DecomposeAffine(self, linear: Rhino.Geometry.Transform@, translation: Rhino.Geometry.Vector3d@) -> bool
Rhino.Geometry.Transform.DecomposeAffine(self, translation: Rhino.Geometry.Vector3d@, linear: Rhino.Geometry.Transform@) -> bool
Rhino.Geometry.Transform.DecomposeAffine(self, translation: Rhino.Geometry.Vector3d@, rotation: Rhino.Geometry.Transform@, orthogonal: Rhino.Geometry.Transform@, diagonal: Rhino.Geometry.Vector3d@) -> bool
Rhino.Geometry.Transform.DecomposeRigid(self, translation: Rhino.Geometry.Vector3d@, rotation: Rhino.Geometry.Transform@, tolerance: float) -> TransformRigidType
Rhino.Geometry.Transform.DecomposeSimilarity(self, translation: Rhino.Geometry.Vector3d@, dilation: System.Double@, rotation: Rhino.Geometry.Transform@, tolerance: float) -> TransformSimilarityType
Rhino.Geometry.Transform.DecomposeSymmetric(self, matrix: Rhino.Geometry.Transform@, diagonal: Rhino.Geometry.Vector3d@) -> bool
Rhino.Geometry.Transform.DecomposeTextureMapping(self, offset: Rhino.Geometry.Vector3d@, repeat: Rhino.Geometry.Vector3d@, rotation: Rhino.Geometry.Vector3d@) -> None
Rhino.Geometry.Transform.Diagonal(d0: float, d1: float, d2: float) -> Rhino.Geometry.Transform
Rhino.Geometry.Transform.Diagonal(diagonal: Rhino.Geometry.Vector3d) -> Rhino.Geometry.Transform
Rhino.Geometry.Transform.Equals(self, obj: Any) -> bool
Rhino.Geometry.Transform.Equals(self, other: Rhino.Geometry.Transform) -> bool
Rhino.Geometry.Transform.GetEulerZYZ(self, alpha: System.Double@, beta: System.Double@, gamma: System.Double@) -> bool
Rhino.Geometry.Transform.GetHashCode(self) -> int
Rhino.Geometry.Transform.GetQuaternion(self, quaternion: Rhino.Geometry.Quaternion@) -> bool
Rhino.Geometry.Transform.GetYawPitchRoll(self, yaw: System.Double@, pitch: System.Double@, roll: System.Double@) -> bool
Rhino.Geometry.Transform.IsRigid(self, tolerance: float) -> TransformRigidType
Rhino.Geometry.Transform.IsSimilarity(self, tolerance: float) -> TransformSimilarityType
Rhino.Geometry.Transform.IsZeroTransformationWithTolerance(self, zeroTolerance: float) -> bool
Rhino.Geometry.Transform.Linearize(self) -> None
Rhino.Geometry.Transform.Mirror(mirrorPlane: Rhino.Geometry.Plane) -> Rhino.Geometry.Transform
Rhino.Geometry.Transform.Mirror(pointOnMirrorPlane: Rhino.Geometry.Point3d, normalToMirrorPlane: Rhino.Geometry.Vector3d) -> Rhino.Geometry.Transform
Rhino.Geometry.Transform.Multiply(a: Rhino.Geometry.Transform, b: Rhino.Geometry.Transform) -> Rhino.Geometry.Transform
Rhino.Geometry.Transform.Orthogonalize(self, tolerance: float) -> bool
Rhino.Geometry.Transform.PlanarProjection(plane: Rhino.Geometry.Plane) -> Rhino.Geometry.Transform
Rhino.Geometry.Transform.PlaneToPlane(plane0: Rhino.Geometry.Plane, plane1: Rhino.Geometry.Plane) -> Rhino.Geometry.Transform
Rhino.Geometry.Transform.ProjectAlong(plane: Rhino.Geometry.Plane, direction: Rhino.Geometry.Vector3d) -> Rhino.Geometry.Transform
Rhino.Geometry.Transform.Rotation(angleRadians: float, rotationAxis: Rhino.Geometry.Vector3d, rotationCenter: Rhino.Geometry.Point3d) -> Rhino.Geometry.Transform
Rhino.Geometry.Transform.Rotation(angleRadians: float, rotationCenter: Rhino.Geometry.Point3d) -> Rhino.Geometry.Transform
Rhino.Geometry.Transform.Rotation(sinAngle: float, cosAngle: float, rotationAxis: Rhino.Geometry.Vector3d, rotationCenter: Rhino.Geometry.Point3d) -> Rhino.Geometry.Transform
Rhino.Geometry.Transform.Rotation(startDirection: Rhino.Geometry.Vector3d, endDirection: Rhino.Geometry.Vector3d, rotationCenter: Rhino.Geometry.Point3d) -> Rhino.Geometry.Transform
Rhino.Geometry.Transform.Rotation(x0: Rhino.Geometry.Vector3d, y0: Rhino.Geometry.Vector3d, z0: Rhino.Geometry.Vector3d, x1: Rhino.Geometry.Vector3d, y1: Rhino.Geometry.Vector3d, z1: Rhino.Geometry.Vector3d) -> Rhino.Geometry.Transform
Rhino.Geometry.Transform.RotationZYX(yaw: float, pitch: float, roll: float) -> Rhino.Geometry.Transform
Rhino.Geometry.Transform.RotationZYZ(alpha: float, beta: float, gamma: float) -> Rhino.Geometry.Transform
Rhino.Geometry.Transform.Scale(anchor: Rhino.Geometry.Point3d, scaleFactor: float) -> Rhino.Geometry.Transform
Rhino.Geometry.Transform.Scale(plane: Rhino.Geometry.Plane, xScaleFactor: float, yScaleFactor: float, zScaleFactor: float) -> Rhino.Geometry.Transform
Rhino.Geometry.Transform.Shear(plane: Rhino.Geometry.Plane, x: Rhino.Geometry.Vector3d, y: Rhino.Geometry.Vector3d, z: Rhino.Geometry.Vector3d) -> Rhino.Geometry.Transform
Rhino.Geometry.Transform.TextureMapping(offset: Rhino.Geometry.Vector3d, repeat: Rhino.Geometry.Vector3d, rotation: Rhino.Geometry.Vector3d) -> Rhino.Geometry.Transform
Rhino.Geometry.Transform.ToDoubleArray(self, rowDominant: bool) -> List[float]
Rhino.Geometry.Transform.ToFloatArray(self, rowDominant: bool) -> List[float]
Rhino.Geometry.Transform.ToString(self) -> str
Rhino.Geometry.Transform.TransformBoundingBox(self, bbox: Rhino.Geometry.BoundingBox) -> BoundingBox
Rhino.Geometry.Transform.TransformList(self, points: Iterable[Rhino.Geometry.Point3d]) -> List[Point3d]
Rhino.Geometry.Transform.Translation(dx: float, dy: float, dz: float) -> Rhino.Geometry.Transform
Rhino.Geometry.Transform.Translation(motion: Rhino.Geometry.Vector3d) -> Rhino.Geometry.Transform
Rhino.Geometry.Transform.Transpose(self) -> Rhino.Geometry.Transform
Rhino.Geometry.Transform.TryGetInverse(self, inverseTransform: Rhino.Geometry.Transform@) -> bool
Rhino.Geometry.Transform.__init__(self, diagonalValue: float) -> None
Rhino.Geometry.Transform.__init__(self, value: Rhino.Geometry.Transform) -> None
Rhino.Geometry.Triangle3d.BarycentricCoordsAt(self, point: Rhino.Geometry.Point3d, signedHeight: System.Double@) -> Point2d
Rhino.Geometry.Triangle3d.ClosestParameterOnBoundary(self, point: Rhino.Geometry.Point3d) -> float
Rhino.Geometry.Triangle3d.ClosestPointOnBoundary(self, point: Rhino.Geometry.Point3d) -> Point3d
Rhino.Geometry.Triangle3d.PointAlongBoundary(self, t: float) -> Point3d
Rhino.Geometry.Triangle3d.PointAtBarycentricCoords(self, coords: Rhino.Geometry.Point2d) -> Point3d
Rhino.Geometry.Triangle3d.PointOnInterior(self, u: float, v: float) -> Point3d
Rhino.Geometry.Triangle3d.ToMesh(self) -> Mesh
Rhino.Geometry.Triangle3d.ToPolyline(self) -> Polyline
Rhino.Geometry.Triangle3d.Transform(self, transform: Rhino.Geometry.Transform) -> Rhino.Geometry.Triangle3d
Rhino.Geometry.Triangle3d.TrySmallestEnclosingTriangle(points: Iterable[Rhino.Geometry.Point2d], tolerance: float, triangle: Rhino.Geometry.Triangle3d@) -> bool
Rhino.Geometry.Triangle3d.WithA(self, a: Rhino.Geometry.Point3d) -> Rhino.Geometry.Triangle3d
Rhino.Geometry.Triangle3d.WithB(self, b: Rhino.Geometry.Point3d) -> Rhino.Geometry.Triangle3d
Rhino.Geometry.Triangle3d.WithC(self, c: Rhino.Geometry.Point3d) -> Rhino.Geometry.Triangle3d
Rhino.Geometry.Triangle3d.__init__(self, a: Rhino.Geometry.Point3d, b: Rhino.Geometry.Point3d, c: Rhino.Geometry.Point3d) -> None
Rhino.Geometry.Unroller.AddFollowingGeometry(self, curve: Rhino.Geometry.Curve) -> None
Rhino.Geometry.Unroller.AddFollowingGeometry(self, curves: Iterable[Rhino.Geometry.Curve]) -> None
Rhino.Geometry.Unroller.AddFollowingGeometry(self, dot: Rhino.Geometry.TextDot) -> None
Rhino.Geometry.Unroller.AddFollowingGeometry(self, dotLocation: Rhino.Geometry.Point3d, dotText: str) -> None
Rhino.Geometry.Unroller.AddFollowingGeometry(self, dotLocations: Iterable[Rhino.Geometry.Point3d], dotText: Iterable[str]) -> None
Rhino.Geometry.Unroller.AddFollowingGeometry(self, dots: Iterable[Rhino.Geometry.TextDot]) -> None
Rhino.Geometry.Unroller.AddFollowingGeometry(self, point: Rhino.Geometry.Point) -> None
Rhino.Geometry.Unroller.AddFollowingGeometry(self, point: Rhino.Geometry.Point3d) -> None
Rhino.Geometry.Unroller.AddFollowingGeometry(self, points: Iterable[Rhino.Geometry.Point3d]) -> None
Rhino.Geometry.Unroller.FollowingGeometryIndex(self, curve: Rhino.Geometry.Curve) -> int
Rhino.Geometry.Unroller.FollowingGeometryIndex(self, dot: Rhino.Geometry.TextDot) -> int
Rhino.Geometry.Unroller.PerformUnroll(self, flatbreps: List[Rhino.Geometry.Brep]) -> int
Rhino.Geometry.Unroller.PerformUnroll(self, unrolledCurves: Rhino.Geometry.Curve[]@, unrolledPoints: Rhino.Geometry.Point3d[]@, unrolledDots: Rhino.Geometry.TextDot[]@) -> List[Brep]
Rhino.Geometry.Unroller.__init__(self, brep: Rhino.Geometry.Brep) -> None
Rhino.Geometry.Unroller.__init__(self, surface: Rhino.Geometry.Surface) -> None
Rhino.Geometry.Vector2d.!=(a: Rhino.Geometry.Vector2d, b: Rhino.Geometry.Vector2d) -> operator
Rhino.Geometry.Vector2d.*(t: float, vector: Rhino.Geometry.Vector2d) -> operator
Rhino.Geometry.Vector2d.*(vector1: Rhino.Geometry.Vector2d, vector2: Rhino.Geometry.Vector2d) -> operator
Rhino.Geometry.Vector2d.*(vector: Rhino.Geometry.Vector2d, t: float) -> operator
Rhino.Geometry.Vector2d.+(vector1: Rhino.Geometry.Vector2d, vector2: Rhino.Geometry.Vector2d) -> operator
Rhino.Geometry.Vector2d.-(vector1: Rhino.Geometry.Vector2d, vector2: Rhino.Geometry.Vector2d) -> operator
Rhino.Geometry.Vector2d.-(vector: Rhino.Geometry.Vector2d) -> operator
Rhino.Geometry.Vector2d./(vector: Rhino.Geometry.Vector2d, t: float) -> operator
Rhino.Geometry.Vector2d.<(a: Rhino.Geometry.Vector2d, b: Rhino.Geometry.Vector2d) -> operator
Rhino.Geometry.Vector2d.<=(a: Rhino.Geometry.Vector2d, b: Rhino.Geometry.Vector2d) -> operator
Rhino.Geometry.Vector2d.==(a: Rhino.Geometry.Vector2d, b: Rhino.Geometry.Vector2d) -> operator
Rhino.Geometry.Vector2d.>(a: Rhino.Geometry.Vector2d, b: Rhino.Geometry.Vector2d) -> operator
Rhino.Geometry.Vector2d.>=(a: Rhino.Geometry.Vector2d, b: Rhino.Geometry.Vector2d) -> operator
Rhino.Geometry.Vector2d.Add(vector1: Rhino.Geometry.Vector2d, vector2: Rhino.Geometry.Vector2d) -> Rhino.Geometry.Vector2d
Rhino.Geometry.Vector2d.CompareTo(self, other: Rhino.Geometry.Vector2d) -> int
Rhino.Geometry.Vector2d.Divide(vector: Rhino.Geometry.Vector2d, t: float) -> Rhino.Geometry.Vector2d
Rhino.Geometry.Vector2d.EpsilonEquals(self, other: Rhino.Geometry.Vector2d, epsilon: float) -> bool
Rhino.Geometry.Vector2d.Equals(self, obj: Any) -> bool
Rhino.Geometry.Vector2d.Equals(self, vector: Rhino.Geometry.Vector2d) -> bool
Rhino.Geometry.Vector2d.GetHashCode(self) -> int
Rhino.Geometry.Vector2d.IsTiny(self) -> bool
Rhino.Geometry.Vector2d.IsTiny(self, tolerance: float) -> bool
Rhino.Geometry.Vector2d.Multiply(t: float, vector: Rhino.Geometry.Vector2d) -> Rhino.Geometry.Vector2d
Rhino.Geometry.Vector2d.Multiply(vector1: Rhino.Geometry.Vector2d, vector2: Rhino.Geometry.Vector2d) -> float
Rhino.Geometry.Vector2d.Multiply(vector: Rhino.Geometry.Vector2d, t: float) -> Rhino.Geometry.Vector2d
Rhino.Geometry.Vector2d.Negate(vector: Rhino.Geometry.Vector2d) -> Rhino.Geometry.Vector2d
Rhino.Geometry.Vector2d.Rotate(self, angleRadians: float) -> bool
Rhino.Geometry.Vector2d.Subtract(vector1: Rhino.Geometry.Vector2d, vector2: Rhino.Geometry.Vector2d) -> Rhino.Geometry.Vector2d
Rhino.Geometry.Vector2d.ToString(self) -> str
Rhino.Geometry.Vector2d.ToString(self, format: str, formatProvider: System.IFormatProvider) -> str
Rhino.Geometry.Vector2d.Unitize(self) -> bool
Rhino.Geometry.Vector2d.__init__(self, x: float, y: float) -> None
Rhino.Geometry.Vector2f.!=(a: Rhino.Geometry.Vector2f, b: Rhino.Geometry.Vector2f) -> operator
Rhino.Geometry.Vector2f.*(point1: Rhino.Geometry.Vector2f, point2: Rhino.Geometry.Vector2f) -> operator
Rhino.Geometry.Vector2f.+(a: Rhino.Geometry.Vector2f, b: Rhino.Geometry.Vector2f) -> operator
Rhino.Geometry.Vector2f.+(point: Rhino.Geometry.Point2f, vector: Rhino.Geometry.Vector2f) -> operator
Rhino.Geometry.Vector2f.-(a: Rhino.Geometry.Vector2f, b: Rhino.Geometry.Vector2f) -> operator
Rhino.Geometry.Vector2f.-(vector: Rhino.Geometry.Vector2f) -> operator
Rhino.Geometry.Vector2f.<(a: Rhino.Geometry.Vector2f, b: Rhino.Geometry.Vector2f) -> operator
Rhino.Geometry.Vector2f.<=(a: Rhino.Geometry.Vector2f, b: Rhino.Geometry.Vector2f) -> operator
Rhino.Geometry.Vector2f.==(a: Rhino.Geometry.Vector2f, b: Rhino.Geometry.Vector2f) -> operator
Rhino.Geometry.Vector2f.>(a: Rhino.Geometry.Vector2f, b: Rhino.Geometry.Vector2f) -> operator
Rhino.Geometry.Vector2f.>=(a: Rhino.Geometry.Vector2f, b: Rhino.Geometry.Vector2f) -> operator
Rhino.Geometry.Vector2f.Add(point: Rhino.Geometry.Point2f, vector: Rhino.Geometry.Vector2f) -> Point2f
Rhino.Geometry.Vector2f.Add(vector1: Rhino.Geometry.Vector2f, vector2: Rhino.Geometry.Vector2f) -> Rhino.Geometry.Vector2f
Rhino.Geometry.Vector2f.CompareTo(self, other: Rhino.Geometry.Vector2f) -> int
Rhino.Geometry.Vector2f.EpsilonEquals(self, other: Rhino.Geometry.Vector2f, epsilon: float) -> bool
Rhino.Geometry.Vector2f.Equals(self, obj: Any) -> bool
Rhino.Geometry.Vector2f.Equals(self, vector: Rhino.Geometry.Vector2f) -> bool
Rhino.Geometry.Vector2f.GetHashCode(self) -> int
Rhino.Geometry.Vector2f.Multiply(point1: Rhino.Geometry.Vector2f, point2: Rhino.Geometry.Vector2f) -> float
Rhino.Geometry.Vector2f.Negate(vector: Rhino.Geometry.Vector2f) -> Rhino.Geometry.Vector2f
Rhino.Geometry.Vector2f.PerpendicularTo(self, other: Rhino.Geometry.Vector2f) -> bool
Rhino.Geometry.Vector2f.Reverse(self) -> bool
Rhino.Geometry.Vector2f.Subtract(vector1: Rhino.Geometry.Vector2f, vector2: Rhino.Geometry.Vector2f) -> Rhino.Geometry.Vector2f
Rhino.Geometry.Vector2f.ToString(self) -> str
Rhino.Geometry.Vector2f.ToString(self, format: str, formatProvider: System.IFormatProvider) -> str
Rhino.Geometry.Vector2f.Unitize(self) -> bool
Rhino.Geometry.Vector2f.__init__(self, x: float, y: float) -> None
Rhino.Geometry.Vector3d.!=(a: Rhino.Geometry.Vector3d, b: Rhino.Geometry.Vector3d) -> operator
Rhino.Geometry.Vector3d.*(t: float, vector: Rhino.Geometry.Vector3d) -> operator
Rhino.Geometry.Vector3d.*(vector1: Rhino.Geometry.Vector3d, vector2: Rhino.Geometry.Vector3d) -> operator
Rhino.Geometry.Vector3d.*(vector: Rhino.Geometry.Vector3d, t: float) -> operator
Rhino.Geometry.Vector3d.+(vector1: Rhino.Geometry.Vector3d, vector2: Rhino.Geometry.Vector3d) -> operator
Rhino.Geometry.Vector3d.-(vector1: Rhino.Geometry.Vector3d, vector2: Rhino.Geometry.Vector3d) -> operator
Rhino.Geometry.Vector3d.-(vector: Rhino.Geometry.Vector3d) -> operator
Rhino.Geometry.Vector3d./(vector: Rhino.Geometry.Vector3d, t: float) -> operator
Rhino.Geometry.Vector3d.<(a: Rhino.Geometry.Vector3d, b: Rhino.Geometry.Vector3d) -> operator
Rhino.Geometry.Vector3d.<=(a: Rhino.Geometry.Vector3d, b: Rhino.Geometry.Vector3d) -> operator
Rhino.Geometry.Vector3d.==(a: Rhino.Geometry.Vector3d, b: Rhino.Geometry.Vector3d) -> operator
Rhino.Geometry.Vector3d.>(a: Rhino.Geometry.Vector3d, b: Rhino.Geometry.Vector3d) -> operator
Rhino.Geometry.Vector3d.>=(a: Rhino.Geometry.Vector3d, b: Rhino.Geometry.Vector3d) -> operator
Rhino.Geometry.Vector3d.Add(vector1: Rhino.Geometry.Vector3d, vector2: Rhino.Geometry.Vector3d) -> Rhino.Geometry.Vector3d
Rhino.Geometry.Vector3d.AreOrthogonal(x: Rhino.Geometry.Vector3d, y: Rhino.Geometry.Vector3d, z: Rhino.Geometry.Vector3d) -> bool
Rhino.Geometry.Vector3d.AreOrthonormal(x: Rhino.Geometry.Vector3d, y: Rhino.Geometry.Vector3d, z: Rhino.Geometry.Vector3d) -> bool
Rhino.Geometry.Vector3d.AreRighthanded(x: Rhino.Geometry.Vector3d, y: Rhino.Geometry.Vector3d, z: Rhino.Geometry.Vector3d) -> bool
Rhino.Geometry.Vector3d.CompareTo(self, other: Rhino.Geometry.Vector3d) -> int
Rhino.Geometry.Vector3d.CrossProduct(a: Rhino.Geometry.Vector3d, b: Rhino.Geometry.Vector3d) -> Rhino.Geometry.Vector3d
Rhino.Geometry.Vector3d.Divide(vector: Rhino.Geometry.Vector3d, t: float) -> Rhino.Geometry.Vector3d
Rhino.Geometry.Vector3d.EpsilonEquals(self, other: Rhino.Geometry.Vector3d, epsilon: float) -> bool
Rhino.Geometry.Vector3d.Equals(self, obj: Any) -> bool
Rhino.Geometry.Vector3d.Equals(self, vector: Rhino.Geometry.Vector3d) -> bool
Rhino.Geometry.Vector3d.GetHashCode(self) -> int
Rhino.Geometry.Vector3d.IsParallelTo(self, other: Rhino.Geometry.Vector3d) -> int
Rhino.Geometry.Vector3d.IsParallelTo(self, other: Rhino.Geometry.Vector3d, angleTolerance: float) -> int
Rhino.Geometry.Vector3d.IsPerpendicularTo(self, other: Rhino.Geometry.Vector3d) -> bool
Rhino.Geometry.Vector3d.IsPerpendicularTo(self, other: Rhino.Geometry.Vector3d, angleTolerance: float) -> bool
Rhino.Geometry.Vector3d.IsTiny(self) -> bool
Rhino.Geometry.Vector3d.IsTiny(self, tolerance: float) -> bool
Rhino.Geometry.Vector3d.Multiply(t: float, vector: Rhino.Geometry.Vector3d) -> Rhino.Geometry.Vector3d
Rhino.Geometry.Vector3d.Multiply(vector1: Rhino.Geometry.Vector3d, vector2: Rhino.Geometry.Vector3d) -> float
Rhino.Geometry.Vector3d.Multiply(vector: Rhino.Geometry.Vector3d, t: float) -> Rhino.Geometry.Vector3d
Rhino.Geometry.Vector3d.Negate(vector: Rhino.Geometry.Vector3d) -> Rhino.Geometry.Vector3d
Rhino.Geometry.Vector3d.PerpendicularTo(self, other: Rhino.Geometry.Vector3d) -> bool
Rhino.Geometry.Vector3d.PerpendicularTo(self, point0: Rhino.Geometry.Point3d, point1: Rhino.Geometry.Point3d, point2: Rhino.Geometry.Point3d) -> bool
Rhino.Geometry.Vector3d.Reverse(self) -> bool
Rhino.Geometry.Vector3d.Rotate(self, angleRadians: float, rotationAxis: Rhino.Geometry.Vector3d) -> bool
Rhino.Geometry.Vector3d.Subtract(vector1: Rhino.Geometry.Vector3d, vector2: Rhino.Geometry.Vector3d) -> Rhino.Geometry.Vector3d
Rhino.Geometry.Vector3d.ToString(self) -> str
Rhino.Geometry.Vector3d.ToString(self, format: str, formatProvider: System.IFormatProvider) -> str
Rhino.Geometry.Vector3d.Transform(self, transformation: Rhino.Geometry.Transform) -> None
Rhino.Geometry.Vector3d.Unitize(self) -> bool
Rhino.Geometry.Vector3d.VectorAngle(a: Rhino.Geometry.Vector3d, b: Rhino.Geometry.Vector3d) -> float
Rhino.Geometry.Vector3d.VectorAngle(a: Rhino.Geometry.Vector3d, b: Rhino.Geometry.Vector3d, plane: Rhino.Geometry.Plane) -> float
Rhino.Geometry.Vector3d.VectorAngle(v1: Rhino.Geometry.Vector3d, v2: Rhino.Geometry.Vector3d, vNormal: Rhino.Geometry.Vector3d) -> float
Rhino.Geometry.Vector3d.__init__(self, point: Rhino.Geometry.Point3d) -> None
Rhino.Geometry.Vector3d.__init__(self, vector: Rhino.Geometry.Vector3d) -> None
Rhino.Geometry.Vector3d.__init__(self, vector: Rhino.Geometry.Vector3f) -> None
Rhino.Geometry.Vector3d.__init__(self, vector: Rhino.Geometry.Vector3f) -> None
Rhino.Geometry.Vector3d.__init__(self, x: float, y: float, z: float) -> None
Rhino.Geometry.Vector3f.!=(a: Rhino.Geometry.Vector3f, b: Rhino.Geometry.Vector3f) -> operator
Rhino.Geometry.Vector3f.*(point1: Rhino.Geometry.Vector3f, point2: Rhino.Geometry.Vector3f) -> operator
Rhino.Geometry.Vector3f.*(t: float, vector: Rhino.Geometry.Vector3f) -> operator
Rhino.Geometry.Vector3f.*(vector: Rhino.Geometry.Vector3f, t: float) -> operator
Rhino.Geometry.Vector3f.+(point: Rhino.Geometry.Point3f, vector: Rhino.Geometry.Vector3f) -> operator
Rhino.Geometry.Vector3f.+(vector1: Rhino.Geometry.Vector3f, vector2: Rhino.Geometry.Vector3f) -> operator
Rhino.Geometry.Vector3f.-(vector1: Rhino.Geometry.Vector3f, vector2: Rhino.Geometry.Vector3f) -> operator
Rhino.Geometry.Vector3f.-(vector: Rhino.Geometry.Vector3f) -> operator
Rhino.Geometry.Vector3f./(vector: Rhino.Geometry.Vector3f, t: float) -> operator
Rhino.Geometry.Vector3f./(vector: Rhino.Geometry.Vector3f, t: float) -> operator
Rhino.Geometry.Vector3f.<(a: Rhino.Geometry.Vector3f, b: Rhino.Geometry.Vector3f) -> operator
Rhino.Geometry.Vector3f.<=(a: Rhino.Geometry.Vector3f, b: Rhino.Geometry.Vector3f) -> operator
Rhino.Geometry.Vector3f.==(a: Rhino.Geometry.Vector3f, b: Rhino.Geometry.Vector3f) -> operator
Rhino.Geometry.Vector3f.>(a: Rhino.Geometry.Vector3f, b: Rhino.Geometry.Vector3f) -> operator
Rhino.Geometry.Vector3f.>=(a: Rhino.Geometry.Vector3f, b: Rhino.Geometry.Vector3f) -> operator
Rhino.Geometry.Vector3f.Add(point: Rhino.Geometry.Point3f, vector: Rhino.Geometry.Vector3f) -> Point3f
Rhino.Geometry.Vector3f.Add(vector1: Rhino.Geometry.Vector3f, vector2: Rhino.Geometry.Vector3f) -> Rhino.Geometry.Vector3f
Rhino.Geometry.Vector3f.CompareTo(self, other: Rhino.Geometry.Vector3f) -> int
Rhino.Geometry.Vector3f.CrossProduct(a: Rhino.Geometry.Vector3f, b: Rhino.Geometry.Vector3f) -> Rhino.Geometry.Vector3f
Rhino.Geometry.Vector3f.Divide(vector: Rhino.Geometry.Vector3f, t: float) -> Rhino.Geometry.Vector3f
Rhino.Geometry.Vector3f.Divide(vector: Rhino.Geometry.Vector3f, t: float) -> Rhino.Geometry.Vector3f
Rhino.Geometry.Vector3f.EpsilonEquals(self, other: Rhino.Geometry.Vector3f, epsilon: float) -> bool
Rhino.Geometry.Vector3f.Equals(self, obj: Any) -> bool
Rhino.Geometry.Vector3f.Equals(self, vector: Rhino.Geometry.Vector3f) -> bool
Rhino.Geometry.Vector3f.GetHashCode(self) -> int
Rhino.Geometry.Vector3f.Multiply(point1: Rhino.Geometry.Vector3f, point2: Rhino.Geometry.Vector3f) -> float
Rhino.Geometry.Vector3f.Multiply(t: float, vector: Rhino.Geometry.Vector3f) -> Rhino.Geometry.Vector3f
Rhino.Geometry.Vector3f.Multiply(vector: Rhino.Geometry.Vector3f, t: float) -> Rhino.Geometry.Vector3f
Rhino.Geometry.Vector3f.Negate(vector: Rhino.Geometry.Vector3f) -> Rhino.Geometry.Vector3f
Rhino.Geometry.Vector3f.PerpendicularTo(self, other: Rhino.Geometry.Vector3f) -> bool
Rhino.Geometry.Vector3f.Reverse(self) -> bool
Rhino.Geometry.Vector3f.Rotate(self, angleRadians: float, rotationAxis: Rhino.Geometry.Vector3f) -> bool
Rhino.Geometry.Vector3f.Subtract(vector1: Rhino.Geometry.Vector3f, vector2: Rhino.Geometry.Vector3f) -> Rhino.Geometry.Vector3f
Rhino.Geometry.Vector3f.ToString(self) -> str
Rhino.Geometry.Vector3f.ToString(self, format: str, formatProvider: System.IFormatProvider) -> str
Rhino.Geometry.Vector3f.Transform(self, transformation: Rhino.Geometry.Transform) -> None
Rhino.Geometry.Vector3f.Unitize(self) -> bool
Rhino.Geometry.Vector3f.__init__(self, vector: Rhino.Geometry.Vector3d) -> None
Rhino.Geometry.Vector3f.__init__(self, x: float, y: float, z: float) -> None
Rhino.Geometry.VolumeMassProperties.CentroidCoordinatesPrincipalMoments(self, x: System.Double@, xaxis: Rhino.Geometry.Vector3d@, y: System.Double@, yaxis: Rhino.Geometry.Vector3d@, z: System.Double@, zaxis: Rhino.Geometry.Vector3d@) -> bool
Rhino.Geometry.VolumeMassProperties.CentroidCoordinatesPrincipalMomentsOfInertia(self, x: System.Double@, xaxis: Rhino.Geometry.Vector3d@, y: System.Double@, yaxis: Rhino.Geometry.Vector3d@, z: System.Double@, zaxis: Rhino.Geometry.Vector3d@) -> bool
Rhino.Geometry.VolumeMassProperties.Compute(brep: Rhino.Geometry.Brep) -> Rhino.Geometry.VolumeMassProperties
Rhino.Geometry.VolumeMassProperties.Compute(brep: Rhino.Geometry.Brep, volume: bool, firstMoments: bool, secondMoments: bool, productMoments: bool) -> Rhino.Geometry.VolumeMassProperties
Rhino.Geometry.VolumeMassProperties.Compute(brep: Rhino.Geometry.Brep, volume: bool, firstMoments: bool, secondMoments: bool, productMoments: bool, relativeTolerance: float, absoluteTolerance: float) -> Rhino.Geometry.VolumeMassProperties
Rhino.Geometry.VolumeMassProperties.Compute(geometry: Iterable[Rhino.Geometry.GeometryBase]) -> Rhino.Geometry.VolumeMassProperties
Rhino.Geometry.VolumeMassProperties.Compute(geometry: Iterable[Rhino.Geometry.GeometryBase], volume: bool, firstMoments: bool, secondMoments: bool, productMoments: bool) -> Rhino.Geometry.VolumeMassProperties
Rhino.Geometry.VolumeMassProperties.Compute(mesh: Rhino.Geometry.Mesh) -> Rhino.Geometry.VolumeMassProperties
Rhino.Geometry.VolumeMassProperties.Compute(mesh: Rhino.Geometry.Mesh, volume: bool, firstMoments: bool, secondMoments: bool, productMoments: bool) -> Rhino.Geometry.VolumeMassProperties
Rhino.Geometry.VolumeMassProperties.Compute(surface: Rhino.Geometry.Surface) -> Rhino.Geometry.VolumeMassProperties
Rhino.Geometry.VolumeMassProperties.Compute(surface: Rhino.Geometry.Surface, volume: bool, firstMoments: bool, secondMoments: bool, productMoments: bool) -> Rhino.Geometry.VolumeMassProperties
Rhino.Geometry.VolumeMassProperties.Dispose(self) -> None
Rhino.Geometry.VolumeMassProperties.Dispose(self, disposing: bool) -> None
Rhino.Geometry.VolumeMassProperties.Finalize(self) -> None
Rhino.Geometry.VolumeMassProperties.Sum(self, summand: Rhino.Geometry.VolumeMassProperties) -> bool
Rhino.Geometry.VolumeMassProperties.Transform(self, xform: Rhino.Geometry.Transform) -> bool
Rhino.Geometry.VolumeMassProperties.WorldCoordinatesPrincipalMoments(self, x: System.Double@, xaxis: Rhino.Geometry.Vector3d@, y: System.Double@, yaxis: Rhino.Geometry.Vector3d@, z: System.Double@, zaxis: Rhino.Geometry.Vector3d@) -> bool
Rhino.Geometry.VolumeMassProperties.WorldCoordinatesPrincipalMomentsOfInertia(self, x: System.Double@, xaxis: Rhino.Geometry.Vector3d@, y: System.Double@, yaxis: Rhino.Geometry.Vector3d@, z: System.Double@, zaxis: Rhino.Geometry.Vector3d@) -> bool
